[
    {
        "id": 1,
        "timestamp_start": 0.72,
        "timestamp_end": 90.86,
        "slide_description": "O slide analisado é um plano de ensino ou cronograma detalhado para a disciplina de \"Arquitetura de Computadores\" (OAC), ministrada pelo \"Prof. Marcus Vinicius Lamar\" no \"Departamento de Ciência da Computação\" da \"Universidade de Brasília\". O documento original é identificado como \"OAC_A_Plano_2021-2_v0.docx\" e se encontra na \"Página 4 de 4\".\n\nO conteúdo principal é uma tabela com o seguinte cronograma de tópicos e atividades, organizado por semanas (numeradas de 5 a 15) e datas:\n\n**Semana 5 (21/2 - 23/2):**\n*   **Tópico Esquerdo:** 10) Arit. Computacional: Fracionários, IEEE 754 (C.3)\n*   **Tópico Direito:** 11) Outras Arquiteturas (T5)\n\n**Semana 6 (28/2 - 2/3):**\n*   **Tópico Esquerdo:** FERIADO\n*   **Tópico Direito:** Lab 1A: Software – Rars (T6)\n\n**Semana 7 (7/3 - 9/3):**\n*   **Tópico Esquerdo:** Lab 1B: Software – Compilador C\n*   **Tópico Direito:** Lab 2: Hardware – Verilog – ULA (T7)\n\n**Semana 8 (14/3 - 16/3):**\n*   **Tópico Esquerdo:** 1ª Prova (P1)\n*   **Tópico Direito:** 12) Processador Uniciclo: Unidade Operativa (C.4) (T8)\n\n**Semana 9 (21/3 - 23/3):**\n*   **Tópico Esquerdo:** 13) Processador Uniciclo: Unidade de Controle (C.4) (L1)\n*   **Tópico Direito:** Lab 3: Processador Uniciclo(T9) (L2)\n\n**Semana 10 (28/3 - 30/3):**\n*   **Tópico Esquerdo:** 14) Processador Multiciclo: Unidade Operativa (C.4)\n*   **Tópico Direito:** 15) Processador Multiciclo: Unidade de Controle (C.4) (T10)\n\n**Semana 11 (4/4 - 6/4):**\n*   **Tópico Esquerdo:** Lab 4: Processador Multiciclo\n*   **Tópico Direito:** 16) Processador Pipeline: Conceitos (C.4)(T11)(L3)\n\n**Semana 12 (11/4 - 13/4):**\n*   **Tópico Esquerdo:** 17) Pipeline: Unidade Operativa e Controle (C.4)\n*   **Tópico Direito:** Lab 5: Processador Pipeline(T12)\n\n**Semana 13 (18/4 - 20/4):**\n*   **Tópico Esquerdo:** 18) Exceção e Interrupção (C.4) (L1)\n*   **Tópico Direito:** 19) Memória: Hierarquia (C.5) (T13)\n\n**Semana 14 (25/4 - 27/4):**\n*   **Tópico Esquerdo:** 19.1) Memória: Cache (C.5)\n*   **Tópico Direito:** 2ª Prova (P2) (T14) (L5)\n\n**Semana 15 (2/5 - 4/5):**\n*   **Tópico Esquerdo:** Prova Substitutiva\n*   **Tópico Direito:** Apresentação dos Projetos (PR)(T15)\n\nO plano aborda uma gama fundamental de tópicos em arquitetura de computadores, incluindo aritmética computacional (com foco em ponto flutuante IEEE 754), diferentes organizações de processadores (uniciclo, multiciclo e pipeline, com suas unidades de controle e operativas), tratamento de exceções e interrupções, e hierarquia de memória, incluindo cache. A disciplina também inclui laboratórios práticos com ferramentas de software (Rars e compilador C) e hardware (Verilog para ULA) e projetos, além de avaliações periódicas.\n\nNão há diagramas (Datapath, Pipeline, Hierarquia de Memória) ou trechos de código (Assembly, C, Verilog) visíveis diretamente neste slide; o conteúdo é estritamente textual e descritivo do cronograma da disciplina.",
        "transcription": "Então, boa tarde, pessoal. Vamos para mais uma aulinha de OAC. Hoje é dia 9 de março, e dia 9 de março nós temos o Laboratório 2. O que é esse Laboratório 2? O Laboratório 1 foi software, para a gente ver como o Rars simula, implementa, monta a linguagem Assembly do RISC-V. E hoje a gente vai começar com um projeto de hardware. Só que esse primeiro laboratório é mais para a gente se acostumar com uma ferramenta que, quando era presencial, era muito requisitada em todos os outros laboratórios. Mas como agora nós não estamos no presencial, então a gente vai utilizar essa ferramenta, que é o Quartus, apenas nesse laboratório, para vocês terem uma noção do que é uma implementação em FPGA. Então, a gente vai ter só esse laboratóriozinho de hardware aqui. Ah, e os outros laboratórios, professor? Vai ser tudo no DcS, coleguinha de vocês. Então, Laboratório 2, Hardware, Verilog e ULA. Baixem aqui do Aprender, que eu acabei de colocar aqui, esse Laboratório 2 aqui, que é um ZIP. Ao deszipar... Cadê? Cadê?",
        "video_source": "OAC_2022-03-09.mp4"
    },
    {
        "id": 2,
        "timestamp_start": 90.86,
        "timestamp_end": 135.86,
        "slide_description": "Como Engenheiro de Computação Sênior, analiso o slide e o conteúdo anotado da aula de Arquitetura de Computadores (OAC) para extrair informações relevantes para um sistema de busca semântica (RAG).\n\n**Contexto Geral:**\nO slide representa uma tela de apresentação em uma conferência web para uma aula de Arquitetura de Computadores (OAC) da Universidade de Brasília (UnB), possivelmente do semestre 2021-2. O tempo decorrido da sessão é de 02:01. O apresentador é identificado como \"Marcus Vinicius Lam...\". O painel esquerdo da interface da conferência exibe \"MENSAGENS\", com subseções para \"Perguntas\" e \"Bate-papo público\", contendo mensagens de boas-vindas (\"Bem vindos à sala de aula de OAC!\"), status da gravação (\"Esta sessão está sendo gravada.\") e instruções para a plataforma (\"Para mais informações, clique aqui. Novo na plataforma? Experimente o tour!\"). Há também mensagens de \"Boa tarde\" de diversos usuários, e uma lista parcial de \"USUÁRIOS (12)\".\n\n**Conteúdo Principal – Explorador de Arquivos:**\nO cerne do slide é uma janela do Explorador de Arquivos do Windows, apresentando o conteúdo de um arquivo compactado `Lab2.zip`. O caminho de navegação indica a estrutura do curso: `kiko > Disciplinas > UnB > OAC > 2021-2 > Lab2 > Lab2.zip`. Isso contextualiza o conteúdo como materiais para o \"Laboratório 2\" da disciplina de Arquitetura de Computadores.\n\n**Arquivos e Detalhes Técnicos do Lab2.zip:**\nDentro do `Lab2.zip`, são listados 5 itens, que são os seguintes:\n1.  `ALU.qar`: Um arquivo do tipo \"Arquivo QAR\". Possui tamanho compactado de 22 KB e data de modificação em 22/03/2021 às 02:18. A extensão `.qar` tipicamente refere-se a um arquivo de projeto ou archive do software Intel Quartus Prime (anteriormente Altera Quartus), sugerindo um componente de Unidade Lógica e Aritmética (ALU) implementado em um Hardware Description Language (HDL), como Verilog ou VHDL, para síntese em FPGAs.\n2.  `DECODER7.qar`: Também um \"Arquivo QAR\", com tamanho compactado de 24 KB e data de modificação em 22/03/2021 às 02:20. Semelhante ao `ALU.qar`, indica um componente de decodificador (possivelmente de 7 segmentos ou 7-para-X) para implementação em hardware.\n3.  `Lab2-DE_A.pdf`: Um documento Adobe Acrobat (PDF) com tamanho compactado de 907 KB, modificado em 07/09/2021 às 18:30. Este arquivo está realçado no explorador, indicando que é o foco atual do apresentador. O nome sugere que é um roteiro ou descrição do \"Laboratório 2 - Parte A\", provavelmente contendo as especificações e instruções para a implementação dos componentes digitais.\n4.  `OAC_LAb.pdf`: Outro documento Adobe Acrobat (PDF) de 83 KB, modificado na mesma data e hora (07/09/2021 às 18:30). Poderia ser um documento complementar, como um resumo do laboratório ou material de apoio.\n5.  `Tutorial_Quartus_Primev22.pdf`: Um documento Adobe Acrobat (PDF) de 2.351 KB, modificado em 05/03/2020 às 16:21. Este é claramente um tutorial para a versão 22 do software Intel Quartus Prime, confirmando o uso dessa ferramenta para o desenvolvimento de circuitos digitais (FPGA) na disciplina de Arquitetura de Computadores.\n\n**Ausência de Diagramas e Código:**\nNão há diagramas explícitos de Datapath, Pipeline, Hierarquia de Memória ou qualquer outro tipo de diagrama de arquitetura visível no slide. Similarmente, não há trechos de código (Assembly, C, Verilog ou VHDL) diretamente visíveis, embora a presença de arquivos `.qar` e o tutorial do Quartus Prime impliquem fortemente que o desenvolvimento de hardware utilizando HDLs seja parte integrante do laboratório.\n\n**Outras Informações Contextuais:**\nUm rótulo sobreposto na parte inferior do explorador de arquivos indica \"Due 9 de março de 2022\", que é uma data de entrega ou prazo relacionada ao laboratório. Abaixo da janela do explorador, é visível o texto \"Semana 8\", indicando o progresso da disciplina. O professor está visível em um feed de vídeo no canto inferior direito da tela.\n\n**Conclusão para RAG:**\nEste slide fornece um forte contexto de um curso prático de Arquitetura de Computadores focado em **design de lógica digital e implementação em FPGA**, utilizando o software Intel Quartus Prime. Os recursos incluem componentes pré-projetados (ALU, Decodificador) e documentação instrutiva para o laboratório, bem como um tutorial para a ferramenta de desenvolvimento. A ausência de diagramas de alto nível ou código diretamente exposto sugere que o foco da apresentação atual é a distribuição e organização dos materiais para o laboratório.",
        "transcription": "Ao descompactar, não vou descompactar aqui porque o meu já está descompactado, vai criar esses cinco arquivos aqui. O tutorial Quartus Prime v22, o roteiro desse Laboratório 2 e o Laboratório 2, a apresentação, que é essa que eu vou fazer agora. E mais ainda dois arquivos .qar, que são arquivos do Quartus compactados do projeto. E desses dois projetos, que é o que a gente vai trabalhar na aula de hoje. Então, primeiro vamos ver a parte teórica disso aqui. Tá, então... Cadê? Cadê? Cadê?",
        "video_source": "OAC_2022-03-09.mp4"
    },
    {
        "id": 3,
        "timestamp_start": 135.86,
        "timestamp_end": 146.27,
        "slide_description": "Como Engenheiro de Computação Sênior, procedo à análise do slide apresentado, extraindo e descrevendo o conteúdo para um sistema de busca semântica (RAG).\n\n**Contexto Geral:**\nA imagem exibe uma captura de tela de uma sessão de aula online, identificada como \"Sala de Aula de OAC\" (Arquitetura de Computadores). A sessão está em andamento, como indicado pelo temporizador \"02:27\" e o ícone de gravação ativo. A tela está dividida entre um painel de comunicação à esquerda e uma área principal que exibe a tela compartilhada do instrutor, juntamente com a sua própria imagem de webcam no canto inferior direito.\n\n**Conteúdo do Painel Esquerdo (Comunicação da Conferência):**\nO painel lateral, intitulado \"MENSAGENS\", apresenta opções de interação da plataforma de conferência. A seção \"Bate-papo público\" está selecionada, mostrando as seguintes informações:\n*   **Mensagens da Sala:**\n    *   \"Bem vindos à sala de aula de OAC!\"\n    *   \"Esta sessão está sendo gravada.\"\n    *   \"Para mais informações, clique aqui. Novo na plataforma? Experimente o tour!\"\n*   **Interações dos Participantes (com carimbos de tempo):**\n    *   Eduarda Costa de M... 13:59 \"Boa tarde\"\n    *   Victor Hugo Rodrig... 14:00 \"Boa tarde\"\n    *   Maycon Vinnycius Sil... 14:00 \"Boa tarde\"\nAbaixo da seção de mensagens, há uma área para \"NOTAS\" (Notas comparti...) e uma lista de \"USUÁRIOS (12)\" presentes na sala, incluindo o professor (\"Marcus... (Você)\") e outros alunos como Andre Carval..., Arthur Brasa..., Eduarda Cost..., Eduardo Ferr..., Filipe de Sou..., Gabriel Kenji..., Gustavo Rodr..., Maycon Vinni..., Michel Luis D... e Ualiton Ventu....\n\n**Conteúdo da Área Principal (Tela Compartilhada):**\nA área principal da tela exibe um navegador web acessando o endereço `https://aprender3.unb.br/course/view.php?id=11880`, indicando o uso de um Ambiente Virtual de Aprendizagem (AVA), provavelmente Moodle, da Universidade de Brasília (UnB). Dentro do navegador, uma janela do Explorador de Arquivos do Windows está sendo mostrada, focada na extração de conteúdo de um arquivo ZIP.\n\n*   **Caminho do Arquivo:** O caminho de navegação do explorador é `kiko > Disciplinas > UnB > OAC > 2021-2 > Lab2 > Lab2.zip`. Isso sugere que o conteúdo pertence à disciplina de Arquitetura de Computadores (OAC), ministrada no segundo semestre de 2021, e o professor está demonstrando os arquivos do Laboratório 2 (Lab2) contidos em um arquivo `Lab2.zip`.\n*   **Interface do Explorador de Arquivos:**\n    *   **Menu de Faixa (Ribbon):** \"Arquivo\", \"Início\", \"Compartilhar\", \"Exibir\". Há uma aba contextual \"Ferramentas de Pasta Compactada\" com a opção \"Extrair\".\n    *   **Painel de Navegação (Acesso Rápido):** Inclui atalhos para \"UnB\", \"Documentos\", \"Downloads\", \"Projeto-FAPDF-Biometria\", \"Pesquisa\", \"Área de Trabalho\", \"Google Drive\", \"ArquivosC\", \"Lab2\", \"STG-backups-FF-97.0.1\", \"Dropbox\", \"OneDrive - Personal\", \"OneDrive - unb.br\" e \"Este Computador\".\n    *   **Conteúdo do `Lab2.zip` (5 itens):**\n        *   `ALU.qar`\n            *   Tipo: Arquivo QAR\n            *   Tamanho Compacta...: 22 KB\n            *   Protegido: Não\n            *   Tamanho: 22 KB\n            *   Razão: 1%\n            *   Data de modificação: 22/03/2021 02:18\n        *   `DECODER7.qar`\n            *   Tipo: Arquivo QAR\n            *   Tamanho Compacta...: 24 KB\n            *   Protegido: Não\n            *   Tamanho: 24 KB\n            *   Razão: 2%\n            *   Data de modificação: 22/03/2021 02:20\n        *   `LAB2-DEV1_a.pdf`\n            *   Tipo: Adobe Acrobat Document\n            *   Tamanho Compacta...: 907 KB\n            *   Protegido: Não\n            *   Tamanho: 1.026 KB\n            *   Razão: 12%\n            *   Data de modificação: 07/09/2021 18:30\n        *   `OAC_LAB2.pdf`\n            *   Tipo: Adobe Acrobat Document\n            *   Tamanho Compacta...: 83 KB\n            *   Protegido: Não\n            *   Tamanho: 93 KB\n            *   Razão: 12%\n            *   Data de modificação: 07/09/2021 18:26\n        *   `Tutorial_Quartus_Primev22.pdf`\n            *   Tipo: Adobe Acrobat Document\n            *   Tamanho Compacta...: 2.351 KB\n            *   Protegido: Não\n            *   Tamanho: 2.585 KB\n            *   Razão: 10%\n            *   Data de modificação: 05/03/2020 16:21\n*   **Informação Adicional:** Abaixo do explorador de arquivos, lê-se \"Due 9 de março de 2022\", indicando uma data de entrega, e \"Semana 8\", provavelmente o título ou tópico da aula corrente.\n\n**Análise Técnica dos Arquivos:**\nA presença de arquivos com a extensão `.qar` (Quartus Archive) é um forte indicativo de que a disciplina de Arquitetura de Computadores envolve o design e implementação de hardware digital, provavelmente utilizando Field-Programmable Gate Arrays (FPGAs) e o software Quartus Prime da Intel (anteriormente Altera).\n*   `ALU.qar`: Sugere um projeto ou exercício de laboratório focado na Unidade Lógica e Aritmética, um componente fundamental de um processador.\n*   `DECODER7.qar`: Aponta para um projeto envolvendo um decodificador, que pode ser tanto um decodificador genérico com 7 saídas/entradas quanto um decodificador para displays de 7 segmentos, comum em projetos de lógica digital.\nOs arquivos `.pdf` (`LAB2-DEV1_a.pdf`, `OAC_LAB2.pdf`) são documentos de laboratório, provavelmente fornecendo instruções e especificações para os projetos de hardware. O arquivo `Tutorial_Quartus_Primev22.pdf` confirma explicitamente o uso do ambiente de desenvolvimento Quartus Prime versão 22, uma ferramenta essencial para a síntese, simulação e implementação em FPGAs.\n\n**Ausência de Diagramas Específicos:**\nNão há diagramas explícitos de Datapath, Pipeline, ou Hierarquia de Memória visíveis nesta tela. O foco está na organização e acesso a arquivos de projeto e documentação relacionados a um laboratório prático de Arquitetura de Computadores.\n\n**Conclusão:**\nO slide detalha o acesso aos materiais do \"Laboratório 2\" da disciplina de \"Arquitetura de Computadores\" da UnB, ministrada pelo Prof. Marcus Vinicius Lam.... Os materiais incluem arquivos de projeto Quartus (`ALU.qar`, `DECODER7.qar`) para implementação de componentes de hardware digital (como uma ALU e um decodificador) e documentação (`LAB2-DEV1_a.pdf`, `OAC_LAB2.pdf`, `Tutorial_Quartus_Primev22.pdf`) que guia os alunos no uso do software Quartus Prime 22 e na realização dos exercícios. A data de entrega do laboratório é 9 de março de 2022, e a aula corresponde à \"Semana 8\" do curso.",
        "transcription": "Beleza.",
        "video_source": "OAC_2022-03-09.mp4"
    },
    {
        "id": 4,
        "timestamp_start": 146.27,
        "timestamp_end": 181.27,
        "slide_description": "Como um Engenheiro de Computação Sênior, analiso o slide apresentado no contexto de uma aula de Arquitetura de Computadores. O conteúdo visual é dominado por um slide de apresentação institucional, focado na introdução de tópicos de hardware.\n\n**Transcrição e Descrição do Conteúdo do Slide:**\n\nO slide é intitulado \"Síntese de Hardware\", apresentado em uma fonte grande e proeminente, sugerindo que este é o tema principal da aula ou seção. Abaixo do título principal, há dois termos chave listados: \"Verilog\" e \"Altera DE1-SoC\", indicando as ferramentas e a plataforma de hardware específicas que serão abordadas para a síntese de hardware.\n\nNo cabeçalho do slide, encontram-se as seguintes informações institucionais:\n*   \"Universidade de Brasília\"\n*   \"Departamento de Ciência da Computação\"\n\nNo canto superior direito, em um logotipo menor, repete-se a afiliação institucional e adiciona detalhes específicos da disciplina e do professor:\n*   \"Universidade de Brasília\"\n*   \"Departamento de Ciência da Computação\"\n*   \"CIC0003 - Introdução aos Sistemas Computacionais\"\n*   \"Prof. Marcus Vinicius Lamar\"\n\nO fundo do slide apresenta um padrão geométrico abstrato em tons de verde e roxo/lilás, que parece ser um elemento de design ou parte da identidade visual da universidade ou do departamento. Não há diagramas complexos como datapath, pipeline ou hierarquia de memória visíveis neste slide, sendo o foco principal a apresentação textual do tema e das tecnologias.\n\nEm resumo, o slide define o escopo da aula como \"Síntese de Hardware\", com um enfoque prático e teórico em \"Verilog\" e na plataforma \"Altera DE1-SoC\", ministrada pelo Professor Marcus Vinicius Lamar, dentro do curso de Introdução aos Sistemas Computacionais da Universidade de Brasília, Departamento de Ciência da Computação.",
        "transcription": "Então, o objetivo desse laboratório é apresentar para vocês a linguagem de descrição de hardware Verilog e como se sintetiza circuitos em Verilog, como que se testa, como que se analisa. Tá? Circuitos em FPGA. No caso, a gente sempre usa o kit de desenvolvimento da Altera, que não é mais Altera, agora é Intel. A Intel comprou a Altera, então a Intel agora é fabricante de FPGA. E desse modelo aqui, o DE1-SoC, se vocês quiserem procurar na internet.",
        "video_source": "OAC_2022-03-09.mp4"
    },
    {
        "id": 5,
        "timestamp_start": 181.27,
        "timestamp_end": 3693.91,
        "slide_description": "Como um Engenheiro de Computação Sênior, analiso o slide e o conteúdo anotado da aula de Arquitetura de Computadores.\n\n**Informações Contextuais do Slide:**\nO slide pertence à disciplina \"UnB/CIC 116394 – Organização e Arquitetura de Computadores\" da \"Universidade de Brasília\", Departamento de Ciência da Computação, ministrada pelo \"Prof. Marcus Vinicius Lima\".\n\n**Título do Slide:**\nO título principal do slide é \"SystemVerilog – aspectos básicos\".\n\n**Conteúdo Textual e Exemplos de Código SystemVerilog:**\nO slide detalha os tipos de dados fundamentais em SystemVerilog, focando na distinção entre `wire`, `reg` e `logic`, e introduzindo brevemente tipos abstratos.\n\n1.  **Tipos de Dados:**\n    *   **wire:**\n        *   Definição: \"define um ou conjunto de fios\".\n        *   Exemplo 1: `wire a;` com o comentário `// a é um fio`.\n        *   Exemplo 2: `wire [7:0] b;` com o comentário `/* b é um conjunto de 8 fios {b[7],b[6],...,b[1],b[0]}*/`.\n    *   **reg:**\n        *   Definição: \"define um registrador (síncrono ou assíncrono)\".\n        *   Exemplo 1: `reg a;` com o comentário `// a é um latch ou flip-flop`.\n        *   Exemplo 2: `reg [7:0] b;` com o comentário `/* b é um conjunto de 8 latches ou flip-flops */`.\n    *   **logic:**\n        *   Definição: \"define um registrador ou wire\".\n        *   Exemplo 1: `logic a;` com o comentário `// a é um elemento definido pelo sintetizador`.\n        *   Exemplo 2: `logic [7:0] b;` com o comentário `/* b é um elemento de 8 bits definido pelo sintetizador */`.\n2.  **Tipos abstratos (32 bits):**\n    *   São mencionados `integer` e `real (IEEE 754)`.\n\n**Conteúdo Visual e Diagramas/Esboços:**\n\nNo canto superior direito do slide, há um conjunto de esboços que complementam as definições de `wire` e `reg`:\n\n1.  **Esboços de `wire`:**\n    *   É ilustrado um fio único (`a`) conectado a uma caixa com um ponto de interrogação (`?`) e uma saída rotulada com '1', representando um sinal lógico binário.\n    *   Ao lado, um conjunto de várias linhas paralelas, rotuladas como 'b' ou 'bc?', simbolizando um barramento de múltiplos fios, como `wire [7:0] b`. Há também um sinal isolado com '1' e '0' em suas extremidades, reforçando a natureza binária dos sinais.\n\n2.  **Esboço de `reg` (Circuito Sequencial):**\n    *   Abaixo dos exemplos de `wire` e `reg`, há um diagrama esquemático de um elemento de circuito sequencial, possivelmente um latch ou um flip-flop.\n    *   O diagrama mostra uma estrutura com entradas e saídas. Uma entrada é rotulada como `TS?` (ou `TST`) com o valor '1', e uma saída é rotulada como `TEQ?` (ou `TEA?` ou `TER?`) também com o valor '1'.\n    *   Uma seta curva é desenhada, indicando uma entrada de clock, característica de circuitos síncronos.\n    *   Componentes internos do elemento sequencial, como portas lógicas básicas (aparentemente AND/OR ou multiplexadores simplificados), são desenhados para representar sua funcionalidade. Este esboço serve para visualizar o conceito de um registrador (latch ou flip-flop) que armazena estado, em contraste com o `wire` que simplesmente propaga sinais.",
        "transcription": "Então, qual é a grande motivação da criação de uma Linguagem de Descrição de Hardware? Uma HDL. Tá? Então, a principal motivação é... Se a gente tem sistemas muito complexos, como por exemplo esse aqui, a gente não consegue implementar esse sistema a partir de transistores e portas lógicas. A gente vai ter que ter uma ferramenta que permita eu descrever o circuito em um nível mais alto do que transistores e portas lógicas. Essa descrição em um nível mais alto, ao ser compilada, gera então a descrição de nível mais baixo. Como se fosse uma linguagem de alto nível e os transistores fossem o Assembly. Quer dizer, linguagem de máquina, não Assembly. Certo? Então, a linguagem de alto nível é compilada, gerando então a descrição do circuito em transistores. Certo? Além do... As duas principais... Linguagens de descrição de hardware hoje em dia é o VHDL. Certo? Que o professor Marcelo é perito em VHDL. O Verilog, que eu acho que é mais simples de se entender do que VHDL. E o SystemVerilog. Tá? Que é o Verilog um passo a mais. Então, se Verilog é C, a SystemVerilog é o C++. Certo? Então, ele possibilita até a definição de... É, não é uma linguagem de programação, é uma linguagem de descrição de hardware. Tá? Então, que a gente vai... É, nós não vamos trabalhar muito com SystemVerilog, mas eu vou dar umas palhinhas de SystemVerilog. Só pra gente ver qual é a diferença dos dois aqui. Certo? Aqui alguns gráficos de utilização, quanto que é utilizado dessas linguagens. Ah, além de VHDL, Verilog e SystemVerilog, SystemC. SystemC é uma linguagem que surgiu. Tá? Há pouco tempo. E que tava crescendo. Agora eu não sei mais se continua crescendo ou não. Porque eu parei de acompanhar. Tá? Então, esse aqui é uma descrição mais próxima da linguagem C. Tá? Que gera hardware também. E até mesmo o próprio C e C++ também pode gerar hardware. Tá? Mas de cara a gente pode ver que Verilog é muito utilizado, né? Para ASICs. O que que é ASICs? É... Application Specific Integrated Circuits. Então, circuitos integrados de aplicações específicas. Enquanto o Verilog e o VHDL são as duas principais para uso em FPGA. Field Programmable Gate Array. Então, array de portas programável no campo. Certo? Beleza. Então, nós vamos... O Marcelo gosta do VHDL e eu gosto do Verilog. Então, quando tinha a turma de OAC do Marcelo, eles viam tudo que a gente vai ver aqui em Verilog. Eles viam em VHDL. Que é muito interessante. Porque o Flávio Vidal vê tudo em esquemático. Né? Então, ele desenha tudo em esquemático. Que no final é o que vocês vão usar. Tá? Porque no remoto não tem como usar outra coisa. Então, Verilog. Tá? Então, histórico. Verilog foi criado em 1974, em 1975. Tá? Por essa empresa, Gateway. Né? Que depois foi adquirida pela Cadence. Que é um grande fabricante. Grande... Fabricante de software de simulação. Em 1990, virou uma de domínio público. Então, foi o OpenVerilog. Né? E em 1995, tornou-se um padrão IEEE. Padrão IEEE 1364. Que foi revisado em 2005. E em 2012, foi criado o IEEE 1800. Que é o SystemVerilog. Certo? Tem vários produtos bem recentes. Então, são usados para projetos de ASICs. O que significa isso? Que tu vai gerar todos os transistores do teu circuito no silício. E também usados em circuitos em FPGA. Então, o que seria isso? Eu já tenho bloquinhos prontos. Né? De circuitos no meu circuito integrado. E eu só preciso interligar esses bloquinhos. Tá? Então, é esse aqui. Então, significa um arranjo de portas programável em campo. O que significa programável em campo? Em campo significa que o usuário, na hora da utilização, é que vai programar esse dispositivo. Tá? Não é que nem esse aqui, que o fabricante tem que fabricar o chip para depois o usuário poder utilizar. Não. Aqui o circuito é genérico e o usuário cria o circuito que ele quer em cima desse array de portas. Ok. Então, o Verilog tem quatro níveis de abstração. O nível de abstração mais baixo é o nível de layout. Onde, então, a gente tem esse tipo de descrição do circuito. Quer dizer, isso aqui, se eu ver um circuito integrado e der um zoom bem grande, eu vou poder ver essas conexões aqui. Isso aqui nada mais é do que dois transistores. Não. Dois transistores aqui e dois transistores aqui. Certo? Então, aí eu tenho as entradas A e D, que são esses pontos aqui e aqui. E VDD e GND. Então, se a gente não sabe microeletrônica, como que a gente projeta esses transistores, a gente fica complicado entender isso aqui. Os projetistas de microeletrônica olham para isso aqui e dizem, ah, isso é uma porta NAND. Certo? De carga. Mas nós não. Então, o que a gente tem que fazer? A gente usa essa abstração aqui. Agora, essa abstração aqui a gente já sabe como é que funciona. Transistor CMOS. Aquilo tipo PMOS e aquilo tipo NMOS. E se vocês lembrarem lá das aulas de Circuitos Lógicos ou ISC, vocês vão ver que isso aqui nada mais é do que uma porta NAND. Certo? Mas para isso vocês têm que saber como é que funcionam esses transistores. Se vocês não sabem como é que funciona um transistor, esse aqui e esse aqui têm uma ligação direta. Um é a representação do outro. Essa aqui é a implementação física. E essa aqui é a simbólica dessa representação física. E que isso aqui também eu posso apresentar de um nível de abstração mais alto. Desse jeito aqui. Uma porta NAND de duas entradas. Então, esse segundo nível aqui é o segundo nível de abstração no Verilog. Quer dizer, eu posso, ao invés de descrever o tamanho do transistor, dopagem, etc e tal. Eu posso desenhar todo o meu circuito utilizando portas lógicas. Que ele, que eu digo o compilador Verilog. Ele vai pegar essa nossa representação e vai gerar isso aqui. Certo? Então, nós temos um nível de abstração mais alto. Que é o nível de portas lógicas. A gente pode ter um nível de abstração mais alto ainda. Que é o nível de transferência de registradores. Ou RTL. Register Transfer Level. O que seria esse nível? Esse nível é a gente poder utilizar em um circuito. Então, isso aqui o que que é? Isso aqui é um flip-flop. Do tipo D. A gente sabe que aqui dentro tem portas lógicas. Se eu pedisse para vocês desenhar como é que é as portas lógicas. Aqui dentro vocês é só dando uma olhadinha lá no material de CL. Vocês saberiam me dizer quais são as portas lógicas que tem aqui dentro. Qual é o circuito que tem aqui dentro. Então, nesse nível de transferência de registradores. A gente trabalha então com um nível maior do que de portas lógicas. Posso usar portas lógicas? Claro que sim. Mas aqui eu posso usar esses componentes. Flip-flop tipo D, por exemplo. E o nível mais alto. Que eu posso ter. É o nível comportamental. Ou behavioral level. Onde então eu não vou especificar o circuito. Aqui tudo eu estou especificando o circuito. Dada essa descrição. Eu sei o que tem aqui dentro. São portas lógicas. Então eu passo para esse nível de descrição em portas lógicas. Eu tenho essa descrição. Eu passo para o circuito. E para o circuito eu sei como é que é a implementação no chip. Mas aqui não. Aqui eu não vou descrever o circuito. Eu vou descrever o comportamento. Que eu quero do circuito. Qual é o comportamento esperado. Então por exemplo. Escrever em Verilog isso aqui. `assign y = b / c;` (se y = b / c). Então. Isso aqui fica fácil. Entender que o `y`. Deve ser a divisão de B por C. Mas eu não estou especificando aqui. Qual é o circuito que faz a divisão. Eu simplesmente disse. B dividido por C. Isso vai dar o A. Certo? Então é o nível comportamental. Estou especificando o comportamento. Não o circuito em si. Então a gente vai trabalhar muito nesses dois níveis aqui. Nessa aula de hoje. Vamos trabalhar muito na aula de hoje. Alguns aspectos básicos. E aqui eu vou dar alguns aspectos básicos do SystemVerilog. Que é um pouquinho mais avançado. Do que o Verilog. Então primeiro. Como é que se representa números? Lembra que dentro. Nós vivemos ainda num mundo. Onde a gente tem eletrônica digital. Baseado em os níveis alto e baixo. Certo? Então a nossa. Toda a nossa computação. A nossa eletrônica digital. É baseada nesse princípio. Que eu tenho um nível lógico baixo. E um nível lógico alto. Então. Tudo dentro do chip. Vai ter que ser zeros e uns. É tudo binário lá dentro. Mas eu posso utilizar. Outras bases. Para representar esses números. Que lá no fundo. Vão ser binários. Então. A nossa representação de números. Segue esse modelinho aqui. É o tamanho em bits. Apóstrofe. Qual é a base. Que eu estou representando esse número. Que eu estou falando desse número aqui. Então. Por exemplo. Eu queria representar. O número 255. Que está na base decimal. Em 16 bits. Então eu posso dizer. Olha. Esse aqui é o número 255. 255 é decimal. Em 16 bits. O que vai ser efetivamente criado. Vai ser criado isso aqui. 16 bits zeros. Desculpa. 8 bits zeros. E 8 bits uns. Para que é o número 255. Em 16 bits. Posso representar esse número aqui. Em hexadecimal. Então. Por exemplo. 8. Apóstrofe. H. Indica que está em hexadecimal. 9A. Então. Esse aqui. É um número de 8 bits. 8. Apóstrofe. H. Indica que está em hexadecimal. 9A. Então. Esse aqui. É o 9. Os primeiros 4 bits. E 10. Que é o segundo. Os últimos 4 bits. Que é o A. Certo. Então. Posso representar isso em hexadecimal. Posso usar em binário também. Então. Em binário. Por exemplo. Representar o número de 32 bits. Binário. Com 010. Tá. Então. A gente tem que cuidar. Que isso aqui. É um número. Ele vai se considerar esse aqui. Então. Em hexadecimal. 9A. Então. Em hexadecimal. 9A. Então. Ele vai se considerar esse aqui. Sempre positivo. Ele vai gerar. Então. Esse número. Em 32 bits. 1010. Ok. Em octal. Em octal. Né. Que agora. Está caindo de uso. Né. Se representa desse jeito. Então. Eu quero representar um número. De 8 bits. E. Que seja o número. 21. Em octal. Então. Ele vai representar. Isso aqui. Tá. Octal. A gente pode dividir. Se assim começa a decimal. Em octal. Octal. Também são. Também são. Bases relacionadas. Com a potência. No caso. 2 na 3. É 8. Né. Então. Eu vou dividir. De 3 em 3 bits. Tá. Então. O 1. 001. O 2. 010. E para completar. Os 8 bits. 00. E aqui. Eu estou mostrando. Apenas. Que a gente pode. Usar esse. Underscore. Né. Para separar esse. Essa faixa. Daquela faixa. Posso botar. Um underscore. Aqui. Só para facilitar. Nosso entendimento. De quando a gente. Vê a descrição. Verilog. O que aquilo ali. Está. Está representando. Números negativos. Tá. A gente representa. Desse jeito. Aqui. O menos. Fica aqui fora. Tá. Não fica aqui dentro. Tá. Então. Esse aqui. É o número. Menos. 3. 1. 1. 1. 0. 1. Que corresponde. Ao número. Menos. 3. Certo. Na descrição. Verilog. A gente pode. Escrever. Assim. Então. Esse aqui. É como. Se representa. Os nossos. Valores. Numéricos. Esses valores. Eles podem. Ser. O dígito. 0. O dígito. 1. X. E Z. Tá? Então, o que que é o X e o Z? O X significa indeterminado. O que que significa indeterminado? Eu liguei aqui esse circuito. Então, se eu ligo esse circuito aqui. Se esses dois transistores estiverem abertos. Qual é o nível lógico da saída? É zero? É um? É indeterminado? Não é nenhum dos três, tá? Como aqui essa chave tá aberta, uma chave aberta, eu posso considerar isso aqui como sendo um resistor de valor infinito. Assim esse aqui também, um resistor de valor infinito. Certo? Então, o que isso aqui significa, um resistor de tamanho infinito? Significa uma impedância alta. Certo? Então, ao invés de chamar de resistência, se chama de impedância. Uma impedância alta. Logo, qual é o nível que tem aqui? É o Z, alta impedância. Significa fio não conectado. Certo? Então, agora você já sabe que o nível desconhecido é diferente do Z. Tá? Não tinha nem falado em terra. Terra seria esse nível aqui, VCC seria esse nível aqui. Tá? Então, o nível desconhecido é quando eles estão ligados, mas eu não posso definir qual é o nível lógico, se é zero ou um. Alta impedância é quando os dois estão desligados. Eu tenho aqui um fio solto. Certo? O fio tá solto, então não é nem nível lógico zero, nem um nem desconhecido. É alta impedância. Aqui sim, não tem nível lógico. Ok? Tranquilo, pessoal? João, mais especificamente. Beleza. Então, aqui a gente pode gerar números não somente com zeros e uns, mas também com X e Zs. Então, eu posso gerar, por exemplo, esse número aqui. 32'bZ. O que significa isso? São 32 fios, ou 32 bits, só que todos eles estão em alta impedância. Então, todos os fios estão desligados. Ou então, esse aqui. 8'h0X. O que significa? Que os quatro primeiros bits estão em zero e que os quatro bits menos significativos, desses 8 bits, eu não sei. É alta impedância. Ou então, eu posso fazer uma coisa mais bagunçada possível. Um número de quatro bits onde o mais significativo vale um, depois esse aqui tá em alta impedância, esse aqui vale zero e o menos significativo eu não conheço. Dá pra fazer bagunças desse tipo assim. Então, geralmente, o que a gente vai usar bastante é alta impedância. O nível desconhecido, geralmente, é nas simulações. Então, ele começa com o nível desconhecido e depois passa a ser conhecido. E se, por acaso, o tamanho não for especificado, quer dizer, esquecer do 4, esquecer do 8, esquecer do 32, o tamanho vai ser 32. Então, o default, se eu não escrever o tamanho de bits, deixar só o apóstrofe B, ele vai colocar 32'b. Ok. Tipos de dados. Na realidade, não são bem tipos, mas já que a gente tá trabalhando com uma linguagem, a gente pode pensar assim, como se fosse um tipo. Na realidade, é a forma como a gente interliga as coisas. Então, o primeiro tipo é um `wire`. Um `wire` é uma coisa simples, né? Tá aqui, um `wire`. É um fiozinho que liga, liga esse ponto àquele ponto. Relação? Não. Então, uma relação. É, talvez, relação. Tá, mais um fio. Tá? Então, nesse caso aqui, eu posso dizer, ó, esse fiozinho aqui tem o nome A. Então, fiozinho A. Certo? Eu posso ter um conjunto de fiozinhos. Tá? Então, nesse caso aqui, o B é composto de um conjunto de oito fios. Tá aqui. Então, o B é um barramento de oito fios. Três, quatro, cinco, seis, sete, oito. Esse aqui é o B. O menos significativo é o B0 e o mais significativo é o B7. De acordo com essa definição aqui. Sete, dois pontos zero. Então, sete é o mais significativo e o zero é o menos significativo. Desse jeito. Tá, e o que acontece se eu botar o contrário? Tá zero aqui e sete aqui. Vai significar que esse aqui vai ser o mais significativo e esse aqui vai ser o menos significativo. Certo? A ordem permanece a mesma. Só que agora esse aqui é o bit mais significativo e esse aqui é o menos significativo. Certo? Então, geralmente a gente trabalha na ordem direta. Sete, dois pontos zero. Então, um byte. Então, B é um conjunto de fios. Oito fios. Né? Que pode trafegar um byte. Outro tipo. Ah, qual é a característica básica de um `wire`? Se eu coloco aqui nível lógico um. O que que sai aqui na saída? Se eu coloco aqui na entrada nível lógico um. O que que sai aqui? Se eu coloco zero aqui na entrada. O que que sai aqui na saída? Zero. Né? E eu tenho aqui um tempo de propagação. Desse meu sinal muito pequeno. Tá? Que pode ser desprezível frente a outros atrasos de propagação. Certo? Então, essa é a característica de um fio. Se eu coloco aqui a entrada, quase que instantaneamente a saída fica igual à entrada. Então, se eu coloco um `um` aqui, quase que instantaneamente vai aparecer um `um` na saída aqui. Tranquilo, pessoal? Entendido essa característica de um fio? Fio elétrico normal, né? Vocês colocam no mais 5 volts e automaticamente ele tá todo energizado com 5 volts. Um outro tipo. O outro tipo é um `reg`. Tá? O que que é um `reg`? `reg` pode ser um `latch` ou um flip-flop. Quer dizer, um elemento que armazena um dado. Especificamente um bit. Tá? Então, por exemplo, `reg A`. Então, um `reg` vai ser, vou colocar aqui um flip-flop. Flip-flop tipo D. Tá? Então, aqui é D e Q. Tá? E aqui é o clock. Então, qual é a característica desse elemento aqui? Se eu coloco um aqui. Então, supor que esteja armazenado zero, tá? Ele começa a armazenar do zero, o flip-flop. Se eu coloco um na entrada, vai aparecer um aqui na saída? Instantaneamente, que nem um fio? Não, né? Quando que vai aparecer um aqui na saída? Quando eu tiver ou uma borda de subida, ou uma borda de descida, ou um nível. Aqui no controle do clock. Tá? Geralmente, pra nós, a gente vai trabalhar com borda de subida. Tá? Pra ser, os nossos circuitos simples vão ser de borda de subida. Quer dizer, esse 1 aqui só vai aparecer na saída quando vier uma borda de subida. Aí, o número 1 é armazenado. E ele... Aparece na saída. Aparece instantaneamente na saída? Aparece instantaneamente como um fio? Aparece? Não, né? Aqui eu tenho várias portas lógicas aqui dentro. Então, vem os atrasos de propagação nessas portas lógicas. Vocês aprenderam isso é de vários tempos aí. Esse tempo que a gente vai colocar aqui, vocês aprenderam setup time, hold time. Estão lembrados disso? Estão lembrados do que é setup time, hold time? Lá no subconsciente. Ah, que bom que tá lá, pelo menos. Certo? Então, essa temporização desse aqui, a gente... Deixa eu pensar. Acho que a gente vai ver isso mais adiante, tá? Que eu preciso aqui, na realidade, eu preciso do setup time. Tempo de setup. Que é esse. Desculpa. Tempo. Tempo de setup time. Tá? O tempo de clock para a saída, o t_CO. Tá? Então, esse aqui é o que mais nos interessa, o t_CO. Tá? O setup time é só pra ele funcionar corretamente. Quer dizer, eu tenho que colocar aqui no nível 1 um tempo antes de vir essa borda de subida do clock. Pra que ele funcione corretamente. Ok? Vamos ter que lidar com hazards também? Vamos ver. Ah... E o tempo que nos interessa é o tempo de, a partir do momento que o clock teve essa borda de subida, até o tempo que o 1 aparece aqui na saída. Então, esse vai ser o tempo de clock para a saída. E é o tempo que mais nos interessa aqui. Porque ele envolve todo o atraso de propagação de armazenamento e disponibilização desse bit que tá armazenado aqui na saída. Ok? A gente pode ter, isso aqui seria então, `reg A`. Pode ser um `latch` ou flip-flop. Tô botando aqui flip-flop. Qual é a diferença entre um `latch` e um flip-flop? Muito bom, olha! Até parece que fez um ISC, assim... Né? Bem de boa. Tá? Então, flip-flop é sensível a bordas. Tipo essa aqui, borda de subida. E `latches` são sensíveis a nível. Tá? Então, se tiver nível lógico 1, aí esse dado aqui tá constantemente sendo passado pra cá. E no momento que esse nível lógico passa pra zero, ele armazena o dado. Ele não muda mais o dado armazenado. Tá? Então, uma revisão rápida aí. `Latches` e flip-flops. Ok. Eu posso ter um conjunto de 8 flip-flops. Certo? Então, B nesse caso, é um `reg`, que é um registrador, que é capaz de armazenar 8 bits. Então, são 8 flip-flops desse, né? Colocados em sequência. Certo? Então, assim como eu tenho um registrador que é um `reg A`, se eu tiver o B, B vai ser 8 desses aqui, né? Copiados aqui embaixo. Tranquilo, pessoal? Então, notem a diferença entre um `reg` e um `wire`. A diferença é brutal entre isso aqui e isso aqui. Só que, às vezes, a gente se confunde e não sabe se determinada ligação, tem que ser feita através de um fio ou através de um `reg`. Isso é bastante comum de acontecer. Pô, eu estou ligando esse bloco a esse bloco. O que eu ponho aqui? Um fio ou um flip-flop? Então, para evitar esse tipo de confusão, que era bem comum, aí surge o SystemVerilog, tentando simplificar as coisas. Então, o SystemVerilog é como se fosse o Python. Ele é o Python para vocês. Então, se vocês não sabem se vocês vão definir um `reg` ou um `wire`, vocês podem usar o `logic`. Então, o `logic`, ele simplesmente define. O A é do tipo lógico. Quem é que vai definir se isso aqui é um `reg` ou um `wire`? É o sintetizador, o compilador. É que vai definir se o A é um `reg` ou um `wire`, a partir da utilização dele. Então, o usuário simplesmente define. `logic [7:0] b`. Ok, B vai ser alguma coisa, que vai ser ou `reg` ou `wire`. Eu, particularmente, não gosto dessa representação, porque a gente perde um pouco do controle. É assim como a gente perde um pouco do controle quando a gente usa Python. Acho que vai ficar marcado pela vida toda de vocês, que o professor odeia Python. Não, não é isso, tá? Entendido? Então, isso aqui veio facilitar. `logic`, né? `logic [7:0] b`. Existem outros tipos abstratos. Por exemplo, `integer`, tá? Que é um número de 32 bits. `real`, que é um número representado em IEEE 754. Então, esses dois aqui são os dois tipos abstratos mais conhecidos. Ok, então já sabemos os tipos. `wire`, `reg` e, quando eu não sei, `logic`. Características do Verilog. Primeiro, ele é case sensitive. Isso significa o quê? Que `reset` é diferente de `Reset` com R maiúsculo, que é diferente de `RESET` com tudo maiúsculo. Quer dizer, ele diferencia maiúsculas e minúsculas. Certo? Tem linguagem de programação que não diferencia isso. Considera tudo a mesma coisa, tá? No caso, o SystemVerilog, ele diferencia. Os nomes não podem começar por números. Então, por exemplo, `2Mux` não é um nome válido, mas `Mux2` é. Certo? Então, não pode começar por número. Espaços em branco são ignorados. Então, assim como C. A gente pode formatar a nossa descrição Verilog do jeito que a gente quiser. Posso escrever tudo em uma linha? Posso. Posso escrever pulando duas linhas? Posso. Posso fazer usando indentação? Pode. Ele é livre nisso aí. Coisa que o Python não é. Ok, comentários são iguais à linguagem C. Então, `//` é comentário de uma linha e `/* ... */` é comentário de múltiplas linhas. Ok? Então, vamos ver um exemplo de uma descrição Verilog. Então, uma estrutura básica, quando a gente cria algo em Verilog, a gente chama isso de `module`. Certo? Então, um módulo possui um nome, uma lista de entradas e uma lista de saídas. E aqui, a descrição do circuito, o que ele deve fazer. E no final, `endmodule`. Certo? Então, esse aqui é a nossa estrutura `module`. Então, todos os nossos circuitos vão ser módulos. Então, vamos ver um exemplinho aqui. Vamos supor que eu queira fazer um circuito aqui, que tem três entradas e uma saída. E eu quero que esse circuito seja... Vamos escrever essa equaçãozinha aí. Y vai ser igual... ~a & ~b & ~c OR a & ~b & ~c OR a & ~b & c. Eu quero que esse circuito aqui implemente essa equação lógica. Beleza? Então, como é que se pode fazer isso em Verilog? Então, uma das formas é a forma comportamental. Então, ao invés de eu especificar o circuito, eu vou especificar a própria equação lógica aqui. Aqui também já é uma boa descrição do circuito. Uma equação lógica passar para circuito é quase que direto. Então, nesse caso, eu vou criar um módulo. O nome do módulo é `exemplo`, que eu quero que esse circuitinho aqui seja chamado de `exemplo`. Uma lista de entradas. Quer dizer, eu tenho três entradas, a, b e c, que são do tipo `logic`. Então, `input logic a, b, c;`. E uma lista de saídas. Então, `output logic y;` nesse caso, eu só tenho uma saída, y. E como é que se relaciona a saída com as entradas? Como que, a partir das entradas, eu calculo a saída? Então, nesse caso aqui, eu estou escrevendo justamente a equação lógica. Então, `assign y = ~a & ~b & ~c | a & ~b & ~c | a & ~b & c;`. O `~a` significa a negação do a. `&` esse e comercial significa AND. E essa barra significa OR. Certo? Então, `~a & ~b & ~c OR a & ~b & ~c OR a & ~b & c`. Que é essa equaçãozinha lógica aqui. E `endmodule`. E eu preciso, então, colocar uma diretiva que é `assign`. `assign` diz o quê? Por que dessa diretiva `assign`? É como se eu estivesse definindo. Olha, coloca y sempre igual a isso aqui. A definição do y nunca vai mudar. Vai ser sempre isso. Certo? Por isso, `assign y = ...`. Certo? Essa é a nossa definição. Y nunca muda. Vai ser sempre calculado dessa maneira. Ok? Difícil, pessoal? Muito difícil, né? Ainda não. Ok. Ótimo. Operações básicas do Verilog em precedência. Então, aqui estão em ordem de precedência. Então, a primeira coisa que vai ser avaliada vão ser os parênteses. Quer dizer, se eu colocar aqui parênteses. Por exemplo, aqui. Ele vai avaliar primeiro essa parte para depois avaliar as outras. Depois vem a concatenação. Que a gente usa chaves. Que a gente já usou bastante isso para fazer a concatenação. Extensão de sinal. Como a gente viu. Algumas linguagens de máquina. O NOT é a operação de maior prioridade. Depois vem multiplicação, divisão e resto. Ou MOD. São as operações mais altas. Depois, adição e subtração. Depois, deslocamentos lógicos. À esquerda e à direita. Então, isso aqui é deslocamentos lógicos. Depois, deslocamentos aritméticos. À esquerda e à direita. A gente já sabe a diferença entre deslocamento lógico e aritmético. Certo? Sim, ótimo. Depois, as comparações. Menor, menor ou igual. Maior, maior ou igual. Depois, o comparador de igualdade e de diferença. Se é igual ou se é diferente. E depois, as operações lógicas. AND, NAND. XOR, XNOR. OR e NOR. Certo? Nessa ordem aqui. Então, AND tem maior prioridade. Depois, vem o XOR. Depois, vem o OR. E por último. Eu não sei. Tu disse que sabia. Olha então. Por último, esse operador ternário. O que que é esse operador ternário? Tem operador ternário em Python? Me digam vocês. Tem esse operador ternário em Python? Tem? Todo mundo já usou. Ótimo. Então, não preciso me preocupar com isso aqui. Tá? Então, depois vem o operador ternário. Uma condição. Se a condição for verdadeira, faz o que tiver aqui. Se a condição for falsa, faz o que tiver aqui. Ok? Então, essas aqui são as operações básicas. SÍNTESE. Tá? Então, a síntese, inclusive, corresponde à tradução ou à compilação. Que é como o Quartus chama de compilação. Eu prefiro usar a síntese mesmo. De uma descrição Verilog em uma netlist. Isso aqui é que é a síntese. Da descrição Verilog, em nosso caso, é esse aqui. E uma netlist. Uma netlist é uma representação interna do sintetizador. Cada sintetizador pode criar a sua própria netlist. Indicando como são as conexões dos circuitos. Certo? E isso aqui vai ser feito pela nossa ferramenta Quartus. Que a gente vai abrir hoje. Então, geralmente durante a compilação, diversas otimizações são realizadas. Então, esse aqui é um exemplo. Esse aqui é o nosso circuitinho. Esse aqui. Só que quando a gente manda sintetizar esse circuito, o Quartus me dá esse circuito aqui. O que vocês acham? Que a partir dessa equação lógica, gerar esse circuito. O que aconteceu? O quê que aconteceu? Se eu fosse, a partir da equação lógica, gerar o circuito direto. Eu ia precisar de uma OR de três entradas. Certo? Onde a primeira entrada vai ser isso aqui. Que é uma AND de três entradas. Onde todas elas são negadas. Depois, outra AND de três entradas. Onde as duas últimas são negadas. As duas últimas são negadas. E por último, outra AND de três entradas. Onde eu tenho só do meio negado. A, B, C. Seria esse circuito aí. Se eu fosse sintetizar a partir da equação lógica. Isso aqui todo mundo sabe fazer, né? A partir da equação lógica, desenhar o circuito, acho que é tranquilo. Só que, geralmente, o quê que vocês fazem? A partir da equação lógica, vocês geram a tabela verdade. Depois, aplica o mapa de Karnaugh. Pra simplificar o circuito. Certo? Estão lembrados disso? Ok. Aqui, o Quartus já fez tudo isso. E já tá te dando o circuito simplificado. Tá? Então, aqui são A, B, C. Duas portas ANDs. E duas entradas. E uma OR de duas entradas. Faz a mesma coisa que isso aqui. Tá? Pela simplificação. Ou o outro termo que nós usamos, né? Mapas de Karnaugh. Ok. Certo? Então, uma coisa que é interessante. A gente tem que sempre manter em mente. Que ao sintetizar essa descrição de Verilog. O circuito que eu vou obter, geralmente, não vai ser esse circuito aqui. O Quartus vai tentar otimizar ele ao máximo. Certo? Então, às vezes, a gente quer fazer esse circuito. E o Quartus gera isso aqui. Mas não era isso aqui que eu queria. Eu queria isso aqui. Tá? Então, às vezes, tem esses inconvenientes. Ok. Como é que se define um circuito combinacional? Um circuito que é só portas lógicas. Tipo isso aqui. Então, uma das formas que a gente tem é usando o `assign`. Isso aqui. Que a gente acabou de fazer. Essa é uma forma. Outra forma é utilizando a diretiva `always`. Tá? Então, `always` é uma ferramenta muito poderosa. Que permite que, dentro do `always`, a gente tenha estruturas complexas. Do tipo `if`, `then`, `else`, `while`, `for`, loops `for`. Tudo dentro de `always`. Então, ela permite. Fora do `always`, não permite usar isso. Mas, dentro do `always`, permite. E o `always`, ele tem `always @`. `@` significa quando que ele vai avaliar isso aqui. Nesse caso, é asterisco. Que significa, então, avalie sempre. Tá? Eu não tenho aqui uma condição. Eu poderia colocar aqui uma condição. `always @(a)` A igual a 1. Daí faz isso. Por exemplo. Então, cada vez que o A for 1, é que ele vai avaliar. Se o A não for 1, ele não vai avaliar. Certo? Então, o `always @(*)` ele vai avaliar isso aqui sempre. Logo, é igual essa de cima. Que isso aqui está sendo avaliado sempre também. Mudou um dos valores aqui, o y é alterado. Aqui também. Mudou um desses valores, o y vai ser alterado. Ok? Eu vou fazer o seguinte. Eu vou tirar essa parte de blocking e non-blocking. Porque isso aqui só gera confusão. E a gente geralmente não usa essa aqui. Então, eu não vou explicar o que significa atribuição non-blocking e atribuição blocking. A gente vai sempre usar essa atribuição aqui. Que é non-blocking. Então, esse aqui deixa para lá. Como é que eu defino um circuito sequencial? Bom, um circuito sequencial é aquele regido por um clock. Onde as coisas acontecem, geralmente, na borda de subida ou na borda de descida do clock. Então, eu poderia fazer esse nosso circuito, que antes era puramente combinacional, ser sensível à borda de clock. Então, `always @(posedge clock)`. Quer dizer, uma borda positiva desse sinal clock. Ele vai avaliar isso aqui. Enquanto não vier uma borda positiva, ele não vai avaliar. Quer dizer, ele vai manter o valor que estava antes. Certo? Então, é como se fosse um registrador. Então, um Y, nesse caso, geralmente é do tipo `reg`. Quer dizer, enquanto não vier a borda de subida ou de clock, ele não vai alterar o valor dele. Vai manter o valor que tinha antes. Quando vier a borda de subida ou de clock, é que ele vai avaliar o A, o B ou o C. E atribuir um novo valor a isso. Certo? Então, na borda do sinal de clock, é que ele é atualizado. Entendido, pessoal, isso aqui? Então, se eu botar A... Oi, fala. O `posedge` é para ser avaliado na borda, né? Na borda de subida. Eu posso ter o `negedge`. `negedge` é avaliado na borda de descida. Tá? `posedge`, `negedge`. Daí, o blocking aqui a gente tira fora, porque não vale a pena agora. Bom, o que que é um FPGA? Que é, a gente está fazendo tudo isso para poder programar e sintetizar os circuitos em FPGA. Então, no caso, o nosso kit lógico, para fazer uma receita dele, a gente tem esse FPGA desse tipo aqui. Então, o Cyclone V. Esse aqui é o desenho dele. Tirado uma foto dele assim, e modificado um pouquinho. Então, o que que ele é, o circuito? É um chip capaz de implementar qualquer sistema digital. Ele implementa qualquer coisa. Através da definição da interconexão de seus elementos. Então, o que que significa um elemento? Então, nesse caso do Cyclone V, ele possui 32.070 elementos lógicos. Que, nesse chip, é chamado de Adaptative Logic Module, ou ALMs. Isso aqui nada mais é do que um elemento lógico. Ok? Outras FPGAs chamam de elemento lógico. No caso desse aqui, ele chama desse ALMs, porque acho que ele gosta de coisas sobrenaturais, assim. E a gente pergunta, quantas ALMs tem o circuito de vocês? E vocês vão ter que dizer quantas ALMs foi necessário. Tá? Então, seria esses pontinhos em azul aqui. Tá? Nessa representação. Então, são 32.000. Cada ALM, cada ALM, pode fazer... Um ALM é isso aqui. O diagrama de blocos de uma ALM. Então, o que que ele pode fazer? Ele pode ter 8 entradas aqui. Então, ele pode fazer qualquer função lógica de 8 entradas. Então, ele é capaz de sintetizar. Certo? Qual for a função lógica de 8 entradas, ele sintetiza com uma ALM só. Ele possui 4 registradores de 1 bit. Então, se eu quero armazenar um número de 4 bits. Com uma ALM, eu consigo armazenar um número de 4 bits. Eles possuem somadores encadeáveis. Quer dizer, eu tenho aqui dentro um full adder. No caso aqui, dois full adders. Tá? Que eu posso concatenar eles. Então, tem um `carry in` entrando aqui e vai gerar um `carry out` saindo. Então, eu posso fazer as operações de adição e subtração, né? Utilizando as ALMs. E permite o roteamento. Quer dizer, eu posso pegar um sinal que está vindo aqui e rotear ele para outro lugar. Tá? Quer dizer, simplesmente passar por ele. Sem precisar fazer nenhuma dessas operações. O que mais que tem nesse chip? Ele possui memória RAM dentro do chip. Tá? Que são 4.065.280 bits. Ok. Quantos bytes dá isso aqui, pessoal? Alguém me calcula aí. 4.065.280? É quantos bytes? Zero. Não, escreve aí. Escreve ali no chat. Nada de ficar falando. Quero ver o número ali. Viu o quanto? Não, não, não. Eduardo, sempre em notação científica, não pode começar com zero vírgula. Certo? Foi isso que eu estava brigando com o Alisson. Ok. Então, 508.160 bytes. É o que dá para armazenar aí. Então, são essas linhas amarelas aqui. Tá? 508.160 bytes. Essas linhas amarelas são as memórias. Possui 87 DSPs. DSP significa Digital Signal Processing. Que, na realidade, nada mais é do que um multiplicador. Tá? Então, ele pode fazer um multiplicador de 18 bits por 18 bits. E uma adição de 64 bits. Certo? Então, ele pode multiplicar e adicionar. Ok? Então, 87 DSPs significa esse conjuntinho aqui. Um multiplicador de 18 por 18 e mais um somador de 64. Bom, possui 6 PLLs. PLL serve para a gente gerar novas frequências. Por exemplo, o teu clock é de 50 MHz. Mas, tu precisa de um clock de 100. Tu precisa de um sinal de 150 MHz. Como é que eu vou passar um sinal de 50 MHz para um sinal de 150 MHz? O que a gente sabe fazer é pegar um sinal de 50 MHz e trocar para 25. Vocês sabem fazer isso? Como que se pega um sinal de 50 MHz e gera um sinal de clock de 25? Isso com flip-flop. Tá? Um flip-flop simplesmente divisor por 2. Então, divisões por 2 eu consigo fazer fácil. Tá? E se eu quisesse, ao invés de 50 MHz, quisesse 45 MHz? Como é que vocês iam fazer isso? Eu tenho um sinal de 50 e ele quer um sinal de 45 MHz. No circuito digital, não dá para fazer. Então, a gente tem esses PLLs. Esses PLLs são sintetizadores de frequência. A gente entra com uma frequência de 50 MHz e escolhe qual é a frequência que ele quer que ele sintetize. Então, isso aqui é interessante quando a gente tem diversas frequências diferentes dentro do chip. A gente precisa disso. Tem 280 pinos de I/O por usuário e dentro dele aqui tem um ARM Cortex-A9 dual-core, que é esse aqui. Certo? Então, ele já tem dois processadores aí dentro. Mas a gente não usa. Ok. Isso aqui é um FPGA. O FPGA é esse chip aqui que fica nessa plaquinha de desenvolvimento que, se vocês tivessem chance, vocês iriam usar essa plaquinha. Então, eu vou pegar isso aqui. Ok? Então, nessa plaquinha tem displays, tem chaves, tem botões. Tem entrada e saída de áudio, entrada de vídeo, saída para monitor, cabo Ethernet, USB. USB está aqui. Desculpa. USB, UART, interface serial. Tem conversores analógico-digitais. RAM está aqui. Tem memória também. 64 MB de SDRAM. Então, é RAM dinâmica. Ok? E tem uma outra memória aqui. 1 GB DDR3. Aqui, que é para uso com os ARMs. Então, a memória que a gente tem disponível aqui são quanto? 508.160 bytes. Ah, mas e se não houver tudo em 508.160 bytes? Aí, ele tem uma memória externa aqui para poder ser utilizado. Ok? Mas como a gente não vai usar esse aqui, esse aqui é só para deixar vocês com água na boca. Para poder usar isso. Era isso que a gente ia queimar se fosse presencial? Se fosse presencial e vocês queimassem isso aqui, tá? Esse negócio aqui custa em torno de 250 dólares. Tá? Não, é para marcar mais o nosso coração. Hã? Ah, para marcar mais. LED a gente pode queimar, porque são 2 centavos um LED. Mas esse aqui não. Não. Não, vocês iam tocar, iam ver as coisas acendendo. Tem LEDzinhos aqui. É bem divertido. Ah, beleza. Ah, revisando temporização, tá? De circuitos digitais. Ah, se aqui eu tenho um elemento de estado 1. Entenda-se flip-flop. E aqui um elemento de estado 2. Entenda-se flip-flop. E aqui um circuito combinacional. Então, o que que eu vou querer fazer? Eu quero que, ao vir a borda de subida, esse elemento de estado seja atualizado para um novo valor, nesse caso. Tá? Aqui vai aparecer esse valor aqui na saída, depois de um certo tempinho. Depois de um certo tempinho, esse valor vai ser processado por essa lógica combinacional e vai gerar um valor aqui. E esse valor aqui, para poder ser armazenado nesse elemento de estado 2, eu tenho que cumprir o setup time dele. Certo? Então, qual é a máxima frequência que eu poderia utilizar nisso? Sabendo que essa frequência de clock é igual a essa. São os mesmos sinais de clock. Então, para a gente poder definir essa máxima frequência de clock, a gente tem que saber quanto tempo isso aqui demora. Quanto tempo isso aqui demora e quanto tempo isso aqui demora. Tá? Vamos lá. Então, qual o tempo que eu devo respeitar? O setup time desse aqui tem que ser respeitado de qualquer jeito. Eu só posso botar aqui o dado. O dado tem que estar pronto antes da subida do clock. Então, nesse caso aqui, o dado aqui está pronto. Seria esse dado aqui. Eu ficaria botando aqui. Está pronto antes da subida do clock. Tá? Então, beleza. Então, aqui tem o setup time desse bichinho aqui. Tá? Mas esse setup time não interfere. Por quê? Porque aqui o clock vai vir. Então, vindo o sinal de clock, esse dado que está aqui na entrada vai ser armazenado no elemento de estado e vai aparecer aqui na saída. Esse tempo de vir o sinal de clock até o novo dado ficar pronto, certo? Então, o dado vai armazenar, vai passar em tempos de transições e depois o dado aqui vai ficar estável aqui na saída. É o tempo de clock para a saída. É o t_CO. Certo? Então, o primeiro tempo que a gente tem que respeitar é o tempo desse tempo de clock até a saída. Quer dizer, eu não posso usar uma frequência de clock que tenha um período menor do que esse t_CO. Senão, vai dar errado. O outro tempo que nos interessa é o t_PD desse aqui. Que é o tempo de delay e propagation. Tempo de atraso de propagação dessa lógica combinacional. E daí isso aqui depende de tudo. Depende das portas lógicas que tiverem aqui dentro. Então, eu tenho que respeitar esse t_PD. E o dado, depois de processado, tem que estar disponibilizado aqui no segundo elemento com o tempo antes. Que é o setup time desse bichinho aqui. Quer dizer, eu preciso garantir que aqui tenha ainda um certo setup time. Para então eu poder vir com a borda de clock aqui. Então, para nós, na prática, o que a gente precisa? A gente... Para que as coisas funcionem, eu preciso que o sinal, essa frequência aqui, respeite esses tempos. Quer dizer, o tempo de atraso da saída do t_CO desse elemento de estado 1. Então, o t_CO desse aqui. Mais o tempo de propagação dessa lógica combinacional. O t_PD. Que é o máximo do t_PHL e t_PLH. Que vocês viram lá em Circuitos Lógicos. E mais ainda o setup time desse outro flip-flop. É o setup time dele. Então, a soma desses três tempos aqui é que vai me dizer qual é o mínimo período que eu tenho que respeitar. Período da onda do sinal de clock. Então, esses tempos é que vão me definir qual é a máxima frequência de clock que eu posso utilizar aqui. Está ok, pessoal? Entenderam isso? Então, eu tenho que respeitar esses três tempos aqui. t_CO desse aqui. E t_PD desse aqui. E o setup time desse aqui. Entendido, pessoal? Ótimo. Então, é isso. Esse aqui eu vou voltar a falar em aula depois. Quando a gente começar com o MC, eu vou começar com isso aqui. Isso aqui é só para vocês lembrarem que o sinal de clock bonzinho é esse aqui. Mas, na realidade, o sinal de clock é isso aqui. Na prática. Essa nossa representação quadradinha, boazinha, não existe na prática. É isso aqui. Então, a gente tem indeterminações aqui. O sinal deveria ir instantaneamente de 0 para 1 e demora um certo tempo para ele ir de 0 para 1. Esse tempo aqui está de indeterminação. Ok? Então, só para tirar os óculos cor-de-rosa que vocês colocam. Quando vocês veem o sinal de clock bonitinho. E depois vem aqui um monte de slides que eu tirei desse site da Intel que explica bem essas temporizações. Então, eu não vou mostrar aqui porque a gente não vai ter tempo. Mas, vocês deem uma lida, acessem esse site aqui para vocês entenderem um pouco mais sobre essa questão de elemento de estado 1, lógica combinacional, elemento de estado 2. Ok? Então, vamos botar a mão na massa. Então, vamos lá. Então, abram o roteiro do laboratório 2 e vamos ver o que quer que a gente tem que fazer nesse laboratório 2.",
        "video_source": "OAC_2022-03-09.mp4"
    },
    {
        "id": 6,
        "timestamp_start": 3693.91,
        "timestamp_end": 3911.62,
        "slide_description": "Como Engenheiro de Computação Sênior, analiso o slide e o conteúdo anotado apresentados. A imagem exibe uma aula online de Arquitetura de Computadores (identificada como \"Sala de Aula de OAC\" no cabeçalho da conferência e no título do documento \"OAC_LAB2.docx\"), com um instrutor (Marcus Vinicius Lam...) visível na parte inferior direita.\n\n**Conteúdo Textual e Estrutural do Documento Principal (Lab Handout):**\n\nO documento exibido é um guia de laboratório, provavelmente do Microsoft Word (\"OAC_LAB2.docx\"), focado em projetos de hardware utilizando FPGAs. Ele está estruturado da seguinte forma:\n\n*   **Objetivos Iniciais (Lista com marcadores):**\n    *   \"Introduzir ao aluno a Linguagem de Descrição de Hardware Verilog;\"\n    *   \"Familiarizar o aluno com a plataforma de desenvolvimento FPGA DE1-SoC e o software QUARTUS Prime da Intel;\"\n    *   \"Desenvolver a capacidade de análise, síntese e caracterização de sistemas digitais usando HDL.\"\n\n*   **Seção 1: \"(0.0) Implementação de um driver para display de 7 segmentos Assíncrono\"**\n    Esta seção detalha os passos para implementar um driver assíncrono para display de 7 segmentos. As instruções incluem:\n    *   **Download e Preparação:** Solicita o download do arquivo `lab2.zip` do Moodle, descompactação em um diretório do desktop sem espaços ou caracteres especiais, e menciona o arquivo `Tutorial_Quartus_Primev22.pdf` para instruções de projeto e síntese na DE1-SoC.\n    *   **Configuração do Projeto no Quartus Prime:** Abrir o \"Quartus Prime Lite\", usar \"Project/Restore Archived Project\" e selecionar o arquivo `Decoder7.qar`.\n    *   **Compilação e Análise (para `decoder7.v`):**\n        *   Definir `decoder7.v` como o **toplevel**.\n        *   Verificar que todos os pinos (exceto o `Clock`) estão configurados como pinos virtuais via \"**Assignments/Assignment Editor**\".\n        *   **Compilar.**\n        *   **Análise Pós-compilação (requerimentos físicos):** Indicar: i) número de elementos lógicos (**ALMs**), ii) número de registradores, iii) quantidade de bits de memória e iv) número de blocos DSP usados.\n        *   **Visualização da Netlist:** Ver o diagrama esquemático do circuito gerado usando \"Tools/Netlist Viewers/RTL viewer\".\n        *   **Simulação Funcional e Temporal:**\n            *   Utilizar o arquivo de forma de onda `decoder7.vwf` (da **University Program**).\n            *   Realizar simulação funcional e temporal, verificando que os \"Simulation settings\" estão com parâmetros default e sem \"-novopt\".\n            *   Capturar \"print screen\" das telas para comparação.\n            *   Usar \"Tool/Run Simulation Tool/RTL Simulation\" para simular o `decoder7_tb`.\n        *   **Análise de Temporização (Timing Analysis):**\n            *   Usar o \"TimeQuest (Tools/Timing Analyzer)\".\n            *   Gerar a \"Timing Netlist\" e o relatório \"Report Datasheet\".\n            *   Indicar os requerimentos temporais: i) o caminho de maior atraso e ii) o maior tempo de atraso **tpd**.\n        *   **Síntese e Verificação no Hardware:**\n            *   Definir o arquivo `topDE.v` como o **toplevel**.\n            *   Compilar.\n            *   Sintetizar na DE1-SoC usando \"Tools/Programmer\".\n            *   Filmar o funcionamento para todos os valores de entrada.\n\n*   **Seção 2: \"(10.0) Unidade Lógico Aritmética de Inteiros:\"**\n    *   Esta seção é uma continuação ou novo tópico, indicando uma tarefa subsequente. Apenas a primeira instrução é visível:\n    *   \"Abra o Quartus Prime e Project/Restore Archived Project e escolha o arquivo ULA.qar\" (onde ULA significa Unidade Lógico Aritmética).\n\n**Diagramas:**\nNão há diagramas explícitos visíveis na imagem. No entanto, o texto instrui a visualização de um \"diagrama esquemático do circuito gerado pelo Tools/Netlist Viewers/RTL viewer\" e a utilização de um \"arquivo em forma de onda decoder7.vwf\" para simulação, indicando que a compreensão de diagramas RTL e formas de onda é parte integrante do laboratório.\n\n**Contexto da Interface de Conferência:**\nNo lado esquerdo, a interface de uma plataforma de conferência web é visível, com opções como \"MENSAGENS\", \"Perguntas\", \"Bate-papo público\" (ativo), \"NOTAS\" e \"USUÁRIOS (19)\". As mensagens do chat refletem a interação dos alunos, com perguntas e comentários técnicos e administrativos, como dúvidas sobre tamanhos de arquivo (\"0,4846191406 Mebi Byte\", \"508.160 bytes\"), menções a \"flipflop\", e discussões sobre valores (\"3500 reais\"). O tempo decorrido da aula é de 63 minutos e 30 segundos.\n\nEm resumo, o conteúdo central é um guia prático para um laboratório de Arquitetura de Computadores focado em Design Digital e FPGAs, utilizando a linguagem Verilog e o ambiente Intel Quartus Prime para implementar e analisar circuitos digitais, com o exemplo principal sendo um driver para display de 7 segmentos e a introdução a uma Unidade Lógico Aritmética (ULA). A aula enfatiza o ciclo completo de desenvolvimento de hardware: especificação, codificação (Verilog), síntese, simulação e implementação física em FPGA.",
        "transcription": "Então, esse laboratório 2 eu acho que ele é mais tranquilo de fazer. Só que não. Vamos dar uma lida aqui. Então, esse laboratório 2 é para entregar no dia 23. Esse é o relatório. Então, ele está... O objetivo é introduzir ao aluno a Linguagem de Descrição de Hardware Verilog. Familiarizar o aluno com a plataforma de desenvolvimento FPGA e com software Quartus. E desenvolver a capacidade de análise, síntese e caracterização de sistemas digitais em HDL. Mas, por que a gente tem que ver isso? Ora, se a gente vai construir um processador, a gente tem que saber analisar esses sistemas digitais. Para, então, a gente ver como que isso impacta em um processador. Então, vamos lá. É dividido em duas partes. Essa primeira parte é o que a gente vai fazer junto aqui. E a segunda parte é o que vocês vão fazer em casa. Mas eu vou explicar direitinho, passo a passo, o que é que vocês têm que fazer. Então, façam download do arquivo lab2.zip. Descompactem em um diretório que não contém espaço no nome. Eu não sei se a Intel já corrigiu isso. Mas ele dava bug se, por acaso, no path de onde estão os arquivos que vocês vão trabalhar, tiver espaço no nome. Então, criem um diretório que não tem espaço no nome. No path todo. Nem em caracteres especiais. Ok. A gente vai utilizar aqui o Quartus Prime versão 18. Ele já está na versão 21. Certo? Se vocês quiserem tentar fazer com a versão 21, tudo bem. Mas eu sei que, para mim, eu sei que a versão 18 funciona. Eu baixei a versão 21. Eu baixei a versão 21 hoje. Então, eu nem mexi muito com ela. Mas a versão 18 do Quartus está ok. Esse arquivo, o Tutorial Quartus Prime v22, aqui, não é o Quartus 22. É a 22ª versão desse arquivo. Então, aqui tem as instruções, passo a passo, de como é que se cria um projeto. Como é que se faz simulação. Como é que se carrega na plaquinha. Quer dizer, é... Tutorial de tudo que vocês precisarem saber fazer está aqui. Então, se por acaso vocês perderem algum passo, eu vou te dizer: Olha lá no tutorial que tem isso. Ok? Então, primeira coisa. Abra o Quartus Prime Lite. E vamos recuperar os projetos que já estão disponíveis nesse laboratório. Esses dois projetos aqui: o ULA, que é a ULA, e o D7. E o D7. Então, a gente tem esses dois projetinhos no arquivo ZIP que foi enviado para vocês. Ok. Vamos abrir o Quartus. Então, vocês têm que instalar o Quartus, obviamente. Mas, como aqui agora, eu só vou fazer demonstração, vocês podem instalar o Quartus depois. Não tem problema. Eu vou usar a versão 18. Essa aqui. Então, quando vocês instalam o Quartus, a gente tem esse programinha aqui. Tem vários programinhas. E esse aqui é o nosso Quartus, a versão 18.1. Ok. Eu tenho duas janelas, pessoal. Então. No caso, ele abriu na outra janela. Então, está aqui.",
        "video_source": "OAC_2022-03-09.mp4"
    },
    {
        "id": 7,
        "timestamp_start": 3911.62,
        "timestamp_end": 3999.12,
        "slide_description": "Atuando como um Engenheiro de Computação Sênior, a análise do slide revela uma sessão de aula online de Arquitetura de Computadores (\"Sala de Aula de OAC\"), com foco prático em projeto de hardware utilizando a ferramenta de Electronic Design Automation (EDA) **Intel Quartus Prime Lite Edition**.\n\n**1. Transcrição de Texto e Títulos:**\n\n*   **Título da Aba do Navegador:** \"ConferênciaWeb - Sala de Aula de OAC\"\n*   **URL:** \"live-idc53.mconf.rnp.br/html5client/join?sessionToken=ruhphnjkmbdmhnp4\"\n*   **Barra Superior da Conferência:** \"Sala de Aula de OAC\" | \"66:01\" (timer)\n*   **Painel Esquerdo (ConferênciaWeb):**\n    *   **Abas:** \"MENSAGENS\", \"NOTAS\", \"USUÁRIOS (20)\"\n    *   **Sub-abas de MENSAGENS:** \"Perguntas\", \"Bate-papo público\"\n    *   **Chat (trechos visíveis):**\n        *   \"ou ou o outro la que nunca utilizamps\"\n        *   \"Eduardo Ferreira Ma... 14:44\" -> \"utilizamos*\" -> \"isso\"\n        *   \"Eduardo Ferreira Ma... 14:51\" -> \"0,484619146 mebi Byte\"\n        *   \"Victor Hugo Rodrig... 14:51\" -> \"508.160 bytes\"\n        *   \"Ualiton Ventura Da... 14:51\" -> \"508160 bytes\"\n        *   \"Ualiton Ventura Da... 14:53\" -> \"com flipflop?\"\n        *   \"Ualiton Ventura Da... 14:55\" -> \"ta maluco\"\n        *   \"Victor Hugo Franca... 14:55\" -> \"ou seja 3500 reais\"\n        *   \"Ualiton Ventura Da... 14:55\" -> \"tudo isso?\"\n        *   \"Maycon Vinnycus S... 14:55\" -> \"n ia nem tocar nisso kkkk\"\n        *   \"Eduardo Ferreira Ma... 15:00\" -> \"ok\"\n        *   \"Victor Hugo Rodrig... 15:00\" -> \"Ok.\"\n        *   \"João Alberto Trava... 15:00\" -> \"sim\"\n        *   \"Enviar mensagem para B...\" (campo de entrada)\n    *   **Usuários (lista parcial):** Marcus Vinicius Lam... (Você), Ana Luisa Pa..., Andre Carval..., Arthur Brasa..., Bruno Vargas..., Eduardo Ferr..., Felipe Dantas..., Gabriel Kenji..., Gustavo Lope..., Gustavo Pierr..., Gustavo Rodr...\n*   **Janela Principal (Intel Quartus Prime Lite Edition):**\n    *   **Título da Janela:** \"Quartus Prime Lite Edition\"\n    *   **Barra de Menus:** \"File Edit View Project Assignments Processing Tools Window Help\"\n    *   **Painel Esquerdo (Project Navigator):**\n        *   **Abas:** \"Project Navigator\", \"Hierarchy\"\n        *   **Conteúdo:** \"Compilation Hierarchy\" (colapsado)\n    *   **Painel Central (Home - Projetos Recentes):**\n        *   **Título:** \"Recent Projects\"\n        *   **Projetos Listados:**\n            *   \"ALU.qpf (C:/Users/mvlam/Dropbox/kiko/Disciplinas/UnB/OAC/2021-2/Lab2/ALU_restored/ALU.qpf)\"\n            *   \"TopDE.qpf (C:/Users/mvlam/Dropbox/kiko/Disciplinas/UnB/OAC/2021-2/Lab2/DECODER7_restored/TopDE.qpf)\"\n            *   \"TopDE.qpf (C:/Users/mvlam/Dropbox/kiko/Disciplinas/UnB/OAC/2021-2/Lab2/DECODER7_restored/TopDE.qpf)\"\n        *   **Botões:** \"New Project Wizard\", \"Open Project\", \"Restore Archived Project\", \"Compare Editions\", \"Buy Software\", \"What's New\", \"Notifications\"\n        *   **Diálogo \"Restore Archived Project\" (parcialmente visível):**\n            *   \"Archive name:\" (campo)\n            *   \"Destination folder:\" (campo)\n            *   Checkbox: \"Overwrite any existing files in the destination folder\"\n            *   Botões: \"OK\", \"Cancel\", \"Help\"\n            *   Checkbox: \"Close page after project load\"\n            *   Checkbox: \"Don't show this screen again\"\n    *   **Painel Inferior (Tasks):**\n        *   **Abas:** \"Tasks\", \"Compilation\"\n        *   **Conteúdo (Tasks):** \"Compile Design\" (tarefa principal expandida)\n            *   \"Analysis & Synthesis\"\n            *   \"Fitter (Place & Route)\"\n            *   \"Assembler (Generate program...)\"\n            *   \"Timing Analysis\"\n            *   \"EDA Netlist Writer\"\n            *   \"Edit Settings\"\n    *   **Painel Direito (IP Catalog):**\n        *   **Título:** \"IP Catalog\"\n        *   **Barra de Busca:** \"Search altera.com\"\n        *   **Informações de Cabeçalho:**\n            *   \"Universidade de Brasília\"\n            *   \"Departamento de Ciência da Computação\"\n            *   \"Device Family: Cyclone V (E/GX/GT/SX/SE/ST)\"\n        *   **Categorias de IP:**\n            *   \"Installed IP\"\n            *   \"Project Directory\" -> \"No Selection Available\"\n            *   \"Library\" (expandida)\n                *   \"Basic Functions\"\n                *   \"DSP\"\n                *   \"Interface Protocols\"\n                *   \"Memory Interfaces and Controllers\"\n                *   \"Processors and Peripherals\"\n                *   \"University Program\"\n                *   \"Search for Partner IP\"\n    *   **Painel Inferior Direito (Messages):**\n        *   **Abas:** \"Messages\", \"System\", \"Processing\"\n        *   **Conteúdo (Messages - cabeçalhos):** \"Type\", \"ID\", \"Message\"\n        *   **Barra de Busca/Filtro:** \"<<Filter>>\", \"Find...\", \"Find Next\"\n\n**2. Descrição de Diagramas e Fluxo de Dados:**\n\nNão há diagramas explícitos de Datapath, Pipeline ou Hierarquia de Memória visíveis no slide. No entanto, o conteúdo da interface do Quartus Prime e do chat fornece insights sobre os tópicos da aula e o fluxo de trabalho de projeto de hardware:\n\n*   **Fluxo de Design FPGA (implícito pelo painel \"Tasks\"):** O painel \"Tasks\" detalha as etapas sequenciais de um fluxo de design para Field-Programmable Gate Arrays (FPGAs), crucial para a implementação de arquiteturas digitais. Este fluxo consiste em:\n    1.  **Analysis & Synthesis:** Traduz o código HDL (Hardware Description Language, como Verilog ou VHDL, implícito pelo uso do Quartus) em uma netlist genérica de portas lógicas e flip-flops.\n    2.  **Fitter (Place & Route):** Mapeia a netlist lógica para os recursos físicos da FPGA (células lógicas, blocos de memória, roteadores) e estabelece as interconexões. Esta etapa define o layout físico do design.\n    3.  **Assembler (Generate program...):** Gera o arquivo de programação da FPGA (bitstream) que será carregado no dispositivo.\n    4.  **Timing Analysis:** Verifica se o projeto atende aos requisitos de tempo, crucial para garantir a funcionalidade correta e o desempenho da arquitetura digital.\n    5.  **EDA Netlist Writer:** Gera netlists em formatos padrão da indústria para simulação ou verificação externa.\n*   **Componentes de Arquitetura (implícito pelo \"IP Catalog\" e Projetos Recentes):**\n    *   O \"IP Catalog\" exibe uma lista de blocos de IP (Intellectual Property) que são componentes reutilizáveis para construção de sistemas. As categorias como \"Basic Functions\", \"DSP\", \"Interface Protocols\", \"Memory Interfaces and Controllers\" e \"Processors and Peripherals\" indicam que a aula aborda a construção de sistemas computacionais a partir de blocos fundamentais, incluindo unidades de processamento (Processors), subsistemas de memória (Memory Interfaces and Controllers) e interfaces de comunicação.\n    *   Os projetos recentes, \"ALU.qpf\" (Arithmetic Logic Unit - Unidade Lógica Aritmética) e \"TopDE.qpf\" (provavelmente um projeto top-level para uma placa DE-series, comum em laboratórios de FPGA), sugerem que os alunos estão trabalhando na implementação de componentes centrais de uma CPU (como a ALU) e na integração desses componentes em um sistema maior em uma FPGA da família \"Cyclone V\".\n*   **Discussões em Tempo Real (Chat):** A menção de \"flipflop\" no chat indica uma discussão sobre elementos de armazenamento de estado fundamentais em circuitos sequenciais e na arquitetura de computadores. As discussões sobre \"mebi Byte\" e \"bytes\" podem estar relacionadas a conceitos de memória ou tamanho de dados.\n\nEm resumo, o slide, embora não contenha diagramas diretos, mostra um ambiente de laboratório virtual onde os alunos estão engajados na implementação prática de conceitos de Arquitetura de Computadores usando FPGAs e a suíte de ferramentas Quartus Prime, cobrindo desde o design de unidades funcionais (ALU) até o fluxo completo de síntese e mapeamento de hardware. O catálogo de IP reforça o estudo de blocos essenciais para a construção de processadores e sistemas embarcados.",
        "transcription": "Esse aqui é o jeitão do Quartus. Então, ele é um ambiente de desenvolvimento profissional. Não essa versão Lite que a gente está usando. Mas, a versão Pro. É o que é usado nas grandes empresas para a fabricação de seus chips. Esse software aqui. O que nós vamos fazer? Como eu já tenho aqueles arquivos descompactados, eu vou recuperar o projeto arquivado. Então, eu vou em Project e Restore. Vou achar onde é que está aquele arquivo. É que ele abre em outra janela. Eu já mencionei aqui. Então, eu sei que eu descompactei isso aqui. Está aqui. Então. Nesse caso, tem até uma a mais, que é uma de configuração, que a gente não vai ver. Então, vamos trabalhar com o decoder de sete segmentos primeiro. Então. O que é o decoder de sete segmentos? É um circuitinho decodificador de binário para display de sete segmentos. Então. Importou. Está importando. Está importando. Pronto. Então.",
        "video_source": "OAC_2022-03-09.mp4"
    },
    {
        "id": 8,
        "timestamp_start": 3999.12,
        "timestamp_end": 5259.28,
        "slide_description": "Como Engenheiro de Computação Sênior, analisei o slide de uma aula de Arquitetura de Computadores, focando na extração e descrição do conteúdo técnico para um sistema de busca semântica.\n\nO slide apresenta uma tela de conferência web (\"ConferênciaWeb - Sala de Aula de OAC\") em andamento, com um cronômetro indicando \"77:15\". O professor, identificado como \"Marcus Vinicius Lamar\", do \"Departamento de Ciência da Computação\" da \"Universidade de Brasília\", é visível no canto inferior direito.\n\nA área principal da tela exibe o ambiente de desenvolvimento integrado (IDE) \"Quartus Prime Lite Edition\" da Intel/Altera, indicando que o foco da aula é projeto de hardware usando HDL (Hardware Description Language), especificamente Verilog. O título do projeto no IDE é \"C:/Users/mvlam/Dropbox/Kiko/Disciplinas/UnB/OAC/2021-2/Lab2/DECODER7_restored/TopDE\".\n\nNo painel esquerdo do IDE (\"Project Navigator\"), a aba \"Files\" está selecionada, listando arquivos como `decoder7.v` (o arquivo atualmente aberto), `decoder7_tb.v`, `TopDE.v`, e `TopDE.vwf`. Abaixo, a seção \"Tasks\" detalha as etapas de compilação de hardware, incluindo \"Compile Design\", \"Analysis & Synthesis\", \"Fitter (Place & Route)\", \"Assembler (Generate programm...)\", \"Timing Analysis\", e \"EDA Netlist Writer\".\n\nO editor de texto no centro da tela exibe o código Verilog do arquivo `decoder7.v`. O trecho visível (linhas 8-42) define um bloco `always` disparado em modo assíncrono (`always@(*)`), com um comentário indicando também a opção síncrona (`// always@(posedge clk)`). Dentro do bloco, há uma atribuição `Rin<=In;` (assumindo `In` como entrada e `Rin` como um registrador ou fio interno de 4 bits, declarado como `reg [3:0] Rin;` na linha 9). Um comando `case (Rin)` decodifica a entrada `Rin` (de 4 bits) para atribuir valores a uma saída `Out` (aparentemente de 7 bits, considerando a negação bit a bit `~7'b...`).\n\nAs atribuições `Out <= ...` parecem implementar uma lógica combinacional de decodificação, potencialmente para um display de sete segmentos ou uma função similar, dado que os padrões binários de 7 bits (`1111111`, `0000110`, `1011011`, etc.) são tipicamente associados a esses dispositivos. Há padrões repetidos para `4'b1000` e `4'b1100`, que atribuem o mesmo `Out` (ex: `~7'b1111111` para `4'b1000`), o que pode ser um erro, uma redundância intencional ou parte de um requisito específico do projeto. A cláusula `default: Out <= ~7'b0000000;` define o comportamento para entradas não explicitamente listadas.\n\nNa parte inferior do IDE, a janela \"Messages\" exibe o log de compilação, indicando que o projeto Quartus foi restaurado com sucesso de um arquivo `.qar` (Quartus Archive) e que a avaliação de um script TCL (`qar.tcl`) foi bem-sucedida, resultando em \"0 errors, 0 warnings\", o que sugere um estado de projeto funcional.\n\nÀ direita, um painel rotulado como \"IP Catalog\" exibe uma estrutura de diretórios e bibliotecas de IP (Intellectual Property). As categorias de IP incluem \"Basic Functions\", \"DSP\", \"Interface Protocols\", \"Memory Interfaces and Controllers\", \"Processors and Peripherals\", e \"University Program\". Isso indica que a aula pode envolver o uso de IPs pré-existentes ou a criação de componentes que se enquadrem nessas categorias.\n\nNo painel esquerdo da conferência web, um chat público (\"Bate-papo público\") está ativo, com mensagens de estudantes fazendo perguntas e comentários. Notavelmente, há uma pergunta de \"Eduardo Ferreira Ma...\" sobre \"que que significa assincrono mesmo\" às 15:07, diretamente relevante para a linha de código Verilog `always@(*)` e o comentário sobre síncrono/assíncrono. Outro aluno, \"Ualiton Ventura Da...\", comenta que \"ele reconhece o fim por conta da identação\", o que pode se referir à estrutura do código Verilog ou a outro contexto discutido.\n\nNão há diagramas explícitos de Datapath, Pipeline ou Hierarquia de Memória visíveis no slide. O foco visual está inteiramente no código HDL e no ambiente de desenvolvimento para sua implementação.",
        "transcription": "Primeira coisa: síncrono é quando você tem um sinal de clock mandando as coisas acontecerem. Assíncrono é quando você não tem um sinal de clock mandando as coisas acontecerem. Então, todos os circuitos combinacionais são assíncronos. Você muda a entrada, você muda a saída, ok? Então, aqui a gente possibilita diversas visualizações. Eu gosto de ver a visualização \"Files\", que daí eu tenho, eu vejo os arquivos que têm aqui dentro desse projeto, tá? Então, dentro aqui desse projeto, tem o \"Top DE\". Esse \"Top DE\" aqui é pra a gente mexer com a plaquinha. A gente não vai mexer com a plaquinha, então a gente não precisa trabalhar com ele. Esse \"Test Bench\" também a gente não vai mexer com ele, então a gente vai trabalhar só com esse \"decoder7.v\". Dando dois cliques aqui a gente abre ele.\n\nE depois a gente vai trabalhar com esse \"decoder7.v\", então, o que é o circuito que eu quero gerar? Eu quero gerar um circuito... meu Deus... só... só, assim. Eu quero gerar um circuito, então, um bloquinho de circuito, que entre um número binário de 4 bits, certo? Então, nesse caso aqui eu estou chamando de `In` 4 bits, e gerem sete sinais de saída aqui, 4, 5, 6, 7, que vão controlar um display de sete segmentos, certo? Coisa feia, mas vocês entenderam a ideia, né? Vamos fazer direitinho: 1, 2, 3, 4, 5, 6, 7, tá? Então, cada um desses fios acende um desses LEDs aqui, certo? Um display de sete segmentos. E aqui, a menos significativa até a mais significativa, 0, 1, 2, 3. E aqui essas sete saídas. Ok?\n\nEntão, eu quero que quando aqui seja, quando eu coloque aqui na entrada 0, 0, 0, 0, eu quero que mostre o número zero, quer dizer que ele acenda todos os LEDs, menos esse aqui do meio, para mostrar o número zero, ok? Ah, deixa eu mostrar uma coisa aqui para vocês. Meu Deus do céu, eu vou perder esse desenho que eu fiz. Tudo bem, vamos lá. Esse aqui é o LED 0, LED 1, LED 2, LED 3, LED 4, LED 5 e LED 6, tá? Essa é a contagem dos LEDs. Eu ia mostrar pra vocês na, ali na plaquinha, mas se eu sair daqui eu perco esse desenho, ok?\n\nEntão, vamos lá, vamos lá. Então, esse aqui é o LED 0, LED 1, LED 2, LED 3, LED 4, LED 5 e o último é esse aqui, LED 6, tá? Então, quando eu entre com o 0, 0, 0, 0, eu quero que todos os LEDs sejam acesos, menos o seis, ok? Ah, e assim por diante. Se eu quero... se eu entrar com o número 0, 0, 0, 1 (esse aqui é o menos significativo), eu quero que somente os LEDs 1 e 2 se acendam, para fazer o número 1. Um, um, um, um, um, o número 1. E assim sucessivamente. Cada um... cada número binário aqui vai gerar o número. Inclusive, se eu botar 10 aqui, eu quero que apareça o A. Se eu colocar 11, eu quero que apareça o B. 12, eu quero que apareça o C. 13, apareça o D. 14, apareça o E. E 15, apareça o F, tá?\n\nMas como é que eu faço a diferenciação do 8? Ah, vamos lá fazer. Do 8 e do B. Oito são todos acesos e o B a gente faz assim, esse é o B. O B vai ser desse jeito assim, esse aqui é o B. Ok pessoal? Entendido? Ok, então o que eu preciso fazer? Ó, eu precisaria criar a tabela verdade disso aqui, simplificar a tabela verdade vai ser um mapa, vão ser sete mapas de Karnaugh de quatro variáveis cada um pra poder gerar os circuitos que vai acionar cada um desses fiozinhos, né? Então vocês vejam que isso aqui vai dar um certo trabalhinho pra projetar esse circuito, certo? E aí vem o Verilog pra nos ajudar. Se eu apertar S aqui eu vou perder esse negócio, com certeza. Ó, eu sabia.\n\nEsse negócio... mas vamos lá. Então vamos ver a nossa descrição Verilog daquele circuitinho. Então eu vou chamar ele de `decoder7`. Então `module decoder7`, lista das entradas. Então eu tenho uma entrada `In` que é de 4 bits, então do 3, 2, 1, 0, certo? Vou ter uma entrada do tipo `logic Out`, que são 7 bits, então 6, 5, 4, 3, 2, 1, 0, certo? E nesse caso aqui eu nem precisaria desse sinal de clock, tá? Porque nós não vamos usar o síncrono, nós vamos usar o assíncrono. Então provavelmente a gente pode, ah, deixa assim, deixa assim pra não criar fatos, tá? Vamos colocar aqui, escolher o modo assíncrono, tá? Então o modo assínrono eu vou usar `always @(*)`. Quer dizer, eu quero gerar um circuito combinacional, né? `always @(*)`.\n\nSe eu tivesse deixado desse `always @(posedge clk)`, eu estaria gerando um circuito síncrono, onde eu vou ter registradores na saída e esses registradores só atualizam seus valores quando vier a borda de subida do clock, tá? Então nesse caso aqui, o `Out` seria `reg`, e o `In` seria `wire`, certo? Do jeito que eu tirei essa parte aqui, então os dois vão ser `wire`, vão ser fios, ok? `always @(*)` eu estou definindo aqui um registrador interno `Rin`, tá? De 4 bits, que era pra usar no modo síncrono, mas como a gente não vai estar usando no modo síncrono esse aqui não vai servir pra nada, tá? Então o `Rin`, ah, outra coisa: quando vocês querem botar várias instruções dentro de um `if`, por exemplo, como é que vocês fazem em Python pra colocar várias instruções dentro de um `if`? Então `if` igual a 1, o que que marca, que que vocês fazem pra botar várias instruções aqui? Me falem, porque em C eu sei.\n\nPython: dois pontos, dois pontinhos, identação. Identação, daí escreve as coisas aqui, e pra terminar faz o quê? Nada. Simplesmente isso, acaba a identação, acaba a identação, acaba o `if`. Python de Deus. Ok, já que é assim mesmo, o que diferencia o final e o início é a identação, é a identação, eu sei. Tá, em C pelo menos o código sai bem bonitinho. Em C a gente faz abrindo e fechando as chaves, certo? Assim, então tudo que tiver entre as chaves é o que ele vai executar, então não precisa de identação, eu posso usar a formatação que eu quiser, certo? Então, e outras linguagens de programação, tipo Pascal, eles usam `begin`, escreve o que o `if` tem que fazer, e `end`, certo?\n\nEntão no caso do Python é a identação que identifica onde é que é, quais são as instruções que devem ser executadas. No caso do C é esse abre e fecha chaves que determina. E o Pascal é o `begin` e `end` que determina o que está dentro desse `if`, ok? No caso de Verilog ele usa algo similar a isso aqui, tá? Então `always @(*)` eu poderia colocar só um comando aqui dentro, mas eu quero colocar mais, então eu vou colocar `begin` e `end`. `begin` e `end`. Então esse `end` aqui termina nesse `begin` aqui. É o `end` de início e fim. E o que que ele vai fazer? Ele vai colocar nesse registrador o valor de `In`. Que que é `In`? É a nossa entrada. E eu posso colocar dentro do `always` estruturas complicadas, tipo `for`, `while`, já falei isso, `if-then-else`, tá? E `case` é uma dessas instruções que a gente pode utilizar, tá?\n\nNão é... em Python, tá com vocês, ok? Então `case` é uma estrutura que eu defino aqui qual é a minha variável, então `case (Rin)` nesse caso aqui, tá? Que é igual ao `In`, tá? Então `case (Rin)`. Se o `In` for igual a `4'b0000`, a minha saída vai ser `7'b0111111`. Como é que era? Se eu queria desenhar o número 0, eu tinha que ter todos os LEDs acesos, com exceção do primeiro que é o número 6, que é o mais significativo. Se a entrada for `0001`, então eu quero escrever o número 1 binário, né? Então eu vou acender somente os dois LEDs que é o 1 e o 2. Então aqui é LED 0, LED 1, LED 2, LED 3 e assim por diante, certo? E assim pra todos os outros números. Eu vou desenhar aqui a letra, ok?\n\nEntão, notem, o que que é isso aqui? Isso aqui é uma descrição comportamental de como que eu quero que o meu circuito se comporte. Se eu tenho essa entrada, eu quero ter essa saída. Se eu tenho essa entrada, eu vou querer ter essa saída. Se eu tenho essa entrada, eu vou querer ter essa saída. Isso aqui, se vocês virem de outro jeito, isso aqui nada mais é do que a tabela verdade que define qual é a relação das entradas com as saídas, certo? Quer dizer, pra eu implementar qualquer que seja a tabela verdade sem precisar levantar equações lógicas, basta eu utilizar essa estrutura `case`, né? Então, caso a entrada seja esse, a saída vai receber isso, e fica simples.\n\nE no `case` sempre a gente tem que ter um `default`, tá? Um `default` quer dizer: se não for nenhum desses aqui, ele vai colocar tudo apagado, certo? E nesse caso aqui nunca vai acontecer isso porque a gente vai usar os números de 0 até 15, né? Então o `default` a princípio nunca vai entrar, mas é bom a gente sempre colocar `default` porque vai que a gente esqueça alguma coisa aqui, né? E o Quartus vai reclamar que não sabe o que fazer com aquela situação, né, se a gente esquecer uma dessas linhas aqui. Então `case` desse jeito, `endcase`, certo? Então o que a gente fez aqui foi um circuito combinacional que apresenta essa tabela verdade. Quer dizer, relacionar essas entradas com essas saídas. Desse jeito a gente não está especificando qual é o circuito que está fazendo isso, a gente está especificando o comportamento, ok?\n\nEntenderam essa descrição Verilog? Dúvidas em relação a isso aqui? O que pode ter não ficado claro? Ninguém. Só pra lembrar, o conteúdo de história também, professor. Hã? A gente tá fazendo ele assíncrono, né? É, a gente tá fazendo ele assíncrono. Logo é pela, pelo nível lógico do Quartus, né? Ou pelo nível do Quartus, não, esqueci exatamente. Professor, assíncrono significa que entra a entrada, a saída é dada instantaneamente após o `tpd`, não tem clock. Ah, sim, tá? Quer dizer, `always @(*)` quer dizer, sempre isso aqui vai estar sendo avaliado. Se o `In` é isso aqui, ele vai estar colocando o `Out` esse aqui. Sempre. O `In` mudou, ele mudou o `Out` pra outra coisa, não tem clock aqui. Se eu colocasse essa linhazinha aqui, comentasse essa e descomentasse essa, aí sim seria síncrono. Somente na borda de subida do clock, né, é que isso aqui aconteceria, ok? Entendi, valeu. Beleza. Hã?\n\nEntão vamos sintetizar isso aqui, tá? Pra sintetizar, ah, no caso aqui eu fiz alguma modificação, né, que foi essas aqui. Então salva. Se não salvar, ele vai pedir pra salvar de qualquer jeito, ele vai salvar automaticamente. E a gente, quando o \"Compilation\" é esse aqui, ó, ele vai passar por esses passos aqui, tá? Então ao invés de pedir passo a passo, se eu fizer esse `Compile Design` aqui, ele vai fazer tudo de uma vez só. Ele vai dizer, ó, \"Foi modificado, quer salvar?\" Sim, quero salvar, tá? Daí ele vai começar a compilar essa nossa descriçãozinha aqui, ó, minha Verilog. Essa compilação, essa compilação às vezes pode demorar, tá? Então, no caso da ULA, eu acho que pode demorar no máximo uns 3 minutos, talvez, tá? Aqui embaixo ele vai mostrando aqui, ó, ele passou por essa etapa, agora ele tá nessa etapa aqui. O processador, quando a gente trabalhava lá no laboratório, costumava demorar 40 minutos pra compilar. Então 3 minutinhos da ULA é tranquilo, tá?\n\nEssa aqui é a etapa que mais demora, que é a etapa onde ele vai tentar achar quais elementos lógicos do FPGA que ele vai utilizar pra implementar o nosso circuito. Então acabou essa etapa, agora ele vai criar os programas pra programação do FPGA, vai fazer uma \"pre-timing analysis\", quer dizer, uma análise temporal, e depois o \"Netlist Viewer Writer\" pra gente poder usar no Viewer. Ok, acabou de compilar, zero erros, ok, 100% da compilação feita. Opa, cadê? Quem tá aqui? Ah, tá aparecendo essa. Ah, agora sim, tá aqui 100% da compilação feita, tá? E demorou 1 minuto e 21 pra compilar. Ok. Uma vez compilado, o que a gente pode fazer, tá? A gente pode verificar qual é o circuito que foi gerado, né?\n\nEntão, vindo em `Tools`, `Netlist Viewers`, `RTL Viewer`. O que que é RTL? RTL: Register Transfer Level. Então ele vai mostrar aquele nível de transferência de registradores, os 4 níveis que o Verilog tem, tá? Então `RTL Viewer`, e tá aqui o... tá caindo, não tá caindo... tá aqui o circuitinho implementado que ele vai sintetizar. Então pra entender esse circuitinho, isso aqui é um decodificador 4 pra 16. Como é que funciona esse decodificador? Você entra `0000` aqui, o pino de 0 aqui. Notem que aqui são 16 fiozinhos, certo? Então 4 pra 16. E somente uma dessas entradas, dessas saídas aqui vai ser 1, dependendo de qual é a entrada. E essa entrada vai ser, então, vai ser a entrada dessas portas OR que vai acionar cada saída. Essa porta OR aciona um LED, tá? Então esse aqui aciona o LED 0, LED 1, LED 2, LED 3, LED 4, LED 5 e LED 6, certo? Então basta um decodificador e portas OR. A gente gera o nosso circuito, ok?\n\nOk. Vamos ver lá na, no roteiro, que mais que isso... que mais que tem que ser feito? Ah, que legal. Veja o diagrama esquemático do circuito só pelo método de vista RTL Viewer. Foi isso que a gente acabou de fazer, tá? Essa letra B aqui. Vamos fazer a letra A. Como é que a gente sabe qual é o custo da construção de um chip, tá? Ou o custo da implementação, o custo de um chip está relacionado com a sua área, tá? Quanto maior a área do circuito necessário, tá, maior é o custo do chip, tá? Então os processadores Intel são imensos, ocupa uma área de um `wafer` por isso que eles são caros. No nosso caso aqui, a gente tá trabalhando com FPGA. Então o custo dos nossos circuitos a gente vai medir de acordo com o número de ALMs, o número de elementos lógicos, certo?\n\nE então isso em seus requerimentos físicos. O que vão ser os requerimentos físicos do meu circuito? É o número de elementos lógicos, número de registradores, tá? Que vai ser, que forem necessários, a quantidade de bits de memória que forem necessários e o número de blocos de DSP, que são os multiplicadores. Então esses quatro elementos aqui são os requerimentos físicos do meu circuito. Aonde que eu tiro isso? Logo que ele acabou de sintetizar, ele te dá esse `reportzinho` aqui. E nesse `reportzinho`, então, a gente tira esses elementos. Então o número de ALMs: utilizou 10 de 32 mil, então precisou de 10 ALMs. O número de registradores: não precisou de nenhum registrador. Número de DSPs: também não precisou de nenhum multiplicador. Número de blocos de bits: precisou de nenhum também, ok? Então daqueles nossos quatro elementos, que é esse, esse e esse, somente 10 ALMs foram necessárias, certo? Mas poderia ter tido registrador, poderia ter tido bits de memória utilizados, poderia ter tido multiplicadores utilizados, ok? Então, entendido como é que se tira...",
        "video_source": "OAC_2022-03-09.mp4"
    },
    {
        "id": 9,
        "timestamp_start": 5259.28,
        "timestamp_end": 5327.16,
        "slide_description": "Como um Engenheiro de Computação Sênior, analiso o slide e o conteúdo anotado apresentados em uma aula de Arquitetura de Computadores.\n\nO slide exibe a interface gráfica do usuário (GUI) do Intel Quartus Prime Lite Edition, um software de design e compilação para Field-Programmable Gate Arrays (FPGAs). O título da janela do Quartus indica que o projeto atual é \"TopDE\" localizado em `C:/Users/mylam/Dropbox/kiko/Disciplinas/UnB/OAC/2021-2/LAB2/DECODER7_restored/TopDE`, sugerindo um laboratório de Arquitetura de Computadores (OAC) de 2021-2 focado em decodificadores.\n\nNa seção do \"Project Navigator\", são listados os seguintes arquivos do projeto: `decoder7.v`, `decoder7_tb.v`, `TopDE.v`, `TopDE_tb.v` e `TopDE.vwf`. Estes são, respectivamente, o código-fonte Verilog para um módulo `decoder7`, seu testbench, o módulo Verilog de nível superior do projeto (`TopDE`), seu testbench, e um arquivo de forma de onda para simulação ou visualização.\n\nA área principal da tela exibe um \"Compilation Report - TopDE\". O painel esquerdo do relatório funciona como um índice, mostrando a hierarquia e as etapas do fluxo de compilação. As seções visíveis incluem \"Flow Summary\", \"Analysis & Synthesis\", \"Fitter\", \"Assembler\", \" \"Timing Analyzer\" e \"EDA Netlist Writer\", com cada uma delas podendo ser expandida para detalhes adicionais. Atualmente, a seção \"Analysis & Synthesis\" está expandida, e \"Resource Utilization by Entity\" está selecionada, indicando o foco da análise.\n\nO painel direito do relatório apresenta o conteúdo de \"Analysis & Synthesis Resource Utilization by Entity\". É exibida uma tabela com as seguintes colunas: \"Compilation Hierarchy Node\", \"Combinational ALUTs\", \"Dedicated Logic Registers\", \"Block Memory Bits\" e \"DSP Blocks\". Para o nó de hierarquia \"decoder7\", os valores são: \"7 (7)\" para \"Combinational ALUTs\", \"0 (0)\" para \"Dedicated Logic Registers\", \"0\" para \"Block Memory Bits\", e \"1\" para \"DSP Blocks\". Uma nota explicativa no rodapé da tabela informa que, para entradas com dois números, o valor entre parênteses indica os recursos usados pela entidade específica isoladamente, enquanto o valor fora dos parênteses indica o total de recursos usados pela entidade e todas as suas subentidades na hierarquia. Neste caso, `decoder7` utiliza 7 ALUTs combinacionais e, notavelmente, 1 Bloco DSP, o que é atípico para um decodificador simples e pode indicar uma funcionalidade mais complexa mapeada para esse recurso, ou que é parte de um sistema maior onde a ferramenta otimizou o uso do DSP. A ausência de registradores dedicados e de blocos de memória sugere uma lógica puramente combinacional ou o uso de memória distribuída nos ALUTs, e não memória de bloco.\n\nNa parte inferior esquerda da tela do Quartus, a aba \"Tasks\" mostra o status do processo de compilação. Todas as etapas principais - \"Compile Design\", \"Analysis & Synthesis\", \"Fitter (Place & Route)\", \"Assembler (Generate programming files)\", \"Timing Analysis\" e \"EDA Netlist Writer\" - estão marcadas com um visto verde, indicando que foram concluídas com sucesso.\n\nA aba \"Messages\", na parte inferior central, exibe os logs de compilação. As mensagens incluem: \"Quartus Prime Full compilation was successful. 0 errors, 998 warnings.\" (Compilação completa bem-sucedida, sem erros, mas com 998 avisos, o que é um número alto e pode demandar investigação para otimização ou correção de potenciais problemas latentes). Outras mensagens indicam o início e o sucesso do \"Quartus Prime Netlist Viewers Preprocess\", e um aviso (`ID 18236`) sobre o \"Number of processors\" não especificado, o que \"pode causar sobrecarga em máquinas compartilhadas\", sugerindo a configuração da variável `NUM_PARALLEL_PROCESSORS`.\n\nNo painel lateral direito do Quartus, parcialmente visível, encontra-se o \"IP Catalog\", que lista categorias de blocos de IP (Intellectual Property) disponíveis: \"Installed IP\", \"Project Directory\", e uma \"Library\" contendo \"Basic Functions\", \"DSP\", \"Interface Protocols\", \"Memory Interfaces and Controllers\", \"Processors and Peripherals\" e \"University Program\". Isso demonstra a capacidade da ferramenta de integrar componentes de hardware pré-fabricados.\n\nAdicionalmente, a tela inclui elementos de uma plataforma de conferência web. Um chat lateral mostra interações de alunos em Português, com perguntas e comentários como \"que significa assíncrono mesmo\", \"não tem clock\", \"ele reconhece o fim por conta da identação\" e \"eita 40min\", refletindo discussões sobre conceitos de arquitetura digital e possibly sobre a sintaxe do Verilog ou o tempo de aula. O professor, Marcus Vinicius Lamar, da Universidade de Brasília, é visível na webcam e o temporizador da aula mostra \"88:20\".",
        "transcription": "Os requerimentos físicos. Uma outra forma de se tirar esses requerimentos físicos é aqui em Análise e Síntese. Depois que ele acaba de compilar, a gente pode ver aqui, esse aqui é o Resource Utilization by Entity, de acordo com a entidade. No nosso caso, a gente só tem uma entidade, então aqui está o número de, no caso aqui, é o número de elementos de ALUTs e a gente dá o número de ALUTs aqui, mas te dá o número de registradores, a quantidade de bits e a quantidade de DSPs, que são multiplicadores. Esse aqui o número de ALUTs é relacionado com o número de ALUTs, mas é preferido usar o número de ALUTs. ALUTs. Perdi porque eu, desculpe, quer dizer, eu perdi a compilação, mas já está aqui. Beleza? Então.",
        "video_source": "OAC_2022-03-09.mp4"
    },
    {
        "id": 10,
        "timestamp_start": 5327.16,
        "timestamp_end": 5756.99,
        "slide_description": "A imagem apresenta uma tela de aula de Arquitetura de Computadores (OAC), focada na utilização da ferramenta de design eletrônico (EDA) **Quartus Prime Lite Edition** da Intel/Altera para simulação funcional de um projeto. O instrutor, Marcus Vinicius Lam..., está demonstrando o processo de simulação em tempo real.\n\n**Conteúdo Principal – Ambiente de Desenvolvimento e Simulação:**\n\nA janela central exibe o ambiente Quartus Prime, especificamente trabalhando no projeto localizado em `C:/Users/mvlam/Dropbox/Kiko/Disciplinas/UnB/OAC/2021-2/LAB2/DECODER7_restored/TopDE`. O foco está no arquivo de forma de onda `decoder7.vwf`.\n\n1.  **Painel Esquerdo – Navegador de Projetos e Arquivos:**\n    *   Exibe os arquivos do projeto, incluindo:\n        *   `TopDE.v`: Módulo Verilog de nível superior (Top-level Design Entity).\n        *   `TopDE_tb.v`: Testbench Verilog para o módulo `TopDE`.\n        *   `TopDE.vwf`: Arquivo de forma de onda para `TopDE`.\n        *   `decoder7.v`: Módulo Verilog do decodificador (provavelmente um submódulo de `TopDE`).\n        *   `decoder7_tb.v`: Testbench Verilog para o módulo `decoder7`.\n        *   `decoder7.vwf`: Arquivo de forma de onda para `decoder7` (o arquivo atualmente aberto).\n    *   Isso indica uma estrutura de projeto hierárquica e a preparação para verificação funcional via testbenches e análise de formas de onda.\n\n2.  **Painel Inferior Esquerdo – Tarefas de Compilação:**\n    *   Mostra o status de várias etapas do fluxo de design de FPGA, todas marcadas como concluídas com sucesso (indicadas por ticks verdes):\n        *   \"Compile Design\"\n        *   \"Analysis & Synthesis\" (Análise e Síntese)\n        *   \"Fitter (Place & Route)\" (Mapeamento e Roteamento)\n        *   \"Assembler (Generation of Programming Files)\" (Geração dos arquivos de programação)\n        *   \"EDA Netlist Writer\" (Escrita do Netlist para ferramentas EDA externas)\n    *   A \"Timing Analysis\" (Análise de Temporização) também está listada, mas seu status não é visível.\n\n3.  **Janela Flutuante – \"Simulation Options\" (Opções de Simulação) – Destaque Técnico:**\n    *   Esta é a seção mais proeminente e tecnicamente densa.\n    *   **Aviso:** \"Caution: Improperly modifying these settings can cause the simulation to fail\" (Cuidado: A modificação incorreta dessas configurações pode fazer a simulação falhar).\n    *   **Aba Ativa:** \"Functional Simulation Settings\" (Configurações de Simulação Funcional), indicando que o foco está na lógica e comportamento, não nos atrasos de temporização.\n    *   **Linguagem HDL:** \"Verilog\" está selecionado (com \"VHDL\" como alternativa).\n    *   **Testbench Generation Command (Functional Simulation):**\n        ```\n        quartus_eda --gen_testbench --tool=modelsim_oem --format=verilog --write_setting\n        ```\n        Comando Quartus EDA para gerar um testbench em Verilog compatível com ModelSim OEM, com base nas configurações atuais.\n    *   **Netlist Generation Command (Functional Simulation):**\n        ```\n        quartus_eda --write_settings_files=off --simulation=functional --on --flatten_buses=\n        ```\n        Comando Quartus EDA para gerar o netlist funcional (sem informações de temporização de portas, apenas lógica), com a opção de \"achatar barramentos\" para facilitar a visualização.\n    *   **ModelSim Script (Functional Simulation):** Este script (em Tcl) define a sequência de comandos para o simulador ModelSim:\n        ```tcl\n        onerror {exit -code 1} ;# Sai em caso de erro\n        vlib work           ;# Cria a biblioteca de trabalho 'work'\n        vlog -work work TopDE.vo ;# Compila o arquivo Verilog otimizado (netlist pós-síntese) TopDE.vo na biblioteca 'work'\n        vlog -work work decoder7.vwf.vxt ;# Compila o arquivo de vetores de forma de onda decoder7.vwf.vxt na biblioteca 'work'\n        vsim -novopt -t 1ps -L cyclonev_ver -L altera_ver -L altera_mf_ver -L 220mode ;# Inicia o simulador ModelSim\n            ;# -novopt: Desabilita otimização para melhor depuração\n            ;# -t 1ps: Define a unidade de tempo padrão para 1 picosegundo\n            ;# -L ...: Mapeia bibliotecas específicas do Cyclone V, primitivas Altera e MegaFunções Altera\n        vcd file -direction TopDE.msim.vcd ;# Define o arquivo Value Change Dump (VCD) para registrar as transições de sinal\n        vcd add -internal decoder7_vlg_vec_tst/* ;# Adiciona todos os sinais internos da instância do testbench decoder7_vlg_vec_tst ao VCD\n        vcd add -internal decoder7_vlg_vec_tst/i1/* ;# Adiciona sinais internos da sub-instância 'i1' do testbench ao VCD\n        proc simTimestamp () { ;# Define um procedimento Tcl para exibir o tempo de simulação\n            echo \"Simulation time: $now ps\"\n            if {[string equal running [runStatus]]} {\n                after 2500 simTimestamp ;# Se a simulação estiver rodando, agenda a próxima chamada após 2500 unidades de tempo\n            }\n        }\n        after 2500 simTimestamp ;# Agenda a primeira chamada para simTimestamp\n        run -all ;# Executa a simulação até o fim\n        ```\n        Este script detalha o fluxo completo de compilação de módulos, inicialização do simulador com bibliotecas específicas, configuração de rastreamento de sinais (VCD) e execução da simulação, incluindo um mecanismo para monitorar o progresso.\n\n4.  **Painel Central Direito – Editor de Forma de Onda (`decoder7.vwf`):**\n    *   Mostra uma representação gráfica das formas de onda para os sinais de entrada e saída do `decoder7`.\n    *   **Sinais visíveis:**\n        *   `In`: Barramento de entrada (provavelmente 4 bits), com valor inicial `B0000`.\n        *   `Out`: Barramento de saída (largura não especificada, `BXXXXX` inicialmente, pois é uma saída).\n        *   `Clk`: Sinal de clock (1 bit), com valor inicial `B1`.\n    *   O gráfico exibe transições de sinais em diferentes pontos no tempo (e.g., 200.0 ns, 240.0 ns, 280.0 ns, 320.0 ns) e os valores binários correspondentes para `In` (1001, 1010, 1011, 1100, 1101, 1110, 1111). A forma de onda do `Clk` também é visível, indicando um pulso de clock. Este editor é fundamental para a verificação visual do comportamento do decodificador.\n\n5.  **Painel Inferior Central – Mensagens:**\n    *   Exibe mensagens do Quartus Prime, incluindo:\n        *   `Command: quartus_npp TopDE -- -netlist_type=gate`: Comando para gerar um netlist em nível de porta para `TopDE`.\n        *   `18236 Number of processors has not been specified...`: Um aviso sobre a configuração do número de processadores para compilação paralela.\n        *   `Quartus Prime Netlist Viewers Preprocess was successful. 0 errors, 1 warning`: Confirmação do sucesso do pré-processamento do netlist sem erros, mas com um aviso.\n\n**Conteúdo Adicional – Chat da Aula:**\n\nO painel de chat à esquerda (\"Bate-papo público\") mostra interações de alunos com o instrutor e entre si. Há perguntas e comentários que podem estar relacionados à demonstração:\n*   \"que significa assincrono mesmo\" e \"não tem clock\" indicam que conceitos de temporização e projetos assíncronos/síncronos estão sendo discutidos, o que é altamente relevante em um contexto de simulação de hardware e arquitetura de computadores.\n*   \"ele reconhece o fim por conta da identação\" pode se referir à sintaxe Verilog ou Tcl, onde a indentação pode influenciar a interpretação do código ou script.\n\n**Em Resumo:**\n\nO slide documenta uma sessão prática de Arquitetura de Computadores focada na verificação funcional de um design de hardware (especificamente um decodificador, `decoder7` dentro de um `TopDE`) usando o software **Quartus Prime Lite Edition** e o simulador **ModelSim**. Ele mostra o fluxo completo desde a compilação do design Verilog até a geração do netlist, configuração detalhada da simulação funcional via um script Tcl do ModelSim (incluindo a especificação de bibliotecas, rastreamento de sinais VCD e execução), e a visualização dos resultados através de um editor de formas de onda. As discussões no chat sugerem que o tópico de sistemas síncronos e assíncronos está em pauta, diretamente ligado à interpretação dos sinais de clock e comportamento de decodificadores.",
        "transcription": "Vou mostrando aqui, então, como que a gente faz os requerimentos físicos desse módulo, tá vendo? Esse relatóriozinho. Ok, mas será que não dá para a gente simular o nosso circuito? Dá, dá para simular, tá? Então a gente pode fazer a simulação. A simulação que nós vamos fazer aqui são dois tipos de simulação. Um é a simulação por forma de onda, tá? Então, esse `decoder7.vwf`, se vocês derem dois cliques, ele vai abrir essa janelinha aqui, tá? Porque a forma de onda, nesse aí o projeto, eu já deixei pronto a forma de onda para vocês. Quer dizer, eu estou variando aqui `In`, né, que são 4 bits, tá? Então, `0000`, `0001`, `0010` até `1111`, certo? Então, são 16 possíveis entradas. Esse `Clk` aqui está aqui só porque tem um clock lá, então esse `Clk` a gente não precisa. E aqui o `Out`, quer dizer, quando eu simular, eu quero obter esse `Out` aqui, tá? O que que vai aparecer aqui? Então, fazer a simulação. Deixa eu tentar fazer como vocês faziam, se vai dar certo. Então aqui eu tenho duas formas de fazer a simulação: simulação funcional e simulação temporal, tá? A simulação funcional, ele vai considerar todas as portas lógicas. Não tem atraso, então ele vai verificar se a função lógica que vocês queriam implementar está correta, certo? Então ele considera as portas lógicas ideais. Na simulação temporal, ele deveria fazer a simulação considerando os atrasos das portas lógicas. O problema é que a Intel acha que o Cyclone V, que é esse nosso chip FPGA, ele não é de uso industrial, ele é mais de uso acadêmico. Então ela não implementou a simulação temporal para esse nosso FPGA. Então, se vocês tentarem fazer a simulação temporal, vai dar a mesma coisa que a funcional, tá? Porque a Intel, infelizmente, não quis investir em fazer a simulação temporal para esse Cyclone V, que é o tipo do nosso FPGA. Então, eu fiz a simulação funcional. Então, ao clicar, espero que dê erro. Isso aqui, erro! Já deu erro, né? Foi tão rápido que já deu erro. O que significa esse erro? Então, o erro está escrito no roteiro aqui, roteiro aqui, ó. \"Tá com arquivo de forma de onda `decoder7.vwf`, realize a simulação funcional e temporal. Verifique sempre se o `Simulation Settings` estão no parâmetro `default` e retire o `-novopt`. Ele só gosta do `-vopt`, tá? E tirar o `print screen` das telas para comparação.\" Então, o que isso significa? Para esse aqui funcionar direitinho, eu tenho que vir aqui em simulação, `Simulation Settings`, `Restore`… Opa! Aqui, `Restore Defaults`. Beleza. E eu tenho que apagar esse `-novopt` que aparece aqui, certo? Então, esse aqui eu tenho que apagar. Pronto. E aí eu salvo e agora eu posso fazer a simulação funcional. Então, está escrito lá no roteiro para cuidar disso. Então, aqui, ó, `0000`. O que tinha que dar em `0000`? Quando a entrada fosse `0`, o que tinha que dar? Quando a entrada for `0`, o que deveria ter dado? Entrada `0`, a saída deu isso aqui. Tá certo isso aqui? Se fosse `1`, fosse `1`, teria que ter só esses dois aqui acesos. Tá certo isso? Não, mas tá certo pela descrição Verilog que a gente implementou. Quer ver? Ninguém me perguntou, mas vocês observaram que tem um til aqui na frente? Esse til significa negação. Então, na realidade, quando for `0000`, eu quero que saia o negado disso aqui. Mas por que, professor? Porque na nossa plaquinha, quando eu ponho um nível lógico `0` é que o LED acende. A nossa plaquinha é invertida. Então, para eu acender o LED, eu tenho que colocar nível lógico `0` nele. Para apagar o LED, eu coloco nível lógico `1` nele. Então, como a gente projetou todas elas para que o nível lógico `1` fosse aceso, eu preciso inverter, certo? Então, quando entrar `0000`, vai sair `10000`. Quando entrar `0001`, vai sair `10001`, e assim por diante. Então, essa simulação tá ok, só que a gente não tinha prestado atenção nesse detalhe, certo? Tranquilo? Então, a gente queria que realmente tivesse isso aqui. Então, é essa telinha aqui que eu quero que vocês tirem `print screen` para colocar no relatório, tá? Aí eu vou botar aqui ok. E a última coisa é usando `TimeQuest`. Então, se o nosso simulador não simula tempo de atraso, como é que o tempo de atraso é muito importante para definir a frequência máxima de utilização de um sistema digital? Quer dizer, o Quartus não permite que a gente faça esse tipo de análise? Pelo contrário, ele faz e faz uma análise muito precisa, tá? Então, só que a ferramenta é outra, não é essa aqui, tá? A gente... A forma de onda é só para verificar se a lógica do nosso, do nosso circuito, está aquilo que a gente queria, tá? Então, nesse caso, está. Então, o que que nós vamos fazer? Tá, nós vamos clicar nesse reloginho aqui, ó. Então, para fazer a `Time Analyzer`, tá? Então, a gente vai chamar um outro aplicativozinho chamado analisador de tempos. O analisador de tempos...",
        "video_source": "OAC_2022-03-09.mp4"
    },
    {
        "id": 11,
        "timestamp_start": 5756.99,
        "timestamp_end": 5802.99,
        "slide_description": "Este slide de uma aula de Arquitetura de Computadores (OAC) apresenta uma interface de software para análise de temporização (timing analysis), especificamente o **Quartus Prime Timing Analyzer** da Intel/Altera.\n\n**Contexto da Aula:**\nA tela principal exibe uma sessão de videoconferência intitulada \"ConferênciaWeb - Sala de Aula de OAC\", com um painel lateral esquerdo contendo \"MENSAGENS\", \"Perguntas\", \"Bate-papo público\", \"NOTAS\" e \"USUÁRIOS (19)\". O bate-papo público contém mensagens de alunos questionando termos como \"assíncrono\", mencionando \"não tem clock\" e comentando sobre o tempo (\"eita 40min\", \"3 de boa\"). O cabeçalho da janela do navegador indica \"Sala de Aula de OAC\" e um tempo de \"96:27\". No canto superior direito da tela principal, há informações da instituição: \"Universidade de Brasília\", \"Departamento de Ciência da Computação\", \"OAC0000 - Arquitetura de Computadores\", \"Prof. Marcus Vinicius Lamar\". O professor está visível em um feed de vídeo no canto inferior direito da tela.\n\n**Conteúdo da Aplicação Principal (Quartus Prime Timing Analyzer):**\nA maior parte da tela é dedicada à aplicação \"Timing Analyzer\". O título da janela da aplicação é \"Timing Analyzer - C:/Users/mvlam/Dropbox/kiko/Disciplinas/UnB/OAC/2021-2/Lab2/DECODER7_restored/TopDE - TopDE\", indicando que se trata de um projeto acadêmico (`OAC/2021-2/Lab2`) de um decodificador (`DECODER7_restored`) sendo analisado.\n\nA barra de menus da aplicação inclui \"File\", \"View\", \"Netlist\", \"Constraints\", \"Reports\", \"Script\", \"Tools\", \"Window\", \"Help\". Abaixo, há uma barra de ferramentas com \"Set Operating Conditions\". A área central da aplicação exibe a mensagem \"No timing corners available\" sob a aba \"Getting Started\".\n\nO painel esquerdo da aplicação possui duas seções: \"Tasks\" e \"Console\".\nA seção \"Tasks\" lista os passos comuns no fluxo de design para análise de temporização:\n*   \"✔ Open Project...\" (Completado)\n*   \"► Netlist Setup\"\n*   \"► Create Timing Netlist\"\n*   \"► Read SDC File\"\n*   \"► Update Timing Netlist\"\n*   \"► Reset Design\"\n*   \"► Set Operating Conditions...\"\n*   \"Reports\" (expandido, mostrando relatórios de slack):\n    *   \"✔ Slack\" (Completado)\n    *   \"Report Setup Summar...\" (sumário de setup)\n    *   \"Report Hold Summar...\" (sumário de hold)\n\nA seção \"Console\" exibe comandos TCL e informações:\n*   `Type \"help <package name>\" to view a list of Tcl commands`\n*   `available for the specified Quartus Prime Tcl package.`\n*   `Type \"help -tcl\" to get an overview on Quartus Prime Tcl usages.`\n*   `*******************************************************************`\n*   `tcl> project_open -force \"C:/Users/mvlam/Dropbox/kiko/Disciplinas/UnB/OAC/2021-2/Lab2/DECODER7_restored/TopDE.qpf\" -revision TopDE`\nEste último comando TCL indica a abertura forçada de um projeto Quartus Prime (`.qpf`) para a revisão `TopDE`, confirmando a operação de abertura de projeto mencionada na lista de tarefas.\n\nO painel direito da aplicação serve como uma área de boas-vindas e descrição da ferramenta:\n**Título:** \"Welcome to the Quartus Prime Timing Analyzer\"\n**Texto descritivo:** \"The Quartus Prime Timing Analyzer is a powerful ASIC-style timing analysis tool that validates the timing performance of all logic in your design using industry-standard constraint, analysis, and reporting methodology. You can use the Timing Analyzer to constrain, run, and view results for all timing paths in your design. The Timing Analyzer offers the following features:\"\nEste texto descreve o Timing Analyzer como uma ferramenta de análise de temporização de estilo ASIC, essencial para validar o desempenho temporal de lógicas em um design, utilizando metodologias de restrição, análise e relatórios.\n\nAbaixo do texto de boas-vindas, são descritas as principais seções da interface com miniaturas ilustrativas:\n*   **Report Pane**: \"Lists generated and report panels.\" (A miniatura mostra uma tabela de relatório comum, com colunas para origem, destino, clock, slack, etc.)\n*   **Tasks Pane**: \"Lists common tasks you can perform. Double-click a command to start the step in the flow.\" (A miniatura mostra uma árvore de tarefas, idêntica à seção \"Tasks\" visível no lado esquerdo da aplicação.)\n*   **View Pane**: \"Displays select ed report panels. Split the View pane into sub-panes by dragging the splitter control at the upper right corner of the pane.\" (A miniatura mostra uma área de visualização principal que pode ser dividida para exibir múltiplos relatórios simultaneamente.)\n*   **Console**: \"Displays SDC and Tcl commands executed by the GUI or command line.\" (A miniatura mostra uma interface de linha de comando, semelhante à seção \"Console\" da aplicação.)\n\n**Diagramas:**\nNão há diagramas de arquitetura computacional (como datapath, pipeline ou hierarquia de memória) visíveis diretamente na tela. Em vez disso, as \"miniaturas\" descritas são pequenas ilustrações da interface gráfica do usuário (GUI) do Quartus Prime Timing Analyzer, que servem para explicar o layout e as funcionalidades da ferramenta para análise de temporização. As imagens são exemplos de relatórios tabulares e da estrutura de painéis da interface.",
        "transcription": "ele abre essa janelinha aqui, ó. Tá? Então, ele já tá com o nosso circuito carregado pra gente poder utilizar o analisador temporal. Nós temos aqui que passar por esses passos. Então, em negrito, tá aqui os passos que eu preciso fazer manualmente, tá? Então, o primeiro passo... Ah, não, o primeiro passo é definir o constraints. Não, nem tem... nem tem. Que ótimo, porque o nosso circuito é um circuito combinacional. Ótimo! A gente não vai trabalhar com circuito sequencial nesse laboratório, tá, pessoal? Então, não se preocupem aí com isso. Então, \"Create Timing Netlist\", tá? Então, a primeira coisa que eu preciso fazer é criar a netlist de análise temporal. Então, dá dois cliques aqui.",
        "video_source": "OAC_2022-03-09.mp4"
    },
    {
        "id": 12,
        "timestamp_start": 5802.99,
        "timestamp_end": 6266.89,
        "slide_description": "Como Engenheiro de Computação Sênior, analiso o slide e o conteúdo anotado da aula de Arquitetura de Computadores para extrair e descrever o material para um sistema de busca semântica (RAG).\n\nO contexto geral é uma aula online (\"Sala de Aula de OAC\" - provavelmente Organização e Arquitetura de Computadores) conduzida pelo \"Prof. Marcus Vinicius Lamar\", com a exibição de uma ferramenta de análise de temporização (Timing Analyzer) e um chat lateral.\n\n**1. Transcrição Fiel de Texto, Título e Código:**\n\n**Título da Janela do Aplicativo:**\n`Timing Analyzer - C:/Users/mvlam/Dropbox/Disciplinas/UnB/OAC/2021-2/Lab2/DECODER7_restored - TopDe`\n\n**Menu Principal do Aplicativo:**\n`File View Netlist Constraints Reports Script Tools Window Help`\n\n**Painel Esquerdo (Opções de Análise e Relatórios):**\n*   **Set Operating Conditions:**\n    *   `Slow 1100mV 85C Model`\n    *   `Slow 1100mV 0C Model`\n    *   `Fast 1100mV 85C Model`\n    *   `Fast 1100mV 0C Model`\n*   **Report (Visualização em Árvore):**\n    *   `Timing Analyzer Summary`\n    *   `Advanced I/O Timing`\n    *   `Fmax Summary`\n    *   `Datasheet Report` (selecionado)\n        *   `Slow 1100mV 85C Model` (selecionado)\n            *   `Propagation Delay` (selecionado)\n            *   `Minimum Propagation Delay`\n        *   `Slow 1100mV 0C Model`\n        *   `Fast 1100mV 85C Model`\n        *   `Fast 1100mV 0C Model`\n*   **Tasks (Visualização em Árvore):**\n    *   `Report Minimum Pulse Width S` (parcialmente visível)\n    *   `Report Max Skew Summary`\n    *   `Report Net Delay Summary`\n    *   `Report Fmax Summary` (selecionado)\n    *   `Report Datasheet` (selecionado)\n    *   **Device Specific:**\n        *   `Report TCCS`\n        *   `Report RSKM`\n        *   `Report DDR`\n        *   `Report Metastability Summary`\n\n**Painel Central (Tabela de Resultados):**\n*   **Título da Tabela:** `Propagation Delay`\n*   **Cabeçalhos da Tabela:** `Input Port`, `Output Port`, `RR`, `RF`, `FR`, `FF`\n*   **Conteúdo da Tabela (linhas visíveis):**\n    *   `1 In[0] Out[0] 1.159 1.169 1.143 1.156`\n    *   `2 In[0] Out[1] 0.958 1.009 0.949 1.033`\n    *   `3 In[0] Out[2] 1.059 1.060`\n    *   `4 In[0] Out[3] 1.017 1.079 1.009 1.104`\n    *   `5 In[0] Out[4] 0.958 1.029`\n    *   `6 In[0] Out[5] 1.087 1.062`\n    *   `7 In[0] Out[6] 1.016 1.092 1.010 1.119`\n    *   `8 In[1] Out[0] 0.839 0.908 0.960 0.953`\n    *   `9 In[1] Out[1] 0.802 0.839 0.788 0.775`\n    *   `10 In[1] Out[2] 0.757 0.844`\n    *   `11 In[1] Out[3] 0.852 0.900 0.838 0.836`\n    *   `12 In[1] Out[4] 0.829 0.781`\n    *   `13 In[1] Out[5] 0.762 0.803 0.883 0.848`\n    *   `14 In[2] Out[0] 0.854 0.916 0.839 0.851`\n    *   `15 In[2] Out[1] 0.776 0.803 0.804 0.812`\n    *   `16 In[2] Out[2] 0.680 0.689`\n    *   `17 In[2] Out[3] 0.694 0.694 0.721 0.703`\n    *   `18 In[2] Out[4] 0.707 0.720 0.727 0.726`\n    *   `19 In[2] Out[5] 0.658 0.656 0.679 0.663`\n    *   `20 In[2] Out[6] 0.656 0.655 0.677 0.658`\n    *   `21 In[3] Out[0] 0.694 0.721 0.711 0.724`\n    *   `22 In[3] Out[1] 1.063 1.136 1.054 1.162`\n    *   `23 In[3] Out[1] 1.076 1.070 1.083 1.069`\n    *   `24 In[3] Out[2] 0.980 1.025 0.972 1.052`\n    *   `25 In[3] Out[3] 1.105 1.110 1.111 1.108`\n    *   `26 In[3] Out[4] 1.046 1.062`\n    *   `27 In[3] Out[5] 0.953 0.997 0.943 1.022`\n    *   `28 In[3] Out[6] 1.096 1.115 1.099 1.110`\n\n**Painel Inferior (Console/Histórico):**\n*   **Texto do Console:**\n    *   `No user constrained clock uncertainty found in the design. Calling \"derive_clock_uncertainty\".`\n    *   `The derive_clock_uncertainty command did not apply clock uncertainty to any clock-to-clock transfers.`\n    *   `report_clock_fmax_summary -panel_name \"Max Summary\" -multi_corner`\n    *   `report_fmax_summary`\n    *   `No fmax paths to report.`\n    *   `report_datasheet -panel_name \"Datasheet Report\" -multi_corner`\n*   **Abas:** `Console`, `History`\n\n**Informações de Contexto no Canto Superior Direito:**\n*   `Search altera.com`\n*   `Universidade de Brasília`\n*   `Departamento de Ciência da Computação`\n*   `CIC0003 - Introdução a Sistemas Computacionais`\n*   `Prof. Marcus Vinicius Lamar`\n\n**Informações do Chat Lateral Esquerdo (Bate-papo público):**\n*   **Mensagens Visíveis (parcial):**\n    *   `mesmo`\n    *   `Eduardo Ferreira Ma... ah, realmente`\n    *   `Eduardo Ferreira Ma... ok`\n    *   `Ualiton Ventura Da ... kkkkkkkkkk ele reconhece o fim por conta da identação`\n    *   `Victor Hugo Rodrig... Sim.`\n    *   `João Alberto Travas... não tem clock`\n    *   `Eduardo Ferreira Ma... credo kk`\n    *   `João Alberto Travas... eita 40min`\n    *   `João Alberto Travas... 3 de boa`\n    *   `Ualiton Ventura Da ... não`\n    *   `João Alberto Travas... não`\n    *   `João Alberto Travas... ok`\n    *   `Eduardo Ferreira Ma... sf`\n\n**2. Descrição de Diagramas e Fluxo de Dados:**\n\nNão há diagramas tradicionais de Datapath, Pipeline ou Hierarquia de Memória visíveis no slide. O conteúdo central é uma **tabela de relatório de temporização**, gerada por um \"Timing Analyzer\".\n\nEsta tabela descreve o **atraso de propagação (Propagation Delay)** de um circuito digital, provavelmente um decodificador (\"DECODER7\") conforme indicado no título do projeto. Cada linha da tabela representa o atraso entre uma porta de entrada (`Input Port`, e.g., `In[0]` a `In[3]`) e uma porta de saída específica (`Output Port`, e.g., `Out[0]` a `Out[6]`).\n\nOs cabeçalhos `RR`, `RF`, `FR`, `FF` indicam os diferentes tipos de atrasos de propagação medidos para cada transição de sinal:\n*   **RR (Rise-to-Rise):** Atraso desde a borda de subida (rise) do sinal de entrada até a borda de subida do sinal de saída.\n*   **RF (Rise-to-Fall):** Atraso desde a borda de subida do sinal de entrada até a borda de descida (fall) do sinal de saída.\n*   **FR (Fall-to-Rise):** Atraso desde a borda de descida do sinal de entrada até a borda de subida do sinal de saída.\n*   **FF (Fall-to-Fall):** Atraso desde a borda de descida do sinal de entrada até a borda de descida do sinal de saída.\n\nOs valores numéricos na tabela (e.g., `1.159`, `1.169`, `1.143`, `1.156`) representam esses atrasos em unidades de tempo (geralmente nanossegundos, conforme padrão para ferramentas de análise de temporização de FPGAs ou ASICs).\n\nO painel esquerdo contextualiza a análise, mostrando que o relatório de atraso de propagação está sendo exibido sob a condição de operação \"Slow 1100mV 85C Model\". Isso significa que os atrasos são simulados sob uma condição de processo de fabricação \"lenta\" (pior caso), com uma tensão de alimentação de 1100mV e temperatura de 85°C. Outras opções de \"Operating Conditions\" (como 0C Model, Fast Model) estariam disponíveis para simular cenários de melhor ou pior caso em diferentes condições ambientais e de fabricação.\n\nO console inferior exibe mensagens importantes da ferramenta, indicando que não foi encontrada incerteza de clock definida pelo usuário (`No user constrained clock uncertainty...`), e que os comandos para gerar relatórios de `fmax` (frequência máxima de operação) e `datasheet` foram executados, mas não há \"fmax paths to report\", o que pode sugerir que a análise se foca em atrasos combinacionais em vez de caminhos síncronos completos ou que a configuração não permitiu a identificação de tais caminhos. A menção \"multi-corner\" em alguns comandos (`report_datasheet`, `report_clock_fmax_summary`) indica que a análise pode considerar múltiplas condições de operação para verificar o pior caso.\n\nEm suma, o slide apresenta uma análise detalhada de temporização de um circuito digital, focando nos atrasos de propagação entre portas de entrada e saída, sob condições de operação específicas. Esta é uma etapa crucial no design de hardware digital para garantir que o circuito opere corretamente dentro das restrições de tempo, especialmente relevante em disciplinas de Arquitetura de Computadores e Projeto de Sistemas Digitais.",
        "transcription": "Ele vai dizer: \"Ok, ok, criou isso aqui\". A princípio, não tem. Ele vai dar o negócio aqui tudo em branco porque não tem. Tá, **Update Timing Netlist**. Isso aqui serve para quando a gente coloca uma **constraint** aqui, que seria o **clock**, tá? Então, **Create Clock**, por exemplo, tá? O nosso nome do **clock** vai ser chamado **clock**, tá, e vai ser de 50 **megahertz**, então 20 **nanossegundos** de período, tá? E aqui eu defino qual é o **target**. O que significa **target**? Ah, qual é o pino do meu projeto que eu vou ligar esse **clock**? Então aqui eu dou um **list** e eu vou escolher: \"Olha, o meu **clock** tem que ser ligado a esse pino aqui de **clock**\", certo? Mas no nosso caso a gente não vai ter **clock**, então deixa assim. E feito. E agora o **Update Timing Netlist**. Tá, então nesse caso aqui, e no caso de vocês, não tem **clock**, então a gente vai simular tudo **combinacional**, tudo assim, então, né? Então a princípio isso não precisaria fazer, tá?\n\nE o que que a gente tem que analisar aqui? Então aqui estão as condições que ele usou para simulação, tá? Então uma simulação lenta de 1.1 **volts**, né, de nível de tensão alta, e 85 graus **Celsius** de temperatura do **chip**. E o que nos interessa são esses dois relatórios aqui, tá? Um ele vai me dar qual é a frequência máxima que eu posso utilizar, mas como o meu circuito é **combinacional** eu não tenho como analisar isso, certo? Se eu tivesse **flip-flops**, **registradores**, aí teria como analisar. Então, o que que a gente tem que analisar? Esse **Report Datasheet** aqui. Então, no **Report Datasheet** ele vai me dar o **Propagation Delay**, ok, que é o atraso do circuito **combinacional**. Já que o nosso circuito é um circuito **combinacional** composto só de portas lógicas, ele vai ter um **TPD**. Qual é o **TPD**?\n\nEntão ele faz as contas considerando todas as entradas para cada uma das saídas. Então, a entrada 0 para todas as saídas, a entrada 1 para todas as saídas, a entrada 2 para todas as saídas, até a última. Então ele analisa tudo: quanto tempo demora da entrada 0 até a saída 0, quanto tempo demora da entrada 0 até a saída 1, e te dá esses valores aqui. Então, o que que significa **RR**, **RF**, **FR** e **FF**? Lá em circuitos lógicos vocês aprenderam que o **TPD** depende se a gente está num nível lógico baixo e vai para alto, ou se a gente está num nível alto e vai para baixo, certo? Que é o **TPD_HL** e **TPD_LH**. Vão lembrar disso? Que bom!\n\nEntão esse aqui ele vai analisar **Rise-to-Rise** (RR) — quer dizer, nível lógico alto e nível lógico alto; **Rise-to-Fall** (RF) — quer dizer, nível lógico alto e nível lógico baixo; **Fall-to-Rise** (FR) — quer dizer, nível lógico baixo e nível lógico alto; e **Fall-to-Fall** (FF) — quer dizer, nível lógico baixo para nível lógico baixo, certo? Então ele te dá todos os tempos possíveis aqui. Qual é o **TPD** do circuito? Então, o **TPD** do circuito é o pior tempo que tiver nessa tabela aqui. Então, como é que a gente analisa isso? Ah, eu posso ordenar essa tabela aqui, ó, pelo **RR**: deu 1.159. Se eu ordenar pelo **RF**: 1.169. Opa, esse aqui é maior! Pelo **FR**: 1.143. Então, 1.169 está ganhando. Ou pelo **FF**: 1.162. Moral da história: o nosso pior caso é esse aqui, certo? Então o atraso de propagação desse nosso circuito vai ser de 1.169 **nanossegundos**. Certo? Então, atraso de 1.169 **nanossegundos**.\n\nEntão, esse **chip** é bem bonzinho, né? Rápido. Vocês se lembram qual era o tempo de atraso? Ah, vocês fizeram um circuito laboratório com o **Digilent Basys 3**, né? Vocês se lembram qual era o tempo de atraso de uma porta lógica lá no **Digilent Basys 3**? Não só para vocês terem uma ideia, assim. Não, isso, 5 **nanossegundos**. Era 4 ou 5 **nanossegundos**, claro. Então, aquilo era modelo. Os autores do **Digilent** modelaram as portas lógicas para dar 4 e 5 **nanossegundos**. Aqui não, aqui é o circuito real. É por causa que tu não conseguia colocar o cursor exatamente em cima da coisa, mas era 5 **nanossegundos**. Era difícil, professor, eu sei que era difícil. Ahã.\n\nEntão esse número aqui é o número real do circuito implementado no **FPGA** que a gente tem, certo? Então 1.169 **nanossegundos**. Então vamos ver aqui o nosso roteiro aqui. Ah, então, no **TimeQuest**, tem esse reloginho. Ele gera e determina esse **timing list**. Em seguida, o relatório **Report Datasheet** e indica os requerimentos temporais, ou seja, o caminho de maior atraso e qual é o **TPD**, o maior tempo de atraso. Bom, então a gente já sabe que o maior tempo de atraso é esse aqui, e qual é o caminho? É da entrada 0 para a saída 0. Esse aqui foi o pior caso. Poderia ter dado outro? Poderia, teria dado qualquer um desses aqui, tá? Mas por coincidência foi a primeira coisa que aconteceu aqui. O segundo pior tempo de atraso, aí tem que verificar, não posso dizer, tá? Mas o pior tempo de atraso é esse e o caminho da entrada do bit 0 da entrada para a saída 0. Entendeu?\n\nEntão, esse aqui é o caminho crítico. Deixa eu ver o que mais. Acho que é só isso. Então essas são as ferramentas que a gente vai utilizar. Então, qual é o trabalhinho de vocês? É fazer exatamente isso que a gente fez aqui: essas análises de requerimentos temporais, ver o diagrama esquemático para simular em forma de onda, e fazer a análise temporal, tá? Só que para um circuito real, tá? Não que o **DECODER7** não seja real, mas para um circuito mais complexo. Tá, aqui a nossa aula de inteiros está projetada. Então, vamos fazer, vamos abrir ela para eu mostrar para vocês. Então eu vou fechar esse projeto. Então, **Close Project**.",
        "video_source": "OAC_2022-03-09.mp4"
    },
    {
        "id": 13,
        "timestamp_start": 6266.89,
        "timestamp_end": 6298.2,
        "slide_description": "Como um Engenheiro de Computação Sênior, analiso o slide da aula de Arquitetura de Computadores (OAC) da Universidade de Brasília (UnB). A tela principal exibe uma sessão de aula online em andamento, com um cronômetro indicando \"104:48\" minutos de duração.\n\n**Conteúdo Visual e Texto Transcrito/Descrito:**\n\n1.  **Interface da Aula Online:**\n    *   **Título da Aula:** \"Sala de Aula de OAC\".\n    *   **URL da Conferência:** `live-idc53.mconf.rnp.br/html5client/join?sessionToken=ruhphnjkmjrbmdhnp4` (elemento da UI, ignorado para busca semântica).\n    *   **Identificação do Palestrante/Professor:** \"Marcus Vinicius Lam...\" (parcialmente visível).\n    *   **Painel Esquerdo - Comunicação:**\n        *   **Seções:** \"MENSAGENS\", \"Perguntas\", \"Bate-papo público\", \"NOTAS\", \"Notas comparti...\", \"USUÁRIOS (19)\".\n        *   **Conteúdo do Bate-papo Público:** As mensagens revelam uma discussão ativa entre os alunos, com referências técnicas a \"5ns\" e \"4.96 ns\" por \"Ualiton Ventura Da...\" e \"Eduardo Ferreira Ma...\", respectivamente, sugerindo tópicos relacionados a atrasos de propagação (delays) ou requisitos de *timing* em projetos de hardware, o que é altamente relevante em Arquitetura de Computadores e design de FPGAs. Outras mensagens são de interação geral como \"credo kk\", \"eita 40min\", \"ok\", \"não\", \"sí\", \"isso\".\n\n2.  **Ambiente de Desenvolvimento Integrado (IDE) - Intel Quartus Prime Lite Edition:**\n    *   **Título da Aplicação:** \"Quartus Prime Lite Edition\".\n    *   **Barra de Menus:** \"File Edit View Project Assignments Processing Tools Window Help\".\n    *   **Seção Principal - Projetos Recentes:**\n        *   Listagem de projetos recentes com seus caminhos de arquivo, todos indicando projetos de `Lab2` de `OAC` da `UnB`:\n            *   `A TopDE.qpf (C:/Users/mvlam/Dropbox/kiko/Disciplinas/UnB/OAC/2021-2/Lab2/DECODER7_restored/TopDE.qpf)`\n            *   `A ALU.qpf (C:/Users/mvlam/Dropbox/kiko/Disciplinas/UnB/OAC/2021-2/Lab2/ALU_restored/ALU.qpf)`\n            *   `A TopDE.qpf (C:/Users/mvlam/Dropbox/kiko/Disciplinas/UnB/OAC/2021-2/Lab2/DECODER7_restored/TopDE.qpf)`\n        *   **Observação:** A presença de \"DECODER7\" (Decoder de 7 bits, presumivelmente) e \"ALU\" (Arithmetic Logic Unit) como nomes de projeto reforça o foco em componentes fundamentais da arquitetura de computadores. O formato `.qpf` indica um arquivo de projeto do Quartus.\n        *   **Botões de Ação:** \"New Project Wizard\", \"Open Project\", \"Restore Archived Project\".\n    *   **Painel Inferior Esquerdo - Tarefas de Compilação (`Tasks`):**\n        *   **Fluxo de Design FPGA (parcialmente visível):**\n            *   `> Compile Design`\n            *   `> Analysis & Synthesis`\n            *   `> Fitter (Place & Route)`\n            *   `> Assembler (Generate programm)`\n            *   `> Timing Analysis`\n            *   `> EDA Netlist Writer`\n            *   `> Edit Settings`\n        *   **Observação:** Esta lista descreve as etapas sequenciais do fluxo de design para FPGAs, desde a síntese do código RTL até a geração do bitstream e análise de desempenho. A \"Timing Analysis\" é uma etapa crítica para verificar se o circuito atende aos requisitos de tempo, o que se alinha com as discussões no chat.\n    *   **Painel Direito - Catálogo IP e Dispositivo (parcialmente visível):**\n        *   **\"IP Catalog\"**: Um recurso para reutilização de blocos de IP (Intellectual Property).\n        *   **\"Device: Family Cyclone V (E/GX/GT/SX/SE/ST)\"**: Indica que o projeto está sendo direcionado para uma FPGA da família Altera Cyclone V, especificando as variantes E, GX, GT, SX, SE, ST.\n        *   **\"Library\"**: Lista de categorias de IP disponíveis:\n            *   `> Basic Functions`\n            *   `> DSP` (Digital Signal Processing)\n            *   `> Interface Protocols`\n            *   `> Memory and memory controllers`\n\n3.  **Explorador de Arquivos do Windows:**\n    *   **Caminho do Diretório:** `> OAC > 2021-2 > Lab2 > DECODER7_restored >` (confirmando o contexto do projeto).\n    *   **Barra de Pesquisa:** \"Pesquisar DECODER7_restored\".\n    *   **Conteúdo do Diretório:**\n        *   `db` (Pasta de arquivos, Data de modificação: 09/03/2022 15:45) - Geralmente contém o banco de dados interno do projeto Quartus.\n        *   `incremental_db` (Pasta de arquivos, Data de modificação: 09/03/2022 15:22) - Banco de dados para compilações incrementais.\n        *   `output_files` (Pasta de arquivos, Data de modificação: 09/03/2022 15:33) - Contém os resultados finais da compilação, como o bitstream para programar a FPGA e relatórios diversos.\n        *   `simulation` (Pasta de arquivos, Data de modificação: 09/03/2022 15:31) - Contém arquivos relacionados à simulação funcional e de temporização do design.\n    *   **Acesso Rápido:** \"UnB\", \"Documentos\", \"Alunos\", \"Downloads\", \"Projeto-FAPD\", \"Pesquisa\", \"Área de Traba\", \"Google Drive\", \"ArquivosC\".\n\n**Análise de Diagramas:**\nNão há diagramas visíveis de datapath, pipeline, ou hierarquia de memória no slide. O conteúdo foca predominantemente na interface e no fluxo de trabalho de uma ferramenta EDA (Intel Quartus Prime Lite Edition) utilizada para o design e implementação de sistemas digitais em FPGAs, especificamente no contexto de um laboratório de Arquitetura de Computadores. A estrutura descrita é a da interface do software e a organização do sistema de arquivos do projeto.\n\n**Conclusão para Sistema RAG:**\nEste slide representa uma aula prática de Arquitetura de Computadores (OAC) focada no design digital usando o Intel Quartus Prime Lite Edition e FPGAs Altera Cyclone V. O conteúdo abrange o gerenciamento de projetos (Decoder e ALU), o fluxo de compilação FPGA (Análise e Síntese, Place & Route, Análise de Timing) e a organização de arquivos do projeto. A interação dos alunos no chat evidencia discussões técnicas sobre desempenho e timing de circuitos digitais. Este material é relevante para buscas sobre: \"projeto FPGA\", \"Intel Quartus Prime\", \"Altera Cyclone V\", \"fluxo de design digital\", \"compilação VHDL/Verilog\", \"timing analysis FPGA\", \"arquitetura de unidade lógica e aritmética (ALU)\", \"projeto de decodificadores\", \"educação em arquitetura de computadores UnB\".",
        "transcription": "Beleza, e vou abrir então Restore Archived Project. Tá aqui: `ALU.qpf`. Abrir. OK. Vamos lá.",
        "video_source": "OAC_2022-03-09.mp4"
    },
    {
        "id": 14,
        "timestamp_start": 6298.2,
        "timestamp_end": 7114.19,
        "slide_description": "O slide analisado apresenta um conjunto de instruções para um laboratório ou projeto da disciplina de Arquitetura de Computadores (OAC), conforme indicado pelo título superior \"Sala de Aula de OAC\" e o nome do arquivo \"OAC_LAB2.docx\". O conteúdo principal detalha tarefas relacionadas à implementação, simulação e análise de uma Unidade Lógico-Aritmética (ULA) de inteiros.\n\nO documento é dividido em seções, sendo a mais proeminente intitulada \"2) (10.0) Unidade Lógico Aritmética de Inteiros\". Uma seção anterior, parcialmente visível, sob o item \"1) f)\", instrui a \"Defina o arquivo TopDE.v como o toplevel, compile, usando o Tools/Programmer sintetize na DE1-SoC e filme-o funcionamento para todos os valores de entrada.\" Este item sugere a integração de um módulo `TopDE.v` em uma placa DE1-SoC e a verificação de seu funcionamento.\n\nAs tarefas detalhadas para a ULA são as seguintes:\n\n*   **2.a) Análise e Visualização (2.0 pontos):** Inicia-se com a abertura do ambiente Quartus Prime e a restauração de um projeto arquivado (`ULA.qar`). Os alunos devem analisar a descrição em Verilog da ULA fornecida, descrever suas funções e elaborar uma tabela de códigos para cada operação implementada. O arquivo `ALU.v` deve ser configurado como o módulo `toplevel`. Após a compilação, o circuito sintetizado deve ser visualizado utilizando o `Tools/Netlist Viewers/RTL viewer`, que permite inspecionar a estrutura lógica gerada.\n\n*   **2.b) Simulação Funcional e Temporal (2.0 pontos):** Exige a modificação dos valores no arquivo de forma de onda (`ULA.vwf`) para realizar simulações funcionais e temporais. O objetivo é verificar cada operação da ULA, comparando os resultados com a simulação RTL. É explicitamente recomendado escolher valores de entrada que sejam tanto \"representativos (comuns)\" quanto \"singulares (overflow, divisão por zero)\" para testar os limites e comportamentos específicos da ULA.\n\n*   **2.c) Análise de Requisitos Físicos (3.0 pontos):** Foca na quantificação dos recursos de hardware utilizados pela implementação da ULA. Os alunos devem indicar os requisitos físicos para a ULA total e para cada operação individualmente, cobrindo:\n    *   i) Número de Elementos Lógicos Adaptativos (ALMs).\n    *   ii) Número de Registradores.\n    *   iii) Quantidade de bits de memória.\n    *   iv) Número de blocos DSP.\n    Além disso, devem comparar a soma dos ALMs de cada operação com o total de ALMs da ULA, explicando eventuais diferenças, e analisar o impacto das funções com maiores circuitos no tamanho geral da ULA. Uma dica técnica crucial é a instrução para \"Defina manualmente o sinal de controle iControl no arquivo ULA.v, pois o Quartus otimiza o projeto retirando as partes não utilizadas\", o que é fundamental para uma análise precisa de cada operação sem interferência da otimização automática.\n\n*   **2.d) Análise de Requisitos Temporais (2.0 pontos):** Utiliza a ferramenta TimeQuest para determinar os requerimentos temporais da ULA (total e por operação). Os aspectos a serem analisados incluem:\n    *   i) O caminho de maior atraso.\n    *   ii) O maior tempo de atraso de propagação (tpd).\n    *   iii) A identificação e análise do impacto das funções que contribuem para os maiores atrasos no tpd.\n\n*   **2.e) Síntese e Verificação em Hardware (1.0 ponto):** Demanda a definição do arquivo `TopDE.v` como o `toplevel` do projeto, sintetizando-o para a placa de desenvolvimento DE1-SoC. A tarefa culmina na gravação de um vídeo que comprove o correto funcionamento do circuito na placa, validando os valores testados na simulação do item `b)`. Isso implica que o `TopDE.v` provavelmente atua como um invólucro (wrapper) que integra a ULA e outros componentes necessários para a interação com a placa DE1-SoC.\n\n*   **2.f) Otimização (1.0 ponto):** A etapa final consiste em avaliar a capacidade de otimização do grupo em relação aos requisitos físicos e/ou temporais da ULA, com a restrição de \"sem retirar nenhuma funcionalidade!\".\n\nEm suma, o conteúdo descreve um conjunto abrangente de tarefas de projeto de hardware digital que envolvem descrição em Verilog, síntese com Quartus Prime, simulação (funcional e temporal), análise de recursos físicos (ALMs, Registradores, Memória, DSP) e temporais (atrasos, tpd) usando TimeQuest, e finalmente, implementação e verificação em hardware real (DE1-SoC). Não há diagramas visuais (como datapath ou pipeline) explicitamente presentes no slide, sendo a informação fornecida em formato textual de instruções técnicas.",
        "transcription": "tá aqui então já tá em `Files`. Então, esse aqui é o nosso arquivo em que a gente vai trabalhar. O `top.de` novamente é para uso da plaquinha, a gente não vai mexer nele. Então, o `decoder_7seg` que é o mesmo que a gente tinha projetado antes, era utilizado aqui pra gente ver os resultados na plaquinha, no display de sete segmentos, também não vai ser utilizado. O `ALU_TB` também a gente não vai utilizar, que é o Test Bench. Então a gente vai utilizar o `ALU.v`, o `parameters.v` e o `ALU.vwf` (forma de onda). Ok, então vamos dar uma olhadinha no `ALU` aqui. Na ULA, então, a primeira coisa que ele faz é incluir esse arquivo de parâmetros, tá? Por que incluir esse arquivo de parâmetros? Porque aqui eu tô usando nomes, por exemplo, `OP_AND`, `OP_OR`, `OP_XOR`, que na realidade são números binários, isso aqui, tá? E onde que tá a definição de qual é o número binário da operação `AND`? Tá? Então tá nesse arquivo de parâmetros, por isso que a gente tem que incluir ele. Abre aqui no arquivo de parâmetros. Tá aqui, ó, essa partezinha inicial aqui, `OP_AND` corresponde a 0. `OP_OR`, 5 bits. Então 00001 é... vim pra cá. Na `OP_XOR` corresponde a esse número. Até o `OP_MUL` ser esse aqui, certo? Então, esse aqui, ao invés da gente trabalhar diretamente com os números, é muito mais fácil a gente trabalhar com esses labels aqui, ok? Então, por isso que a gente precisa desse arquivo de parâmetros, tá? Porque a gente tá usando aqui esses parâmetros. Então, vamos lá, vamos entender o que que a ULA tá fazendo, tá? Então, o módulo `ALU`. Inputs são 5 bits de controle, então, naquela ULA que a gente viu em aula eram 4 bits de controle, aqui a ULA tá mais completa, então ele tem 5 bits de controle. Tenho duas entradas `A` e `B` de 32 bits cada uma, certo? Que são, a princípios, com sinal, tá? E eu tenho como saída os 32 bits aqui, né, do lógico. Então, eu entro com duas palavras de 32 bits, obtendo o resultado de 32 bits, e através desse controle aqui eu escolho o que que é a operação que eu quero fazer. Nossa, Maria! Vamos fazer esse aqui? Nesse caso eu já deveria ter deixado isso pronto, vocês têm que descomentar isso aqui, descomentar... deixa eu pensar aqui, deixa eu ver o roteiro. Roteiro. Eu vou ver o roteiro. ...consegue otimizar. Ok, tá. Então aqui a primeira coisa que está sendo pedido, para o oferecido em aula, \"Analise a definição em Verilog e descreva suas funções e escreva a tabela de seus códigos para cada operação.\" Então, na realidade, isso aqui é simplesmente vocês analisarem essa partezinha aqui e me dizer: qual é o código para eu fazer um `AND`? Qual é o código para fazer um `XOR`? Qual é o código de controle para fazer um `XOR`? Certo? E botar uma tabelinha: \"O `AND` precisa de tal código em binário, certo?\" 5 bits em binário. \"Para o `OR` precisa de tal código. Para o Shift Lógico à Esquerda precisa de tal código. Shift Lógico à Direita de tal código. Para a multiplicação tal código. Para a divisão tal código. Para a divisão sem sinal, tal código\", certo? É para vocês entenderem o que é que vocês têm disponíveis de funções aqui e operações lógicas e aritméticas: soma, subtração, comparação. Então vocês vão analisar esse arquivinho aí e escrever essa tabelinha, ok? \"Defina o arquivo como toplevel, compile e visualize o circuito sintetizado.\" Então, vamos definir esse arquivo `ALU.v` como toplevel, certo? E vou compilar. Vamos ver se isso aqui vai demorar 5 minutos mesmo. Bom, enquanto isso aí compila, vamos seguir aqui analisando o roteiro, ok? Na forma de onda, tem alguns valores que estão definidos. Então, o que eu estou pedindo aqui: \"Modifique esses valores e verifique para cada operação implementada através de simulação.\" Então, vocês vão colocar: \"Eu quero somar 3 com 4, o resultado tem que dar 7. Eu quero subtrair 1 de 2, não, 1 menos 2, o resultado tem que dar menos 1.\" Então, analisar se a ULA está fazendo as coisas certinho, e é interessante escolher valores de entrada que sejam representativos, quer dizer, comuns, e valores que possam dar singularidades, por exemplo, overflow, divisão por zero, para a gente ver o que a ULA faz nesses casos, certo? Como essa aqui é uma ULA de inteiros, divisão por zero até pode ter, e o que ela vai fazer? E overflow a gente sabe que é quando a gente faz o... era o número 0, 1, 1, 1, passou para o número 1, 0, 0, 0. Quer dizer, era um número positivo, passou para ser um número negativo. Então, essa aqui é a análise da forma de onda. Para o \"C\": \"Indique os requerimentos físicos da implementação da ULA total e para cada operação separadamente.\" Então, como que vocês vão fazer isso? Para obter o número de ALMs, número de registradores, quantidade de bits, número de DSPs. Indique quais são, quais são e analise o impacto das funções com maior circuito no tamanho da ULA. Quer dizer, a ULA está fazendo várias operações. Qual dessas operações é que gerou o maior circuito que está impactando no custo da ULA? Aquele que deu o circuito maior. A partir daqui, da análise de cada um, é que a gente vai verificar como é que a gente faz a análise de cada um. Então, aqui está a dica de como é que se faz isso. O Quartus, como a gente viu, ele é esperto. Se tem alguma coisa que dá para otimizar, ele otimiza. Se tem coisas que não estão sendo utilizadas, ele simplesmente capa fora, então ele é bem esperto. Então, se eu definir o `iControl` aqui é para a simulação em forma de onda. Mas se eu definir o `iControl` aqui é para a simulação em forma de onda. Então, se eu definir o `iControl`, o `iControl` aqui, quer dizer, descomentando essa linha aqui e comentando essa aqui, o que a gente vai estar fazendo? Eu vou estar definindo o `iControl`, por exemplo, conforme esse exemplo aqui, como sendo a operação de adição. Quer dizer, a minha ULA não tem mais essa entrada `iControl`. Internamente está definindo o `iControl` como operação de adição. Ao sintetizar o Quartus não vai sintetizar a ULA. O Quartus não vai sintetizar a ULA. Ele vai sintetizar só a operação de adição, porque ele está vendo que o `iControl` é uma constante que não muda. Então, ele não sintetiza nada a não ser essa partezinha aqui. E assim a gente consegue analisar o peso de cada uma dessas instruções, quer dizer, cada uma dessas operações. Qual é a maior operação? Qual é a menor? Qual é a mais rápida? Quando a gente faz essa definição aqui interna, a definição do módulo da ULA, não deixando como uma entrada. Se eu deixar como uma entrada, o Quartus não vai saber o que tem aqui, já que é uma entrada. Mas se eu definir ela no corpo do procedimento, o Quartus vai saber. O `iControl` está fixo em `OP_ADD`. Ele vai sintetizar só o `OP_ADD`. Entenderam isso, pessoal? Entenderam isso, pessoal? Certo? Beleza. Então, é assim que a gente vai fazer. Isso aqui está escrito aqui: \"Defina manualmente o sinal de controle `iControl` no arquivo `ULA.v`, pois o Quartus otimiza o projeto retirando as partes não utilizadas.\" Ok, na letra D: \"Usando o TimeQuest, indique os requerimentos temporais da ULA total e para cada operação separadamente.\" Então, vocês vão fazer esse aqui também para a ULA total, quer dizer, deixando o `iControl` lá como uma entrada mesmo. Esse aqui também, deixando o `iControl` lá como uma entrada mesmo. E depois para cada operação. Então, eu aconselho a vocês fazerem da ULA total, mede os requisitos físicos e mede os requisitos temporais. No caso, caminho de maior atraso, tempo de maior atraso, e indique quais são os impactos das funções mais demoradas no TPD. Quer dizer, qual é a operação mais demorada? É soma, subtração, `AND`, `OR`, certo? Então, cada vez que vocês definirem o `iControl`, já façam, compilem, vejam quais são os requisitos, os requerimentos físicos, e façam a simulação no TimeQuest para ver os requerimentos temporais para cada operação, certo? E por último, \"Verificar o quanto o seu grupo consegue otimizar essa ULA em termos de requerimentos físicos e/ou temporais, sem retirar nenhuma funcionalidade!\" Quer dizer, vocês analisando o arquivo Verilog, será que vocês conseguem tentar diminuir essa ULA para que ela fique mais eficiente? Certo? Quero sugestões. Aqui tem uma otimização que vocês analisando fica claro, dá para fazer. Eu quero perguntar qual é essa aí? Ok, acho que acabou, 100% acabou. Só vamos ver o circuito aqui então para terminar. O `ALU`. Então, `RTL Viewer`. Qual foi o circuito da ULA? Que circuitinho da ULA? Não dá nem para ver. Então, vamos dar um zoom. Então, notem que a gente tem aqui as entradas A e B de 32 bits, várias portas lógicas aqui. Aqui a gente tem somador, aqui a gente tem subtrator. Aqui a gente tem divisores, módulos multiplicadores. Por exemplo, eu quero ver como é que é uma multiplicação, como é que ela faz uma multiplicação. Daí você clica aqui, ele não mostra nada. Quer dizer, está usando o multiplicador que existe no FPGA. Daí eu quero ver como é que é feita a divisão. Eu clico aqui, ele não mostra nada. Quer dizer, isso aí é quase um segredo industrial, como que é feito o circuito da divisão, certo? E depois ele coloca aqui na saída através de multiplexadores. Então está aqui o resultado. É um circuito bem grande, mas que no fundo é uma seleção de quais operações ele vai colocar na saída, tal qual a gente... a gente não projetou ainda, não, certo? Então esse aqui é o circuitinho. Ok, pessoal, responderam o testinho? Antes que eu me esqueça, tá? Hoje tem testinho. Vocês podem responder até às 4h10. Respondam lá o... a presença pelo FAPETI também, tirando a fotinho. Respondam lá rapidão. E essa aí é só até às 4h. O FAPETI fecha às 4h. Já o testinho não, pode ficar até às 4h10. Difícil? Bom, ok, então encerramos por aqui a aula, tá? Então, eu vou apagar as gravações. Então, eu vou parar a gravação aqui.",
        "video_source": "OAC_2022-03-09.mp4"
    },
    {
        "id": 15,
        "timestamp_start": 7114.19,
        "timestamp_end": 7118.62,
        "slide_description": "A imagem exibe uma tela de conferência web de uma aula de Arquitetura de Computadores, ministrada pelo Professor Marcus Vinicius Lamar, da Universidade de Brasília, Departamento de Ciência da Computação. O conteúdo principal da aula visível é a representação gráfica de um design de hardware digital, provavelmente uma Unidade Lógica Aritmética (ALU), apresentada em um ambiente de desenvolvimento e visualização de RTL (Register-Transfer Level), similar ao Quartus Prime da Intel.\n\nNo canto superior direito, há informações sobre a origem da aula:\n*   **Universidade de Brasília**\n*   **Departamento de Ciência da Computação**\n*   **Prof. Marcus Vinicius Lamar**\n\nNo painel esquerdo da ferramenta de design, parcialmente visível, encontra-se o \"Netlist Navigator\", que mostra a hierarquia do projeto:\n*   A instância principal identificada é **ALU:1**.\n*   Dentro de ALU:1, categorias como **Primitives** e **Logics** são listadas, indicando componentes básicos do circuito.\n*   A categoria **Operators** detalha as operações implementadas na ALU, incluindo: **Add0**, **Add1**, **Div0**, **Div1** e **LessThan0**. Isso sugere que a ALU é capaz de realizar operações de adição, divisão e comparação (menor que).\n*   Ainda no Netlist Navigator, uma série de multiplexadores é listada, de **Mux15** até **Mux28**, indicando que esses componentes são amplamente utilizados para selecionar dados e controlar o fluxo de informações dentro da ALU, uma prática comum em arquiteturas de UCs.\n\nO diagrama esquemático, embora parcialmente obscurecido por uma caixa de diálogo, mostra uma série de linhas paralelas, que representam barramentos de dados multi-bit, e blocos funcionais interconectados. Esses blocos são rotulados com identificadores como **oResult~58**, **oResult~27**, **oResult~59**, **oResult~91**, **oResult~92**, **oResult~93**, **oResult~30**, **oResult~62** e **oResult~31**. Esses rótulos são típicos de nomes gerados por ferramentas de síntese para saídas de portas lógicas ou subcircuitos intermediários dentro de um netlist. O fluxo de dados aparente é da esquerda para a direita, através desses blocos, indicando a propagação de sinais e o processamento lógico. A presença desses operadores e multiplexadores, juntamente com o diagrama esquemático, reforça que a aula está abordando a implementação e a arquitetura interna de uma Unidade Lógica Aritmética em nível de hardware.\n\nElementos de interface do usuário, como o chat lateral e a caixa de diálogo \"Pausar gravação\" (que contém o texto \"Tem certeza de que deseja pausar a gravação? Você pode retomar a qualquer momento pressionando o botão de gravação novamente.\" e os botões \"Sim\" e \"Não\"), são ignorados por não fazerem parte do conteúdo técnico da aula.",
        "transcription": "E parar a gravação aqui.",
        "video_source": "OAC_2022-03-09.mp4"
    }
]