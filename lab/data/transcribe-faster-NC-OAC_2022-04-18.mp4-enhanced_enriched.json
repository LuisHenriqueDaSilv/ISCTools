[
    {
        "id": 1,
        "timestamp_start": 2.22,
        "timestamp_end": 55.22,
        "slide_description": "Como Engenheiro de Computa√ß√£o S√™nior, analiso o slide da aula de Arquitetura de Computadores. O conte√∫do principal exibido √© um documento do Microsoft Word, presumivelmente o plano de ensino ou cronograma da disciplina \"OAC\" (Arquitetura de Computadores), intitulado \"OAC_A_Plano_2021-2_v0.docx\". N√£o h√° diagramas vis√≠veis de arquitetura (como Datapath, Pipeline ou Hierarquia de Mem√≥ria em formato gr√°fico) para descrever a estrutura ou fluxo de dados; em vez disso, os t√≥picos listados referem-se a esses conceitos.\n\nA transcri√ß√£o do conte√∫do t√©cnico e informativo √© a seguinte:\n\n**Documento \"OAC_A_Plano_2021-2_v0.docx\":**\n\nO documento apresenta uma tabela detalhando o progresso da disciplina semana a semana, incluindo laborat√≥rios, provas e t√≥picos conceituais. As colunas vis√≠veis incluem um n√∫mero sequencial, duas colunas de datas (possivelmente para aulas te√≥ricas e pr√°ticas ou diferentes turmas), e duas colunas de descri√ß√£o de conte√∫do.\n\n**Conte√∫do da Tabela:**\n\n*   **Linha 7 (Semana 7/3 - 9/3):**\n    *   `Lab 1B: Software - Compilador C`\n    *   `Lab 2: Hardware - Verilog - ULA (T7)`\n    *   *(Indica introdu√ß√£o ao desenvolvimento de software de baixo n√≠vel (compiladores C) e hardware description language (Verilog para Unidade L√≥gica Aritm√©tica - ULA).)*\n*   **Linha 8 (Semana 14/3 - 16/3):**\n    *   `1¬™ Prova (P1)`\n    *   `12) Processador Uniciclo: Unidade Operativa (C.4) (T8)`\n    *   *(Aponta para a primeira avalia√ß√£o e o estudo da Unidade Operativa (Datapath) de um processador uniciclo, com refer√™ncia ao Cap√≠tulo 4 (C.4) e Tarefa 8 (T8).)*\n*   **Linha 9 (Semana 21/3 - 23/3):**\n    *   `13) Processador Uniciclo: Unidade de Controle (C.4) (L1)`\n    *   `Lab 3: Processador Uniciclo(T9) (L2)`\n    *   *(Foca na Unidade de Controle de um processador uniciclo, tamb√©m no Cap√≠tulo 4, com Laborat√≥rio 3 (L2) e Tarefa 9 (T9) possivelmente para implementa√ß√£o ou an√°lise do processador uniciclo completo.)*\n*   **Linha 10 (Semana 28/3 - 30/3):**\n    *   `14) Processador Multiciclo: Unidade Operativa (C.4)`\n    *   `15) Processador Multiciclo: Unidade de Controle (C.4) (T10)`\n    *   *(Transi√ß√£o para processadores multiciclo, cobrindo tanto a Unidade Operativa quanto a Unidade de Controle, ambas no Cap√≠tulo 4, com a Tarefa 10 (T10).)*\n*   **Linha 11 (Semana 4/4 - 6/4):**\n    *   `Lab 4: Processador Multiciclo`\n    *   `16) Processador Pipeline: Conceitos (C.4) (T11)`\n    *   *(Laborat√≥rio dedicado ao processador multiciclo e introdu√ß√£o aos conceitos de Pipeline, no Cap√≠tulo 4 e Tarefa 11 (T11).)*\n*   **Linha 12 (Semana 11/4 - 13/4):**\n    *   `17) Pipeline: Unidade Operativa e Controle (C.4)`\n    *   `Lab 5: Processador Pipeline(T12) (L3)`\n    *   *(Aprofundamento no design de processadores pipeline, abordando a Unidade Operativa e de Controle espec√≠ficas para pipeline, no Cap√≠tulo 4, com o Laborat√≥rio 5 (L3) e Tarefa 12 (T12).)*\n*   **Linha 13 (Semana 18/4 - 20/4):**\n    *   `18) Exce√ß√£o e Interrup√ß√£o (C.4)`\n    *   `19) Mem√≥ria: Hierarquia (C.5) (T13) (L4)`\n    *   *(T√≥picos de Exce√ß√£o e Interrup√ß√£o no Cap√≠tulo 4, e in√≠cio da discuss√£o sobre Hierarquia de Mem√≥ria, no Cap√≠tulo 5, com Tarefa 13 (T13) e Laborat√≥rio 4 (L4, *possivelmente uma renumera√ß√£o ou refer√™ncia a um laborat√≥rio anterior se a lista de Labs for cont√≠nua, ou um erro de digita√ß√£o no material original*).)*\n*   **Linha 14 (Semana 25/4 - 27/4):**\n    *   `19.1) Mem√≥ria: Cache (C.5)`\n    *   `2¬™ Prova (P2) (T14) (L5)`\n    *   *(Detalhamento da mem√≥ria Cache, como parte da hierarquia de mem√≥ria no Cap√≠tulo 5, seguido da segunda avalia√ß√£o (P2), Tarefa 14 (T14) e Laborat√≥rio 5 (L5).)*\n*   **Linha 15 (Semana 2/5 - 4/5):**\n    *   `Prova Substitutiva`\n    *   `Apresenta√ß√£o dos Projetos (Pr) (T15)`\n    *   *(Previs√£o para uma prova substitutiva e a apresenta√ß√£o de projetos finais, associada √† Tarefa 15 (T15).)*\n\n**Se√ß√£o \"Avalia√ß√£o\" (parcialmente vis√≠vel abaixo da tabela):**\n\n*   `P1: 1¬™ Prova: 14/03/2022`\n*   `P2: 2¬™ Prova: 27/04/2022`\n\n**Elementos Adicionais Vis√≠veis na Tela:**\n\n*   **T√≠tulo da Janela do Navegador:** \"Confer√™nciaWeb - Sala de Au...\"\n*   **URL da Sess√£o:** `live-aws027.mconf.rnp.br/html5client/join?sessionToken=lw7bu6bgnzcxqdgqz`\n*   **T√≠tulo da Sala de Aula:** \"Sala de Aula de OAC\"\n*   **Cron√¥metro da Grava√ß√£o/Transmiss√£o:** `00:36`\n*   **Painel Lateral \"Confer√™nciaWeb\":**\n    *   Mensagens de boas-vindas e informa√ß√µes sobre a grava√ß√£o e a plataforma.\n    *   Lista de \"USU√ÅRIOS (5)\", incluindo \"Marcus Vinicius Lam... (Voc√™)\", \"Luiz Carlos Da Sil...\", \"Eduardo Ferreira ...\", \"Maycon Vinnycus...\", \"Victor Hugo Rodri...\".\n\nEm resumo, o slide documenta o plano de estudos detalhado de uma disciplina de Arquitetura de Computadores, cobrindo t√≥picos fundamentais como compiladores, linguagens de descri√ß√£o de hardware (Verilog), projeto de processadores (uniciclo, multiciclo, pipeline), tratamento de exce√ß√µes/interrup√ß√µes e hierarquia de mem√≥ria, incluindo cache. A agenda inclui laborat√≥rios pr√°ticos e avalia√ß√µes regulares, demonstrando uma abordagem te√≥rico-pr√°tica na forma√ß√£o em Arquitetura de Computadores.",
        "transcription": "Caraca, hoje √© um recorte. Tr√™s alunos. √ìtimo. Ent√£o, vamos l√°. Vamos l√° pra mais uma aulinha de ISC com tr√™s telespectadores. ISC? √â OAC isso aqui. Meu Deus do c√©u. Ent√£o, mais uma aulinha de OAC. Hoje √© dia 18 de abril, n√≥s estamos aqui. Exce√ß√£o e interrup√ß√£o, que n√≥s j√° come√ßamos a ver na aula passada. Ent√£o, essa aula vai ser mais leve. E da√≠ eu posso me aprofundar um pouco mais do que no semestre passado. Ent√£o, isso vai ser legal. Depois, n√≥s temos duas aulas de mem√≥ria cache. E acabou o semestre. Segunda prova, prova substitutiva e apresenta√ß√£o dos projetos. Certo? Ent√£o, n√≥s estamos nos √∫ltimos cem metros do curso. Ent√£o, vamos ver o que n√≥s temos pra hoje.",
        "video_source": "OAC_2022-04-18.mp4"
    },
    {
        "id": 2,
        "timestamp_start": 55.22,
        "timestamp_end": 66.13,
        "slide_description": "Como Engenheiro de Computa√ß√£o S√™nior, procedo √† an√°lise do slide e conte√∫do anotado da aula de Arquitetura de Computadores para extra√ß√£o de informa√ß√µes visuais para um sistema de busca sem√¢ntica (RAG).\n\n**Conte√∫do Visual Principal (Tela de Apresenta√ß√£o):**\nA √°rea central de visualiza√ß√£o est√° completamente vazia e exibe uma tela escura, indicando que nenhum material did√°tico (slides, diagramas, c√≥digo-fonte ou qualquer outra m√≠dia visual) est√° sendo exibido no momento.\n\nNo topo desta √°rea, o t√≠tulo da sess√£o √© claramente vis√≠vel como:\n*   **\"Sala de Aula de OAC\"** (Provavelmente \"Organiza√ß√£o e Arquitetura de Computadores\").\n\nH√° um indicador de grava√ß√£o ativo com o tempo decorrido:\n*   **\"01:04\"** (Um minuto e quatro segundos de grava√ß√£o).\n\nUm r√≥tulo no canto superior esquerdo da tela principal mostra um participante, indicando poss√≠vel foco ou apresenta√ß√£o:\n*   **\"Marcus Vinicius Lam...\"**\n\n**Conte√∫do Textual e Interativo (Barra Lateral Esquerda):**\nA barra lateral esquerda cont√©m informa√ß√µes sobre a plataforma, mensagens e participantes.\n\n1.  **T√≠tulo da Plataforma:** \"Confer√™nciaWeb\"\n2.  **Se√ß√£o \"MENSAGENS\":**\n    *   \"Perguntas\"\n    *   \"Bate-papo p√∫blico\"\n3.  **Se√ß√£o \"NOTAS\":**\n    *   \"Notas compartilh...\" (Notas compartilhadas)\n4.  **Se√ß√£o \"USU√ÅRIOS (6)\":** (Indica 6 participantes na sala)\n    *   \"Marcus Vini... (Voc√™)\" - (Status: microfone ativo, c√¢mera ativa, compartilhando tela)\n    *   \"Luiz Carlos Da Sil...\"\n    *   \"Eduardo Ferreira ...\"\n    *   \"Maycon Vinnycus...\"\n    *   \"Michel Luis Duwe\"\n    *   \"Victor Hugo Rodri...\"\n\n**Conte√∫do do Bate-papo P√∫blico:**\nO painel de bate-papo p√∫blico exibe as seguintes mensagens informativas:\n*   \"Bem vindos √† sala de aula de OAC!\"\n*   \"Esta sess√£o est√° sendo gravada.\"\n*   \"Para mais informa√ß√µes, clique aqui.\" (O texto \"clique aqui\" √© um hiperlink.)\n*   \"Novo na plataforma? Experimente o tour!\" (O texto \"o tour\" √© um hiperlink.)\n\n**Aus√™ncia de Diagramas ou C√≥digo:**\nN√£o h√° nenhum diagrama de *Datapath*, *Pipeline*, *Hierarquia de Mem√≥ria*, ou qualquer trecho de c√≥digo (Assembly, C, Verilog) vis√≠vel no conte√∫do principal da tela. A apresenta√ß√£o est√° focada, neste momento, na intera√ß√£o via chat e na participa√ß√£o dos usu√°rios, sem conte√∫do visual de aula sendo projetado.\n\n**Sum√°rio para RAG:**\nA aula de Arquitetura de Computadores (OAC) est√° sendo gravada e tem uma dura√ß√£o atual de 1 minuto e 4 segundos. O palestrante ou apresentador identificado √© Marcus Vinicius. Atualmente, a tela de apresenta√ß√£o est√° em branco, sem exibi√ß√£o de slides, diagramas t√©cnicos (Datapath, Pipeline, Hierarquia de Mem√≥ria) ou c√≥digo-fonte (Assembly, C, Verilog). A sess√£o utiliza a plataforma \"Confer√™nciaWeb\" e conta com 6 usu√°rios. O bate-papo p√∫blico exibe mensagens de boas-vindas, um aviso sobre a grava√ß√£o e links para informa√ß√µes adicionais e um tour da plataforma.",
        "transcription": "Ent√£o, exce√ß√µes e interrup√ß√µes.",
        "video_source": "OAC_2022-04-18.mp4"
    },
    {
        "id": 3,
        "timestamp_start": 66.13,
        "timestamp_end": 1097.2,
        "slide_description": "Este slide, proveniente de uma aula de Arquitetura de Computadores, especificamente da disciplina CIC0099 ‚Äì Organiza√ß√£o e Arquitetura de Computadores da Universidade de Bras√≠lia, ministrada pelo Prof. Marcus Vinicius Lamar, aborda o tema \"Opera√ß√µes de Entrada e Sa√≠da\" com foco no m√©todo de *polling*.\n\nO slide apresenta dois exemplos de implementa√ß√£o de *polling*: um para a arquitetura x86 e outro para RISC-V.\n\n1.  **Exemplo de Polling no x86**:\n    Este segmento demonstra como um dispositivo de E/S pode ser interrogado continuamente para verificar seu estado antes de ler dados. O c√≥digo Assembly x86 √© apresentado da seguinte forma:\n    ```assembly\n    WAIT:   in AL, 1        # l√™ estado do dispositivo (porta 1)\n            cmp AL, READY   # compara AL com valor READY\n                            # seta Z=(AL == READY)\n            jnz WAIT        # se Z‚â†1 repete\n            in AX, 2        # sen√£o l√™ dado (porta 2) para AX\n    ```\n    A rotina `WAIT` inicia lendo o estado do dispositivo da porta 1 para o registrador `AL` (usando a instru√ß√£o `in`). Em seguida, compara o valor em `AL` com um valor `READY` predefinido (usando `cmp`). A instru√ß√£o `cmp` afeta os flags, em particular o flag Zero (Z), que √© setado se `AL` for igual a `READY`. A instru√ß√£o `jnz WAIT` (jump if not zero) cria um loop, fazendo com que o processador repita a leitura e compara√ß√£o do estado do dispositivo enquanto este n√£o estiver pronto (ou seja, enquanto `Z` for diferente de 1). Uma vez que o dispositivo esteja pronto (`Z=1`), o loop √© encerrado, e a instru√ß√£o `in AX, 2` √© executada para ler os dados da porta 2 para o registrador `AX`.\n\n2.  **Exemplo de Polling no RISC-V**:\n    Este segmento ilustra a mesma l√≥gica de *polling*, mas adaptada para a arquitetura RISC-V. O c√≥digo pseudo-assembly/assembly RISC-V, com defini√ß√µes de constantes e se√ß√µes de texto, √© mostrado como:\n    ```assembly\n    .eqv MASK 0x001\n    .eqv STATUS 0x000\n    .eqv DATA 0x004\n    .text\n    WAIT:   lw t0, STATUS(s0)   # l√™ estado do dispositivo s0\n            andi t1, t0, MASK   # Isola o bit status por MASK\n            beq t1, zero, WAIT  # se n√£o est√° pronto repete\n            lw s1, DATA(s0)     # sen√£o l√™ o dado para s1\n    ```\n    Primeiro, s√£o definidas tr√™s constantes simb√≥licas: `MASK` com valor `0x001`, `STATUS` com `0x000` e `DATA` com `0x004`, provavelmente representando endere√ßos ou offsets de registradores de E/S. A rotina `WAIT` come√ßa com `lw t0, STATUS(s0)`, que carrega o estado do dispositivo (provavelmente de um endere√ßo base em `s0` mais o offset `STATUS`) para o registrador tempor√°rio `t0`. Em seguida, `andi t1, t0, MASK` executa uma opera√ß√£o AND bit a bit entre `t0` e `MASK` para isolar o bit de status relevante no registrador `t1`. A instru√ß√£o `beq t1, zero, WAIT` (branch if equal) cria o loop de *polling*, repetindo a rotina `WAIT` enquanto o bit de status isolado em `t1` for zero (indicando que o dispositivo n√£o est√° pronto). Uma vez que `t1` n√£o seja zero (dispositivo pronto), o fluxo de execu√ß√£o continua para `lw s1, DATA(s0)`, que carrega os dados do dispositivo (do endere√ßo base em `s0` mais o offset `DATA`) para o registrador `s1`.\n\nO slide n√£o cont√©m diagramas de datapath, pipeline ou hierarquia de mem√≥ria, focando exclusivamente na apresenta√ß√£o e compara√ß√£o de exemplos de c√≥digo Assembly para o mecanismo de *polling* em diferentes arquiteturas.",
        "transcription": "Ent√£o, a gente viu o que √© uma exce√ß√£o. S√≥ lembrando, exce√ß√µes s√£o eventos inesperados internos ao processador. E interrup√ß√µes s√£o eventos gerados externamente que o processador tem que atender. Pra tratar exce√ß√µes e interrup√ß√µes, eu preciso de tr√™s coisas. N√£o, foi no semestre passado, acho, Lu√≠s, que me passaram essa imagem a√≠. Eu li e botei a√≠. Ent√£o, para tratamento dessas exce√ß√µes e interrup√ß√µes, eu preciso de tr√™s coisas. Conhecer o fato que gerou a exce√ß√£o e interrup√ß√£o. Conhecer o endere√ßo da instru√ß√£o onde ocorreu a exce√ß√£o e interrup√ß√£o. E executar uma rotina capaz de acessar os recursos que n√£o podem ser acess√≠veis ao usu√°rio. Porque ele vai entrar num modo de opera√ß√£o mais privilegiado para poder acessar, tratar as exce√ß√µes e interrup√ß√µes. Ent√£o, a gente viu como √© que acontece o tratamento. Registrador de causa. Interrup√ß√£o vetorizada. O RISC-V tem tr√™s modos, sendo o User Mode n√£o privilegiado, e os outros dois s√£o privilegiados. E cada um deles tem registradores espec√≠ficos, de utiliza√ß√£o espec√≠fica. Aqui est√° o banco de registradores CSR. S√£o 4.096 registradores. Ent√£o, geralmente, esse banco de registradores n√£o √© implementado como flip-flops, como s√£o os registradores originais, mas s√£o implementados como mem√≥rias SRAM para criar um acesso mais r√°pido, tipo aquele L1. Por qu√™? Porque esse aqui n√£o √© continuamente que o processador acessa isso aqui, os registradores de controle de status. Ent√£o, aqui est√£o esses, os principais que n√≥s vamos precisar. E o *status*, o User Status Register, que indica qual √© o status que ele est√°. O Interrupt Enabled (IE), quer dizer, √© um bit/campo que tu habilita ou n√£o determinadas interrup√ß√µes, certo? Ent√£o, tu p√µe 1 e tu habilita. Tu p√µe 0 e n√£o habilita. O MTVEC, que √© o Trap Handler Base Address. Quer dizer, qual √© o endere√ßo da rotina de tratamento de exce√ß√£o. Ent√£o, o MTVEC. E o Mscratch, √© um registrador a mais para o que a rotina de tratamento de exce√ß√£o possa usar. Ent√£o, ele tem esse aqui, esse registrador aqui, como registrador gen√©rico a mais. O MEPC, que armazena o Exception Program Counter. Quer dizer, qual √© o endere√ßo da instru√ß√£o que aconteceu a exce√ß√£o, n√©? E o MCAUSE, que indica qual √© a causa da exce√ß√£o/interrup√ß√£o, n√©? E o MTVAL, certo? Que ele retorna um valor que √© √∫til para a rotina de tratamento de exce√ß√£o. Por exemplo, se for uma exce√ß√£o de endere√ßo inv√°lido, ele retorna esse endere√ßo inv√°lido. Se for uma instru√ß√£o inv√°lida, ele retorna essa instru√ß√£o que foi inv√°lida. Algo que possibilite √† rotina de tratamento de exce√ß√£o mostrar qual foi o erro. Ah, o erro aconteceu em tal endere√ßo. Ah, o erro aconteceu porque eu li essa instru√ß√£o aqui que eu n√£o conhe√ßo. Certo? E o MIP, que √© o Interrupt Pending. Porque se v√°rias exce√ß√µes (isso aqui √© para interrup√ß√µes), se v√°rias interrup√ß√µes acontecem, pode ser, por exemplo, tem tr√™s interrup√ß√µes no processador. Ele vai ter que ver qual √© a mais privilegiada, n√©? E come√ßar a executar ela. As outras ficam como pendentes. Quando ele acabar de executar o tratamento dessa, a√≠ ele vai para o tratamento dessa, e a√≠ ele vai para o tratamento dessa. Ent√£o ele tem que saber quais s√£o as interrup√ß√µes que est√£o pendentes. OK? Ent√£o esses aqui s√£o os principais, fora os que voc√™ j√° conhece: o mcycle, o mtime e o mhartid. Pronto. Isso aqui s√£o as instru√ß√µes para ler e escrever nos registradores CSR, n√©? Foi permitido. As causas de... Ah n√£o! Voc√™s est√£o ouvindo isso, n√©? N√£o. N√£o, que bom. Meu gerador de ru√≠do aqui est√° muito bom. Porque come√ßaram a furar a parede aqui. Como as paredes aqui s√£o de concreto, tem que ser uma brincadeira para furar a parede. Mas vamos l√°. Ent√£o o registrador de causa. O que que tem que ter? Se for uma interrup√ß√£o, tem que dizer aqui qual √© a interrup√ß√£o, t√°? Se for o registrador de causa, esses aqui s√£o os c√≥digos, n√©, das exce√ß√µes que o RISC-V suporta. Ent√£o se o primeiro bit da causa for 0, √© uma exce√ß√£o. Se o primeiro bit da causa for 1, √© uma interrup√ß√£o. Certo? Depois v√™m esses endere√ßos, quer dizer, esses c√≥digos. A√≠ isso √© o que est√° armazenado dentro do registrador de causa, t√°? Muito bem. Como √© feita a defini√ß√£o do endere√ßo do exception handler, da rotina de tratamento de exce√ß√£o? Meu Deus do c√©u. Se for a interrup√ß√£o por registrador de causa, o registrador base, quer dizer, o endere√ßo base, √© esse aqui. Quer dizer, o endere√ßo que estiver no MTVEC. Por exemplo, esse X aqui pode ser M-Mode, n√©? MTVEC. Os 30 bits mais significativos, concatenado com dois zeros. Ent√£o vai ser nesse endere√ßo aqui. Ent√£o, quem define o endere√ßo onde est√° localizado o exception handler √© o MTVEC, t√°? E se for interrup√ß√£o vetorizada, o MTVEC vai conter, ent√£o, essa instru√ß√£o de trap handler base. Nessa que √© o endere√ßo da instru√ß√£o mesmo. Vai ser dado com esse endere√ßo aqui, t√°? Base mais quatro. Ent√£o, isso te d√° um endere√ßamento a um vetor. Op√ß√µes de entrada e sa√≠da, voc√™s j√° conhecem: por polling e por interrup√ß√£o, n√©? Polling: o software fica o tempo todo verificando se aquele dispositivo quer mandar uma mensagem. E por interrup√ß√£o, n√©? Nesse caso, o dispositivo notifica o processador. Da√≠ a gente entende que tem tamb√©m a DMA, n√©? Que tira da CPU a tarefa de ficar lendo de um dispositivo e escrevendo na mem√≥ria, lendo do dispositivo e escrevendo na mem√≥ria. A√≠ a CPU simplesmente programa o DMA. E o DMA faz, ent√£o, essa tarefa de ler do dispositivo e escrever na mem√≥ria, ler do dispositivo e escrever na mem√≥ria, e deixando a CPU livre para fazer outras coisas. Eu adoro esse barulho. Agora deu para ouvir. Mas, se voc√™s conseguem ouvir, imagina o quanto de barulho ele est√° sendo aqui agora. Mas, vamos... Aqui d√° um exemplo de polling em x86. Mas, como a gente viu, a ideia √© x86? √â s√≥ um exemplo aqui. Voc√™s podem, a partir dessas instru√ß√µes, inferir o que ele fica fazendo. E aqui d√° um exemplo de polling do RISC-V, n√©? Ent√£o seria essa partezinha aqui. Ent√£o, l√™ do endere√ßo `s0` mais o offset `STATUS`. Nesse caso, `STATUS` est√° definido como 0. Ent√£o, o endere√ßo √© `s0`. Mascara o valor 1, que √© o bit 0. Ent√£o, ele vai fazer uma m√°scara, por exemplo, com esse n√∫mero aqui, 0, 0, 1. Ent√£o, eu estou pegando o primeiro bit, o bit 0. Eu quero somente pegar o valor desse bit, os outros bits v√£o ser 0, j√° que eu estou aplicando um AND. Colocou o AND, se tem 1. E aqui eu verifico se esse bit 0 √© igual a 0. Se for igual a 0, √© porque o dispositivo n√£o quer enviar nada. Ent√£o, ele vai para o `WAIT` e fica aqui esperando, at√© o dispositivo querer mandar alguma coisa. Quando ele quer mandar alguma coisa, esse bit aqui n√£o vai ser 0, vai ser 1. Ele, ent√£o, l√™ do endere√ßo `s0` mais `DATA`, onde `DATA` √© esse offset aqui, por exemplo. Ent√£o, `s0` mais 4. L√™ o valor do dado que o dispositivo quer enviar para `s1`. OK? Ent√£o, isso aqui eu s√≥ estou mostrando como se usa essa diretiva `.eqv`. Ent√£o, `.eqv MASK 0x001` significa que onde tiver `MASK` no programa de voc√™s, ele vai substituir por `0x001`. Quem faz isso √© o montador. OK? Ent√£o, OK. Essa √© √≥tima. Ent√£o, vamos come√ßar a... Vamos implementar exce√ß√µes e interrup√ß√µes nos nossos processadores que a gente desenvolveu aqui em aula. Ent√£o, para simplificar a implementa√ß√£o, vamos identificar e tratar tr√™s exce√ß√µes. Uma exce√ß√£o de instru√ß√£o inv√°lida. Ent√£o, o cause igual a 2. Uma exce√ß√£o de endere√ßo desalinhado no load. Ent√£o, o cause igual a 4. Uma exce√ß√£o de endere√ßo desalinhado no store. Ent√£o, o cause igual a 6. Da onde que sa√≠ram esses n√∫meros? Sa√≠ram dessa tabela aqui. Ent√£o, o 2, instru√ß√£o inv√°lida. O 4, load address desalinhado. E o 6, store address desalinhado. OK? Aqui. E, como para fazer o tratamento das exce√ß√µes, n√≥s vamos precisar do banco de registradores CSR. Ent√£o, ao inv√©s de implementar o banco de registradores CSR e implementar aquelas instru√ß√µes `CSRR`, `CSRW`, `CSRRS`, `CSRRC`, por a√≠ vai. N√≥s vamos fazer uma coisa mais simples. S√≥ mostrar para voc√™s qual √© a ideia dessa implementa√ß√£o. Ent√£o, n√≥s vamos implementar o CSR, mas n√£o todos. Vamos implementar s√≥ esses quatro registradores aqui do banco de registradores CSR. O MCAUSE indica a causa da exce√ß√£o ou interrup√ß√£o. Voc√™ deve armazenar esses valores aqui. O MTVAL, que cont√©m a instru√ß√£o inv√°lida, nesse caso, ou o endere√ßo desalinhado, nesses dois casos aqui. O MEPC, que indica o endere√ßo da instru√ß√£o que estava sendo executada quando causou a exce√ß√£o. O MTVEC, que cont√©m o endere√ßo da rotina de tratamento de exce√ß√£o. Por exemplo, esse endere√ßo a√≠. Ent√£o, nesse endere√ßo aqui, como ele termina em zero, a exce√ß√£o √© tratada com o registrador de causa. Se fosse um aqui, a√≠ a exce√ß√£o seria tratada como uma exce√ß√£o vetorizada. OK? Ent√£o, a gente est√° tratando ela como uma interrup√ß√£o (ou exce√ß√£o), usando o registrador de causa. E o endere√ßo dessa rotina de tratamento de exce√ß√£o √© esse aqui. Beleza. Ent√£o, vamos l√°. Nossa ideia aqui √© colocar isso em pr√°tica. Ent√£o, para isso, est√° aqui o nosso RISC-V uniciclo. O que n√≥s vamos ter que fazer nesse datapath para permitir, ent√£o, a esse processador identificar e tratar aquelas tr√™s exce√ß√µes que a gente viu, certo? Essas tr√™s exce√ß√µes aqui: essa, essa e essa. Ent√£o, duas coisas sempre, n√©? Se eu quero acrescentar uma nova funcionalidade ao processador, eu tenho que garantir que o datapath tenha as funcionalidades necess√°rias e, depois, configurar o controle, n√©, para que as funcionalidades sejam, ent√£o, identificadas pelo controle, certo? Assim como novas instru√ß√µes, eu tenho que modificar o datapath e acrescentar a nova instru√ß√£o no controle. No nosso caso aqui, n√£o vai ser uma nova instru√ß√£o, vai ser uma exce√ß√£o. Ent√£o, o que n√≥s vamos fazer? O que tem que ser aqui? N√≥s vamos acrescentar quatro registradores. Est√£o aqui eles. Esse aqui vai servir para o MTVEC, o MCAUSE, o MEPC e o MTVAL. Ent√£o, eu j√° deixei escrever logo. Eu podia ter logo escrito isso a√≠, mas... Ent√£o, esse aqui vai ser o CAUSE. Ah, claro. Escrever direitinho, pelo menos, n√©, pessoal? Cad√™ meu... Ah, n√£o. Sabe, n√£o estou conseguindo escrever aqui, n√£o. N√£o estou conseguindo apagar. Ah, claro. Ent√£o, foi... Bloqueou todo mundo. Eu disse que tu fez. Bloqueei todo mundo? Como assim? Eu n√£o consigo digitar no chat. Mas, da√≠, eu acho que eu consigo desbloquear. Boa. Como que eu fiz isso? N√£o sei. Eu estou mexendo na imagem aqui em cima. Ah, meu Deus do c√©u. S√©rio, n√£o estou conseguindo. Foi, Eduardo. D√° para fazer agora? D√°, d√°. D√° para editar agora. N√£o, para a√≠ que eu vou ter que ver se est√° entendido errado. Porque, por isso, tem algo que n√£o est√° certo. O que √© isso? √â a furadeira, n√©? Entender. N√£o, est√° errado. Ent√£o, eu... A caneta n√£o est√° apagando. Escrever, ela escreve, mas apagar, ela n√£o. Ah, deixa eu dar uma olhadinha r√°pida aqui. S√≥ de escutar isso, voc√™ escuta a furadeira. Sim, vou... Como √© que eu fa√ßo para ver se n√£o boto? N√£o sei. √â s√≥ voc√™ colocar uma furadeira, a√≠, e a√≠, voc√™ vai... Eu vou... Eu vou... Eu vou... Eu vou... Eu vou... Eu vou... Eu vou... Eu vou... Eu vou... Eu vou... Eu vou... Eu vou... Eu vou... Eu vou... √â, realmente, eu aperto o bot√£o de apagar e ele para. Puts! Agora isso vai ser t√£o chato porque eu acho que √© problema da minha caneta. Bom, vamos tentar continuar a aula escrevendo tudo sem apagar.",
        "video_source": "OAC_2022-04-18.mp4"
    },
    {
        "id": 4,
        "timestamp_start": 1097.2,
        "timestamp_end": 1103.15,
        "slide_description": "Como Engenheiro de Computa√ß√£o S√™nior, analiso o slide e o conte√∫do anotado para extrair informa√ß√µes relevantes para um sistema de busca sem√¢ntica (RAG).\n\nO contexto visual principal √© uma interface de confer√™ncia ou aula online, identificada como \"Confer√™nciaWeb\" e especificamente a \"Sala de Aula de OAC\". A sigla \"OAC\" sugere fortemente \"Organiza√ß√£o e Arquitetura de Computadores\" ou \"Arquitetura de Computadores\", o que √© consistente com o tema da aula. A sess√£o est√° sendo gravada, indicado pelo √≠cone de grava√ß√£o e o timestamp \"18:26\".\n\n**Conte√∫do Textual Transcrito:**\n\n1.  **T√≠tulo da Sala/Apresentador:** No topo da √°rea principal, √© exibido \"Sala de Aula de OAC\" e, abaixo, \"Marcus Vinicius Lam...\" como o principal participante ou apresentador.\n2.  **Barra Lateral de Navega√ß√£o:**\n    *   **MENSAGENS:**\n        *   Perguntas\n        *   Bate-papo p√∫blico (selecionado)\n    *   **NOTAS:**\n        *   Notas compartilh... (presumidamente \"Notas compartilhadas\")\n    *   **USU√ÅRIOS (8):** Lista de participantes, incluindo:\n        *   Marcus Vini... (Voc√™)\n        *   Luiz Carlos Da Sil...\n        *   Eduardo Ferreira ...\n        *   Jo√£o Alberto Trav...\n        *   Marcello Brandao ...\n        *   Maycon Vinnycus...\n        *   Michel Luis Duwe\n        *   Victor Hugo Rodri...\n3.  **Conte√∫do do Bate-papo P√∫blico:** A conversa entre os participantes inclui as seguintes mensagens, com timestamps entre 14:01 e 14:16:\n    *   **Eduardo Ferreira Mar... 14:01:** \"100 m que devemos correr sem uma perna\"\n    *   **Luiz Carlos Da Silva N... 14:01:** \"ou eu n lembro dessa imagem no come√ßo mas maei\"\n    *   **Luiz Carlos Da Silva N... 14:01:** \"amei*\"\n    *   **Eduardo Ferreira Mar... 14:01:** \"achei foi tu que fez luisz\"\n    *   **Luiz Carlos Da Silva N... 14:02:** \"infelizmente n\"\n    *   **Luiz Carlos Da Silva N... 14:02:** \"adoraria ter sido o genio\"\n    *   **Eduardo Ferreira Mar... 14:10:** \"oquei\"\n    *   **Marcello Brandao Sca... 14:15:** \"furadeira hacker\"\n    *   **Eduardo Ferreira Mar... 14:16:** \"üèòÔ∏è üë∑üèΩ üöß Obras na casa do lamar destruindo a aula üò© ü§¶üèΩ ü§¶üèª\"\n    *   Abaixo do chat, h√° um campo de entrada de texto: \"Enviar mensagem para Bat...\" (presumidamente \"Bate-papo p√∫blico\").\n\n**Conte√∫do Visual (Diagramas/Estruturas/Fluxo de Dados):**\n\nO painel principal de exibi√ß√£o, que √© a √°rea designada para a apresenta√ß√£o de slides, diagramas ou c√≥digo da aula, est√° **completamente vazio e escuro**. N√£o h√° diagramas de datapath, pipeline, hierarquia de mem√≥ria, modelos de arquitetura de processadores, circuitos l√≥gicos, blocos de controle, fluxo de instru√ß√µes, estruturas de dados, ou quaisquer representa√ß√µes visuais ou textuais (como c√≥digo Assembly, C, Verilog) relacionadas ao conte√∫do de Arquitetura de Computadores. Isso indica que, no momento da captura da imagem, nenhum material did√°tico espec√≠fico da disciplina estava sendo compartilhado ou exibido na tela principal, ou o slide atual era intencionalmente em branco. O conte√∫do vis√≠vel limita-se √† interface da plataforma de confer√™ncia e √†s intera√ß√µes no chat.\n\n**Resumo para RAG:** A imagem representa uma interface de aula online de Arquitetura de Computadores (OAC) em andamento e gravada. O conte√∫do principal da aula (slides, diagramas, c√≥digo) est√° ausente na tela de apresenta√ß√£o. O conte√∫do vis√≠vel se restringe a intera√ß√µes de chat entre alunos e um apresentador, com mensagens que variam de coment√°rios informais a brincadeiras, e a lista de participantes da sess√£o. As mensagens do chat n√£o cont√™m termos t√©cnicos ou conceitos diretamente relacionados √† Arquitetura de Computadores, sendo conversas gerais entre os participantes.",
        "transcription": "√â eu fazendo a minha pr√≥pria caneta no ensino m√©dio",
        "video_source": "OAC_2022-04-18.mp4"
    },
    {
        "id": 5,
        "timestamp_start": 1103.15,
        "timestamp_end": 1106.01,
        "slide_description": "Como um Engenheiro de Computa√ß√£o S√™nior, analisei o slide apresentado de uma aula de Arquitetura de Computadores. O conte√∫do principal √© um plano de curso ou cronograma, exibido em um documento do Microsoft Word, com anota√ß√µes e informa√ß√µes contextuais do curso.\n\n**1. Transcri√ß√£o Fiel de Texto, T√≠tulo e C√≥digo:**\n\nO documento exibido √© intitulado \"OAC_A_Plano_2021-2_v0.docx\".\nNo canto superior direito do documento, s√£o vis√≠veis as seguintes informa√ß√µes institucionais:\n*   Universidade de Bras√≠lia\n*   Departamento de Ci√™ncia da Computa√ß√£o\n*   Prof. Marcus Vinicius Lamar\n*   CIC0090 - Organiza√ß√£o e Arquitetura de Computadores\n\nA parte central do slide apresenta uma tabela cronol√≥gica detalhando t√≥picos, laborat√≥rios e avalia√ß√µes. Abaixo, h√° uma se√ß√£o de \"Avalia√ß√£o\".\n\n**Conte√∫do da Tabela (coluna de datas / coluna de conte√∫do):**\n\n*   **Linha ~6:** (coluna da direita) FERIADO\n*   **Linha 7:** 7/3 | 9/3 | Lab 1B: Software ‚Äì Compilador C\n*   **Linha 8:** 14/3 | 16/3 | 1¬™ Prova (P1) | Lab 2: Hardware ‚Äì Verilog ‚Äì ULA (T7)\n*   **Linha 9:** 21/3 | 23/3 | 13) Processador Uniciclo: Unidade de Controle (C.4) (L1) | Lab 3: Processador Uniciclo (T8) (Nota: O \"T8\" est√° riscado, e \"L2\" foi escrito √† m√£o ao lado.)\n*   **Linha 10:** 28/3 | 30/3 | 14) Processador Multiciclo: Unidade Operativa (C.4) | 15) Processador Multiciclo: Unidade de Controle (C.4) (T10)\n*   **Linha 11:** 4/4 | 6/4 | Lab 4: Processador Multiciclo | 16) Processador Pipeline: Conceitos (C.4) (T11) (Nota: Uma seta grande e grossa, desenhada √† m√£o, aponta de \"Processador Multiciclo\" para \"Processador Pipeline\").\n*   **Linha 12:** 11/4 | 13/4 | 17) Pipeline: Unidade Operativa e Controle (C.4) | Lab 5: Processador Pipeline (T12) (L3)\n*   **Linha 13:** 18/4 | 20/4 | 18) Exce√ß√£o e Interrup√ß√£o (C.4) | 19) Mem√≥ria: Hierarquia (C.5) (T13) (L4)\n*   **Linha 14:** 25/4 | 27/4 | 19.1) Mem√≥ria: Cache (C.5) | 2¬™ Prova (P2) (T14) (L5)\n*   **Linha 15:** 2/5 | 4/5 | Prova Substitutiva | Apresenta√ß√£o dos Projetos (Pr) (T15)\n*   **Linha 16:** (Vazio)\n*   **Linha 17:** (Vazio)\n\n**Se√ß√£o \"Avalia√ß√£o\":**\n\n*   P1: 1¬™ Prova: 14/03/2022\n*   P2: 2¬™ Prova: 27/04/2022\n\n**2. Descri√ß√£o de Diagramas:**\n\nN√£o h√° diagramas complexos como Datapath, Pipeline ou Hierarquia de Mem√≥ria visualmente representados no slide. O conte√∫do se limita √† descri√ß√£o textual de conceitos de arquitetura de computadores, como processadores uniciclo e multiciclo, pipeline, exce√ß√µes/interrup√ß√µes e hierarquia de mem√≥ria/cache. Existe uma anota√ß√£o manual em forma de seta apontando do t√≥pico \"Processador Multiciclo\" para \"Processador Pipeline\", sugerindo uma progress√£o conceitual ou depend√™ncia entre os t√≥picos.\n\n**Informa√ß√µes Contextuais Adicionais (relevantes para um RAG sobre o curso):**\n\nA interface de videoconfer√™ncia mostra que a aula ocorre na \"Sala de Aula de OAC\". O nome do professor √© \"Marcus Vinicius Lamar\". O curso √© \"CIC0090 - Organiza√ß√£o e Arquitetura de Computadores\". A lista de t√≥picos detalha uma progress√£o desde a implementa√ß√£o de software (compilador C), passando por hardware (Verilog para ULA), design de processadores (uniciclo e multiciclo, com unidades de controle e operativa), pipeline, exce√ß√µes e interrup√ß√µes, at√© a hierarquia de mem√≥ria, incluindo cache. A exist√™ncia de \"Labs\" (Lab 1B, Lab 2, Lab 3, Lab 4, Lab 5) indica uma forte componente pr√°tica no curso. Os c√≥digos \"(C.x)\", \"(Tx)\", \"(Lx)\" provavelmente referem-se a cap√≠tulos ou se√ß√µes de material de estudo (\"C\") ou aulas te√≥ricas/t√≥picos (\"T\") e laborat√≥rios (\"L\"), respectivamente.",
        "transcription": "√â, no m√≥dulo",
        "video_source": "OAC_2022-04-18.mp4"
    },
    {
        "id": 6,
        "timestamp_start": 1106.01,
        "timestamp_end": 1170.34,
        "slide_description": "Como um Engenheiro de Computa√ß√£o S√™nior, analiso o slide e o contexto fornecido.\n\nO conte√∫do visual principal deste \"slide\" de uma aula de Arquitetura de Computadores √© notavelmente *ausente* de qualquer material did√°tico diretamente relacionado √† disciplina, como diagramas de datapath, pipelines, hierarquias de mem√≥ria, ou exemplos de c√≥digo (Assembly, C, Verilog). A √°rea central designada para a apresenta√ß√£o do conte√∫do da aula est√° completamente em branco, exibindo um fundo escuro uniforme.\n\nA informa√ß√£o extra√≠vel e transcrev√≠vel √© composta primariamente por metadados de uma plataforma de confer√™ncia web e intera√ß√µes de chat entre os participantes.\n\n**Conte√∫do Textual Transcrito:**\n\n1.  **T√≠tulo da Aplica√ß√£o/Sess√£o:**\n    *   No painel lateral esquerdo: \"Confer√™nciaWeb\"\n    *   Na barra superior central: \"Sala de Aula de OAC\" (OAC provavelmente denota \"Organiza√ß√£o e Arquitetura de Computadores\").\n    *   Na barra superior central, um indicador de tempo: \"18:34\" (com um c√≠rculo vermelho, indicando grava√ß√£o ou status ativo).\n\n2.  **Navega√ß√£o e Menus do Painel Lateral Esquerdo:**\n    *   \"MENSAGENS\"\n        *   \"Perguntas\" (com √≠cone de m√£o levantada)\n        *   \"Bate-papo p√∫blico\" (com √≠cone de bal√£o de fala)\n    *   \"NOTAS\"\n        *   \"Notas compartilh...\" (com √≠cone de arquivo/documento)\n    *   \"USU√ÅRIOS (8)\" (com √≠cone de engrenagem para configura√ß√µes)\n\n3.  **Lista de Usu√°rios Ativos (8 no total, vis√≠veis):**\n    *   \"Marcus Vinicius Lam... (Voc√™)\"\n    *   \"Luiz Carlos Da Sil...\"\n    *   \"Eduardo Ferreira ...\"\n    *   \"Jo√£o Alberto Trav...\"\n    *   \"Marcello Brandao...\"\n    *   \"Maycon Vinnycus...\"\n    *   \"Michel Luis Duwe\"\n    *   \"Victor Hugo Rodri...\"\n    *   Na parte superior da tela principal, h√° tamb√©m uma lista abreviada de participantes com c√¢meras/microfones ativados ou em destaque: \"Marcus Vinicius Lam...\", \"Eduardo Ferreira Ma...\", \"Luiz Carlos Da Silva ...\".\n\n4.  **Conte√∫do do Bate-papo P√∫blico:**\n    *   **Eduardo Ferreira Mar... (14:01):** \"100 m que devemos correr sem uma perna\"\n    *   **Luiz Carlos Da Silva N... (14:01):** \"ou eu n lembro dessa imagem no come√ßo\"\n    *   **Luiz Carlos Da Silva N... (14:01):** \"mas maei\"\n    *   **Luiz Carlos Da Silva N... (14:01):** \"amei*\"\n    *   **Eduardo Ferreira Mar... (14:01):** \"achei foi tu que fez luissz\"\n    *   **Luiz Carlos Da Silva N... (14:02):** \"infelizmente n\"\n    *   **Luiz Carlos Da Silva N... (14:02):** \"adoraria ter sido o genio\"\n    *   **Eduardo Ferreira Mar... (14:10):** \"oquei\"\n    *   **Marcello Brandao Sca... (14:15):** \"furadeira hacker\"\n    *   **Eduardo Ferreira Mar... (14:16):** \"üë∑‚Äç‚ôÇÔ∏èüöß obras na casa do lamar destruindo a aula üë∑‚Äç‚ôÇÔ∏èüöß\"\n\n**Descri√ß√£o de Diagramas/Estrutura/Fluxo de Dados:**\n\nN√£o h√° diagramas (Datapath, Pipeline, Hierarquia de Mem√≥ria) ou qualquer representa√ß√£o gr√°fica t√©cnica de arquitetura de computadores vis√≠vel neste \"slide\". O conte√∫do √© puramente textual, relacionado √† interface e intera√ß√£o de uma plataforma de aula online. N√£o √© poss√≠vel inferir estrutura ou fluxo de dados de componentes arquitet√¥nicos a partir da imagem fornecida.\n\n**S√≠ntese para um Sistema de Busca Sem√¢ntica (RAG):**\n\nEste documento representa um artefato de uma aula online intitulada \"Sala de Aula de OAC\" (Organiza√ß√£o e Arquitetura de Computadores), utilizando a plataforma \"Confer√™nciaWeb\". Embora o conte√∫do da palestra esteja ausente, o registro captura intera√ß√µes do bate-papo p√∫blico entre alunos como Eduardo Ferreira, Luiz Carlos Da Silva, e Marcello Brandao, com timestamps variando de 14:01 a 14:16. As mensagens discutem t√≥picos informais, incluindo refer√™ncias a imagens, coment√°rios sobre autoria (\"achei foi tu que fez luissz\"), e distra√ß√µes (\"obras na casa do lamar destruindo a aula\"). A lista de usu√°rios presentes inclui Marcus Vinicius Lam, Maycon Vinnycus, Michel Luis Duwe, Victor Hugo Rodri, entre outros. A imagem n√£o cont√©m nenhum material de arquitetura de computadores, focando apenas na infraestrutura de comunica√ß√£o da aula.",
        "transcription": "Modo permanente, modo arriscado. Ent√£o, vamos l√°, modo super arriscado. Bom. Ent√£o, isso aqui √© a **fase**. Esse aqui √© o **Decode**. Esse aqui vai ser o **Divide**. Esse aqui √© o **Execute**. S√£o esses quatro **estados** aqui. N√£o √© intervalo, s√≥ **vale**. Esse a√≠ √© o **Execute**.",
        "video_source": "OAC_2022-04-18.mp4"
    },
    {
        "id": 7,
        "timestamp_start": 1170.34,
        "timestamp_end": 2936.91,
        "slide_description": "Como Engenheiro de Computa√ß√£o S√™nior, apresento a an√°lise t√©cnica detalhada do slide e conte√∫do anotado da aula de Arquitetura de Computadores para um sistema de busca sem√¢ntica (RAG):\n\nO slide, intitulado **\"RISC-V Uniciclo\"**, apresenta o diagrama do *datapath* (caminho de dados) de um processador RISC-V de ciclo √∫nico, t√≠pico em estudos de Arquitetura de Computadores. O cabe√ßalho indica o contexto acad√™mico: **\"UnB ‚Äì CIC0099 ‚Äì Organiza√ß√£o e Arquitetura de Computadores\"**, da **\"Universidade de Bras√≠lia, Departamento de Ci√™ncia da Computa√ß√£o\"**, ministrado pelo **\"Prof. Marcus Vinicius Lamel\"**.\n\n**Conte√∫do Visual Principal: Datapath RISC-V Uniciclo**\n\nO diagrama ilustra o fluxo de dados para execu√ß√£o de instru√ß√µes em um √∫nico ciclo de clock, abrangendo as cinco etapas cl√°ssicas de um pipeline (Fetch, Decode, Execute, Memory, Write Back), embora aqui todas ocorram simultaneamente no mesmo ciclo.\n\n1.  **Instruction Fetch (Busca de Instru√ß√£o):**\n    *   Um registrador **PC** (Program Counter) armazena o endere√ßo da instru√ß√£o atual.\n    *   O valor do **PC** √© enviado para a **Instruction memory** (mem√≥ria de instru√ß√£o) para buscar a instru√ß√£o.\n    *   Paralelamente, o **PC** √© somado a 4 (usando uma unidade **Add**) para calcular o endere√ßo da pr√≥xima instru√ß√£o sequencial (**PC+4**).\n    *   Um multiplexador (**MUX**, com entradas 0 e 1) seleciona entre **PC+4** e um endere√ßo de desvio/salto calculado (sa√≠da de outra unidade **Add**), determinando o pr√≥ximo valor do **PC**.\n    *   A sa√≠da da **Instruction memory** √© a **Instruction [31-0]** (instru√ß√£o completa de 32 bits).\n\n2.  **Instruction Decode & Register Fetch (Decodifica√ß√£o e Busca de Registradores):**\n    *   A **Instruction [6-0]** (opcode) √© enviada para a unidade de **Control** (controle).\n    *   A unidade **Control** gera os sinais de controle para todos os componentes do *datapath*: `Branch`, `MemRead`, `MemtoReg`, `ALUOp`, `MemWrite`, `ALUSrc`, `RegWrite`.\n    *   A instru√ß√£o tamb√©m √© dividida para acessar os **Registers** (banco de registradores):\n        *   **Instruction [19-15]** especifica o `Read register 1`.\n        *   **Instruction [24-20]** especifica o `Read register 2`.\n        *   **Instruction [11-7]** especifica o `Write register`.\n    *   O banco de registradores fornece `Read data 1` e `Read data 2`.\n    *   O m√≥dulo **Imm Gen** (Immediate Generator) utiliza partes da **Instruction [31-0]** e **Instruction [30,14-12]** para gerar o valor imediato, que pode ser um dos operandos da ALU ou parte do c√°lculo de endere√ßo de branch/jump.\n\n3.  **Execute (Execu√ß√£o):**\n    *   `Read data 1` (do primeiro registrador lido) √© um dos operandos da **ALU** (Arithmetic Logic Unit).\n    *   O segundo operando da **ALU** √© selecionado por um **MUX** (controlado por `ALUSrc`): pode ser `Read data 2` (do segundo registrador lido) ou o valor imediato (`Imm Gen`).\n    *   A **ALU** executa a opera√ß√£o controlada pela unidade **ALU control**.\n    *   A unidade **ALU control** recebe `ALUOp` (da unidade **Control**) e partes da instru√ß√£o (`Instruction [30,14-12]`, que correspondem aos campos funct3 e funct7 para instru√ß√µes R-type).\n    *   A **ALU** produz `ALU result` e um sinal `Zero` (indicando se o resultado √© zero, crucial para branches condicionais).\n\n4.  **Memory Access (Acesso √† Mem√≥ria):**\n    *   O `ALU result` √© utilizado como `Address` para a **Data memory** (mem√≥ria de dados).\n    *   `Read data 2` √© usado como `Write data` para a **Data memory** em opera√ß√µes de escrita.\n    *   A **Data memory** √© controlada pelos sinais `MemRead` e `MemWrite` (da unidade **Control**).\n    *   Em caso de leitura, a **Data memory** produz `Read data`.\n\n5.  **Write Back (Escrita de Resultado):**\n    *   Um **MUX** (controlado por `MemtoReg`) seleciona qual valor ser√° escrito de volta no banco de **Registers**: o `ALU result` (para instru√ß√µes R-type ou imediatas) ou o `Read data` da **Data memory** (para instru√ß√µes de load).\n    *   Este valor √© o `Write data` para o banco de **Registers**, e a escrita √© habilitada pelo sinal `RegWrite`.\n\n**L√≥gica de Branch/Jump:**\n*   A sa√≠da de uma unidade **Shift left 1** (que desloca um valor imediato de branch em 1 bit para esquerda, multiplicando por 2, considerando que endere√ßos s√£o alinhados por palavra) e o **PC+4** s√£o somados por uma unidade **Add** para gerar o endere√ßo alvo de um branch.\n*   A condi√ß√£o de branch √© determinada por um sinal **AND** que combina o sinal `Branch` (do **Control**) com o sinal `Zero` (da **ALU**). Este sinal controla o **MUX** que atualiza o **PC**.\n\n**Anota√ß√µes Manuscritas em Vermelho:**\n*   `0x00400000`: Provavelmente um endere√ßo inicial para o **PC** ou um ponto de interesse na mem√≥ria.\n*   `TRAC`: Possivelmente relacionado a um mecanismo de *trace* ou depura√ß√£o.\n*   Setas e linhas vermelhas sublinham fluxos de dados importantes ou pontos de controle.\n*   Na parte superior direita, s√£o vis√≠veis componentes de tratamento de exce√ß√µes/interrup√ß√µes (um *common practice* em RISC-V para `CSRs` - Control and Status Registers):\n    *   Tr√™s pares de `MUX`es (0/1) para sinais que parecem ser `CAUSE`, `EC` (Exception Code), `EP` (Exception Program Counter), `VAL` (Trap Value), `EV`. Estes provavelmente se referem aos registradores `mcause`, `mepc`, e `mtval` do RISC-V, que armazenam informa√ß√µes sobre a exce√ß√£o/interrup√ß√£o.\n    *   Os n√∫meros `2`, `y`, `0`, `1`, `X` ao lado indicam os estados ou valores desses sinais de controle/multiplexadores.\n    *   `FC` e `TCCL` s√£o outras anota√ß√µes, cujo contexto espec√≠fico n√£o √© claro apenas pela imagem, mas podem se referir a Function Call ou Trap Cause Code Latch.\n\n**Tabela de Sinais de Controle (Control Signal Table):**\nA tabela abaixo do *datapath* descreve os valores dos sinais de controle para algumas instru√ß√µes RISC-V, ilustrando como a unidade de **Control** configura o *datapath* para diferentes opera√ß√µes:\n\n| Instru√ß√£o | ALUSrc | MemtoReg | RegWrite | MemRead | MemWrite | Branch | ALUOp |\n| :-------- | :----- | :------- | :------- | :------ | :------- | :----- | :---- |\n| **Tipo-R** | 0      | 0        | 1        | 0       | 0        | 0      | 10    |\n| **lw**    | 1      | 1        | 1        | 1       | 0        | 0      | 00    |\n| **sw**    | 1      | X        | 0        | 0       | 1        | 0      | 00    |\n| **beq**   | 0      | X        | 0        | 0       | 0        | 1      | 01    |\n\n*   **Tipo-R**: O segundo operando da ALU vem de um registrador (`ALUSrc=0`), o resultado da ALU √© escrito no registrador destino (`MemtoReg=0`, `RegWrite=1`), n√£o h√° acesso √† mem√≥ria (`MemRead=0`, `MemWrite=0`), n√£o √© um branch (`Branch=0`), e a ALU executa uma opera√ß√£o gen√©rica de tipo R (`ALUOp=10`).\n*   **lw (Load Word)**: O segundo operando da ALU √© um imediato (`ALUSrc=1`), o dado lido da mem√≥ria √© escrito no registrador destino (`MemtoReg=1`, `RegWrite=1`), h√° leitura da mem√≥ria (`MemRead=1`, `MemWrite=0`), n√£o √© um branch (`Branch=0`), e a ALU realiza uma soma para calcular o endere√ßo (`ALUOp=00`).\n*   **sw (Store Word)**: O segundo operando da ALU √© um imediato (`ALUSrc=1`), n√£o h√° escrita em registrador (`RegWrite=0`, `MemtoReg=X` - irrelevante), h√° escrita na mem√≥ria (`MemRead=0`, `MemWrite=1`), n√£o √© um branch (`Branch=0`), e a ALU realiza uma soma para calcular o endere√ßo (`ALUOp=00`).\n*   **beq (Branch if Equal)**: O segundo operando da ALU vem de um registrador (`ALUSrc=0`), n√£o h√° escrita em registrador (`RegWrite=0`, `MemtoReg=X` - irrelevante), n√£o h√° acesso √† mem√≥ria (`MemRead=0`, `MemWrite=0`), √© um branch condicional (`Branch=1`), e a ALU realiza uma subtra√ß√£o para comparar os operandos e gerar o sinal `Zero` (`ALUOp=01`).\n\n**Instru√ß√µes Anotadas Manuscritamente na Tabela:**\n*   `jm Sin`\n*   `Lw DA`\n*   `Sw DA`\nEssas s√£o provavelmente varia√ß√µes ou instru√ß√µes espec√≠ficas discutidas na aula, talvez \"jm Sin\" para Jump Signed, e \"Lw DA\" e \"Sw DA\" para Load/Store Data Aligned ou com modos de endere√ßamento espec√≠ficos.\n\nO slide fornece uma vis√£o compreens√≠vel do funcionamento de um processador RISC-V de ciclo √∫nico, destacando os componentes essenciais e o fluxo de controle para instru√ß√µes b√°sicas e tratamento de exce√ß√µes.",
        "transcription": "N√£o tinha escrito aqui. Tinha, mas acho que a gente tem que fazer todos os passos de novo. √â a parte da coisa... Voc√™ escreveu? Voc√™ botou pra descartar l√° quando voc√™... N√£o, n√£o √© quando... Sim, olha! Est√° gravado. Olha aqui! N√£o est√° gravado? Meu Deus do c√©u. `mcause`, `mepc`, `mtval`. Bom, vamos l√°.\n\nEnt√£o, vamos ver aqui. Eu sei que vou precisar incluir esses quatro registradores. Esses quatro registradores n√£o podem ser escritos a qualquer momento, ent√£o n√£o √© na borda de subida de clock que eles s√£o escritos. Ele tem que ser escritos quando eu mandar ele escrever, certo? Ent√£o eu vou ter que botar aqui um `enable` para o `mcause`, um `enable` para o `mepc` e um `enable` para o `mtval`. Ent√£o eu s√≥ vou escrever nesses registradores quando esses `enables` estiverem ativados, ok?\n\nA mesma coisa aqui, o `MTVEC`. A gente nem precisa escrever porque ele j√° est√° escrito com o endere√ßo. A gente vai colocar aqui, ele j√° est√° escrito com o endere√ßo `0x800000`, certo? Que √© o endere√ßo da rotina de tratamento de exce√ß√£o. Ok.\n\nEnt√£o, o que que eu vou gravar nele? Eu vou gravar, no registrador `mcause`, eu vou ter que gravar: ou 2, ou 4, ou 6. S√£o as causas, certo? No `mepc`, o que que eu vou gravar no `mepc`? O PC atual, o PC de onde ocorreu a exce√ß√£o. Onde √© que tem o PC atual a√≠? Ali, √≥. Basta eu pegar daqui, que eu tenho o PC atual. Vai dizer que eu perdi tudo? Como assim? 2, 4, 6, entra aqui: enable `mcause`, enable `mepc` e enable `mtval`. Certo? De onde que vem esse PC? N√£o √© aqui que eu tenho que botar? Ah, bom. Esse aqui √© do multiciclo. √â daqui que tem que botar. Que susto, cara. De onde que vem, ent√£o, esse sinal aqui? Vem do PC. O PC t√° aqui, certo? Ah, n√£o. O PC atual. Ent√£o eu vou pegar esse valor aqui e botar aqui, ok? Ok, tudo bem? Quer dizer, eu vou gravar no `mepc` o valor do PC atual. O que que vai ser o `mtval`? O `mtval`, certo? Ent√£o, se a instru√ß√£o for inv√°lida, o que eu tenho que escrever √© a instru√ß√£o, a pr√≥pria instru√ß√£o. Onde que aqui eu tenho a instru√ß√£o que foi definida e que eu detectei como sendo inv√°lida? Na sa√≠da dessa mem√≥ria de instru√ß√µes. Ent√£o, aqui eu tenho a instru√ß√£o que eu detectei como sendo inv√°lida e √© isso que eu quero salvar aqui. E se por acaso for o endere√ßo do `load` ou do `store` quando eles forem inv√°lidos? Quem √© que calcula o endere√ßo do `store`, do `load`? Pessoal, a ULA? N√£o. A ULA t√° aqui. A ULA... O resultado, o endere√ßo, t√°? Ent√£o √© a ULA, o resultado que eu tenho na ULA, que eu tenho que vir pra c√°, certo?\n\nEnt√£o, desse modo, n√≥s configuramos o que tem que ser escrito nesses registradores ao vir a borda, se esses sinais aqui estiverem ativados. Ent√£o, a causa que n√≥s vamos ter que escolher agora vai ser gravada no `mcause`. O PC vai ser gravado no `mepc`. E um desses dois valores, que √© ou a instru√ß√£o ou o endere√ßo da ULA (quer dizer, o endere√ßo que eu estou acessando a mem√≥ria), vai ser gravado no `mtval`. E o que mais que eu preciso fazer? Preciso que, quando acontecer a exce√ß√£o, ao inv√©s dele gravar no PC o valor que vinha originalmente, seja `PC+4` ou endere√ßo do `JALR` ou do `BEQ` (nesse caso aqui n√£o tem `JAL`), ao inv√©s de eu gravar no PC esse endere√ßo, eu vou ter que gravar no PC esse endere√ßo aqui que est√° no `MTVEC`. Ent√£o eu vou precisar colocar... Cad√™ o meu condicionador? Achei. Ent√£o eu vou ter que botar aqui o multiplexador. Se for 0, ele pega o endere√ßo direto. Se for 1, ele vai pegar o endere√ßo do `MTVEC`, e isso vem pro PC. Ok.\n\nVamos ver essa parte aqui. Ent√£o, esse multiplexador vai ter que ser controlado tamb√©m. Deixa eu ver aqui, olha s√≥. Deixa eu ver aqui, t√°? Tem que ser controlado por um 'Escreve `MTVEC`', ok? Ou tamb√©m podemos simplificar isso a√≠ para 'ET Escreve `MTVEC`'. Esses aqui s√£o `enables` que n√£o deve ser um 'Escreve' tamb√©m, s√≥ que aqui eu estou selecionando qual √© o endere√ßo. Estou selecionando qual √© o endere√ßo que vai ser gravado no PC, se vai ser o endere√ßo original do processador ou o endere√ßo do `MTVEC`, da rotina de tratamento de exce√ß√£o. Ok? At√© a√≠ tudo bem? Tranquilo, pessoal? Beleza. Agora n√≥s vamos ter que ver quem que detecta que √© uma instru√ß√£o inv√°lida. Quem que descobre que isso √© uma instru√ß√£o inv√°lida? Quem que sabe que a instru√ß√£o que eu li aqui √© inv√°lida? Claro que nosso sistema est√° usando s√≥ o `opcode` pra ele ver que a instru√ß√£o √© inv√°lida. Se fosse verificar mesmo, teria que verificar o `opcode`, o `funct3` e o `funct7`. Mas no nosso caso aqui, eu s√≥ vou verificar o `opcode`. Se o `opcode` n√£o for nem desses que eu conhe√ßo, que s√£o esses aqui, vou dizer que √© uma instru√ß√£o inv√°lida. Ok? Ent√£o, quem que sabe se a instru√ß√£o √© inv√°lida? O controle. Ent√£o, ele pode me dar um sinal aqui. Vamos l√°, vamos l√°, de instru√ß√£o inv√°lida, `II`. Ok? Ent√£o, quando o controle detectar uma instru√ß√£o inv√°lida, ele vai acionar esse `II` aqui. Entendido? Eu coloquei um novo sinal aqui de sa√≠da, `II`. Que mais? Como √© que eu sei que o endere√ßo aqui est√° desalinhado? Como √© que eu descubro que esse endere√ßo est√° desalinhado? O que √© um endere√ßo desalinhado, pessoal? Quando que eu sei que o endere√ßo est√° desalinhado? N√£o, n√£o. Eu quero saber o que que eu sei que o endere√ßo est√° desalinhado, eu olhando o endere√ßo. Como √© que eu sei que esse endere√ßo est√° desalinhado? N√£o. O endere√ßo desalinhado, ele pode estar em qualquer posi√ß√£o da mem√≥ria. N√£o necessariamente tem que estar no `.text`. Como √© que eu sei que o endere√ßo qualquer est√° alinhado ou desalinhado? Ah, n√£o sei, professor. Desculpa. Vamos ver se o Michael diz a√≠. √â divis√≠vel por 4. Isso. Tudo bem, entendi. Significa que o endere√ßo √© m√∫ltiplo de 4. Se o endere√ßo √© m√∫ltiplo de 4, ele est√° alinhado, certo? Ent√£o, 0, 4, 8, 12, 16, 20 por a√≠ vai. Logo, se o endere√ßo terminar... Cad√™? Cad√™? Cad√™? Cad√™? Cad√™? Eu, eu, eu, eu, eu aqui... verde aqui e falso aqui, que eu quero saber o endere√ßo desalinhado, certo? Eu s√≥ preciso verificar os dois √∫ltimos bits do endere√ßo. Cad√™ o endere√ßo? Cad√™ o meu cursor? Isso, isso. Uma porta OR aqui. Ent√£o, uma porta OR dos bits 0 e do bit 1 do endere√ßo √© o suficiente para saber se ele est√° desalinhado, certo? Onde √© que eu tenho esses dois bits? Ent√£o, daqui, ao inv√©s de eu colocar daquele jeito l√°, eu vou escrever de um modo mais simplificado. Quer dizer, eu tenho o bit 0 e o bit 1, o bit do endere√ßo, quer dizer, o bit menos significativo do endere√ßo e o segundo bit menos significativo do endere√ßo. Isso aqui vai me dizer se ele est√° alinhado, se ele est√° desalinhado. Quando for 1 ali, √© porque ele est√° desalinhado, ok? Entendido? Ent√£o, eu vou chamar isso aqui de sinal `desalinhado`. Beleza! Pra onde que vai esse sinal `desalinhado`? Quem que tem que saber se o sinal est√° desalinhado? Quer dizer, se o endere√ßo est√° desalinhado para tomar alguma atitude? O controle. Ent√£o, eu vou colocar isso aqui como uma nova entrada do controle, certo? Nosso `DA` (sinal desalinhado), ele entra no controle. E assim, o controle fica sabendo se aquilo que ele quer fazer gerou um endere√ßo desalinhado, certo? Para `load` e `store`. Beleza? Eu acho que √© s√≥ isso que precisa. Est√° faltando mais alguma coisa? Acho que n√£o. Ent√£o, vamos l√°.\n\nEnt√£o, se eu coloquei mais um dado de entrada aqui, eu vou ter que colocar em que situa√ß√µes eu preciso que o controle tome alguma atitude. Ent√£o, a primeira situa√ß√£o, quando for uma instru√ß√£o inv√°lida. Ent√£o, vou colocar aqui na tabela de verdade: se for uma instru√ß√£o inv√°lida, instru√ß√£o inv√°lida, eu vou ter que tomar alguma atitude. No outro caso, se for um `load` e o desalinhado for um, eu tenho que tomar outra atitude. Se for um `store` e o desalinhado for um, eu tenho que tomar outra atitude. Certo? Aqui eu vou precisar colocar se for um `load` e o desalinhado... N√£o, n√£o interessa o desalinhado. N√£o, se for um `load` e o desalinhado n√£o interessa o desalinhado. N√£o, deixa assim. Deixa sem o... Porque o controle vai mudar. Ah, eu n√£o posso apagar. Esqueci. Eita. Ent√£o, eu tiro esse neg√≥cio daqui. Pronto, apaguei. Ent√£o, s√£o essas tr√™s situa√ß√µes que eu preciso identificar agora: se √© uma instru√ß√£o inv√°lida (√© o controle que decide isso, ele sabe se √© uma instru√ß√£o...), se for um `load`, o controle sabe se √© um `load`, e se ele estiver desalinhado (quer dizer, esse bit for um), a√≠ eu vou ter que tomar uma atitude. Se for um `store` e estiver desalinhado, eu vou ter que tomar outra atitude, t√°? Isso aqui eu queria fazer um AND aqui com ele `desalinhado`, com ele `alinhado`. Mas j√° vim de volta. Se eu colocar aqui: AND `desalinhado` barra, AND `desalinhado` barra, AND `desalinhado` barra, AND `desalinhado` barra... Deixa eu tentar ser escravo. Meu Deus do c√©u. Cad√™ meu cursor? AND `desalinhado` barra. Certo? Assim eu fico com... Essa aqui tamb√©m, AND `desalinhado` barra. Assim eu fico com essas duas condi√ß√µes. Se o `DA` √© negativo, √© positivo, quer dizer, √© positivo... √â ruim. O pior √© que eu acho que n√£o funciona, Marcelo. Porque ele vai pintar de branco, n√£o de transparente. N√£o vai virar aquilo que eu pintei. Ele vai pintar de brancozinho. Isso aqui n√£o √© branco, √© azul. Pinta de azul. √â eu achar esse azul aqui pra pintar. N√£o esquece. Tem como selecionar a cor, tipo... Sim, tem que ficar fazendo isso. N√£o √© importante. N√£o, o importante √© ele funcionar. Essa caneta aqui. Eu estou impressionado que caiu no ch√£o e estragou alguma coisa. Mas vamos l√°.\n\nBeleza, ent√£o tem a lista das instru√ß√µes: esse, esse, esse, esse. Instru√ß√£o inv√°lida. Quer dizer, se o `opcode` n√£o for nenhum desses, eu tenho que acionar essa instru√ß√£o inv√°lida. √â porque √© uma instru√ß√£o inv√°lida, certo? O `opcode` n√£o √© nem esse, nem esse, nem esse, nem esse. √â uma instru√ß√£o inv√°lida, certo? Entendido, pessoal? Quer dizer, na tabela-verdade, o `opcode` vai escrever tudo para o tipo R, para o `load`, para o `BEQ`, e para as outras condi√ß√µes vai ser isso aqui. N√£o, a instru√ß√£o inv√°lida, ele sabe aqui no momento que ele deu a instru√ß√£o. A√≠ ele sabe que √© inv√°lido, certo? O endere√ßo desalinhado, sim, ele s√≥ vai saber como calcular. Mas a instru√ß√£o ou vai ser um `load` ou vai ser um `store`. Ent√£o ele sabe qual √© a instru√ß√£o, certo? Certo. Beleza. E agora o meu controle vai ter que gerar todos esses sinais aqui: o `ET`, o `EC` (enable cause), o `EP` (enable mepc) e o `EV` (enable mtval). A√≠, mais ainda aqui, vamos colocar esse aqui como sendo `SC` (seleciona a causa) e esse aqui `SV` (seleciona o valor). S√£o esses dois seletores aqui. Ent√£o a gente tem mais um, 1, 2, 3, 4, 5, 6 sinais de controle, certo? Quem vai gerar esses sinais de controle? O controle, obviamente. Ent√£o, o controle vai ter que gerar todos esses sinais de controle. Depois voc√™s v√£o ver que esses aqui s√£o todos iguais, t√°? Esse vai ser igual a eles, mas vamos fazer do modo cl√°ssico. Eu estou controlando para cada registrador, eu controlo com um sinal. Controlar tudo com um sinal s√≥ vai funcionar? Pode ter efeitos colaterais n√£o previstos, t√°? Ent√£o, eu vou ter o 'escreve `MTVEC`', o `SC` (que √© o 'seleciona causa'), o `EC` (que √© o 'escreve causa'), o `SV` (que √© o 'seleciona valor'), o `EV` (que √© o 'escreve valor'), e o `EEP` (que √© o 'escreve `mepc`'). Na realidade, escreve `mepc`, mas vamos colocar como `mepc`. Ok? Eu preciso de... Ah, professor. Oi. Ela ia gerar efeitos num√©ricos. Voc√™ falou que isso a√≠ precisa de outros efeitos de checagem. Mas os efeitos de checagem v√£o gerar outros efeitos de checagem, checa e checa, porque n√£o tem efeitos colaterais. N√£o pode ter, t√°? Nesse caso aqui, n√£o vai ter. Em um sistema maior, a gente n√£o faz esse tipo de coisa, t√°? Em um sistema mais complexo: colocar todos os registradores controlados por um √∫nico sistema, por um √∫nico sinal. T√°? Isso √© fora das boas recomenda√ß√µes de hardware. A gente faz o controle de cada um deles separadamente. N√£o, n√£o, n√£o. N√£o tem clock. O clock √© um s√≥ para todo o circuito. Vem a borda de subida de clock. O que que acontece? Vindo a borda de subida de clock, isso aqui vai ler do PC (o que tiver no PC, n√©?). Vai ler a instru√ß√£o. A√≠ o controle vai decidir se a instru√ß√£o √© v√°lida ou n√£o. Se a instru√ß√£o for inv√°lida, o que que ele tem que fazer? A instru√ß√£o √© inv√°lida. Ent√£o, o `ALUSrc` tem que ser o qu√™? N√£o, bloquear tudo, n√£o. O que a gente quer, se a instru√ß√£o for inv√°lida, √© que ele passe a executar a rotina de tratamento de exce√ß√£o, t√°? A gente n√£o quer que pare a m√°quina, n√£o. A gente quer que ele v√° para esse endere√ßo aqui. √â isso que a gente quer: detectar a instru√ß√£o inv√°lida. Logo, `ALUSrc`? A ULA vai ser usada para alguma coisa? Eu s√≥ quero botar esse valor aqui e escrever nesses registradores. N√£o. Ent√£o, a ULA pode fazer qualquer coisa, n√£o vai modificar em nada no resultado. Nem `RegWrite`. Eu vou querer escrever no banco de registradores? N√£o. Eu vou escrever no banco de registradores? N√£o. Eu quero ler da mem√≥ria? N√£o. Eu quero escrever na mem√≥ria? N√£o. √â um `branch`? N√£o. O `ALUOp`? Tanto faz, certo? Ent√£o, notem que a √∫nica coisa que eu coloquei como 'tanto faz' s√£o essa sele√ß√£o dos multiplexadores aqui. E esse controle aqui, tanto faz o que ela vai fazer aqui. Os controles de escrita no banco de registradores, tem que colocar zero. N√£o quero que escreva. Porque n√£o adianta eu colocar 'tanto faz' e de repente √© um aqui. Ele vai escrever o lixo do banco de registradores. Tem que ser zero. `MemRead` e `MemWrite` tamb√©m: zero e zero. Controla a leitura e escrita na mem√≥ria. N√£o quero ler e nem quero gravar, certo? Se √© um `branch`, esse aqui at√© poderia ser 'tanto faz'. Por qu√™? Tanto faz qual vai ser o endere√ßo, qual vai ser o endere√ßo que vai sair daqui. Porque eu vou querer escolher √© esse endere√ßo aqui, e n√£o o endere√ßo original. Ent√£o, aqui esse `branch` tamb√©m poderia ser 'tanto faz', ok? Por qu√™? Esse `branch` vai acionar essa porta AND e vai selecionar ou esse endere√ßo ou esse endere√ßo. Por que 'tanto faz'? Porque, na realidade, esse endere√ßo n√£o vai ser utilizado, ok? Ent√£o, vamos l√°. Agora os outros: 'escreve `MTVEC`'? Sim. Escreve `MTVEC`? Ent√£o, para onde que vai vir o endere√ßo? Tem que vir do `MTVEC`. Ent√£o, aqui vai ser 1. Opa, peguei 1. Seleciona a causa. Qual √© a causa de instru√ß√£o inv√°lida? 2, 4 ou 6? Seria o terceiro, n√©? √â 2. Isso. Ent√£o, seleciona a causa: 0, 0. Porque eu quero escolher esse n√∫mero 2 aqui para ser colocado para escrever a causa. Eu vou querer escrever a causa? Sim. Ent√£o, escreve causa igual a 1. Seleciona o valor. Qual √© o valor que eu quero que eu escreva? Que eu escreva no registrador `mtval`? A instru√ß√£o ou o endere√ßo do `load` ou do `store`? A instru√ß√£o. Ent√£o, seleciona o valor: 0. Ele vai escrever esse endere√ßo no PC e n√£o vai fazer mais nada. Esses aqui v√£o estar sendo escritos tamb√©m l√° na borda de subida do clock, certo? Ent√£o, na instru√ß√£o seguinte, ele vai pegar o endere√ßo que tiver armazenado no PC, que vai ser o endere√ßo, esse aqui do `MTVEC`, para executar as instru√ß√µes que tiverem l√°. Entendido, pessoal? Ok?\n\nEnt√£o, vamos l√°. Outro: se for um `load` desalinhado. `Load` desalinhado. O que que eu preciso fazer? Ent√£o, vamos l√°. Se for um `load`, quanto √© que vale o `ALUSrc`? `ALUSrc = 1`. T√° aqui. Se for um `load`, eu preciso que a ULA calcule o endere√ßo do `load`. Ai meu Deus do c√©u. Eu quero que isso aqui seja 1. Nem `RegWrite`. Eu quero escrever no banco de registradores? Eu quero escrever no banco de registradores? Nem `RegWrite`. Vou querer escrever no banco de registradores? N√£o, ent√£o √© X. Se o `load`, o `load` for detectado como alinhado, eu quero escrever? Quer dizer, o que que eu vou escrever no banco de registradores? E aqui, se eu quero escrever no banco de registradores, eu quero escrever se o `load` tiver desalinhado? N√£o. Ent√£o, por isso que eu posso usar X no `MemtoReg`. Que saco. Ent√£o, esse aqui √©... n√£o... √© melhor logo n√£o mandar escrever. Quer escrever na mem√≥ria? Bem, n√£o √© o caso. √â melhor logo n√£o mandar escrever. Quero ler da mem√≥ria? Se o endere√ßo estiver desalinhado? N√£o. Porque se tiver desalinhado e tentar ler da mem√≥ria, provavelmente a mem√≥ria vai te retornar um valor dizendo \"olha, eu quero escrever na mem√≥ria...\". Seja o que tiver no banco de registradores. Tamb√©m tem algum erro? Conseguiu alcan√ßar? Vai receber... √â melhor logo n√£o mandar escrever na mem√≥ria. Quando a mem√≥ria tamb√©m n√£o importa... Para voc√™ conseguir no banco de registradores... `ALUOp` tamb√©m. Qual √© o `ALUOp` que eu quero? `ALUOp` n√£o √© X. Ah, n√£o posso apagar. Qual √© o `ALUOp` que eu quero? Eu quero que a ULA calcule a soma. Ent√£o, isso aqui √© `00`. `00`. Imaginem qualquer coisa. `00`. Porque eu preciso que a ULA mantenha o c√°lculo aqui. Ser√° que, mesmo que ele detecte que esse neg√≥cio √© desalinhado, eu preciso que o endere√ßo desalinhado permane√ßa aqui at√© o final da instru√ß√£o? Porque eu vou querer que esse endere√ßo desalinhado seja gravado aqui. Ele tem que permanecer at√© o final, certo? N√£o √© √≥bvio. Ent√£o, vamos l√°. Escreve 'escreve `MTVEC`'? Sim, porque gerou uma exce√ß√£o. E a pr√≥xima instru√ß√£o tem que ser buscada l√° na rotina de tratamento de exce√ß√£o. Seleciona a causa. Qual √© a causa que eu vou colocar? 2, 4 ou 6? A causa agora √© 4. Ent√£o, entrada do meu multiplexador 0, 1. Sabe que eu tenho parti√ß√£o, ent√£o fica dif√≠cil. 0, 1. Escreve causa. Eu quero escrever na causa? Quero. Seleciona valor. Qual √© o valor que eu quero que eu escreva? Que eu escreva no registrador `mtval`? Agora eu quero que o endere√ßo calculado que est√° desalinhado seja escrito no `mtval`. Ent√£o, seleciona `mtval`. Eu quero escrever no `mtval`? Sim, quero. E quero gravar o endere√ßo do `load` que causou isso? Sim, quero. Entendido isso? E agora, se for um `store` desalinhado. Ent√£o, o `store` vai ser mais ou menos igual a essa linha aqui, t√°? Para o `store`, eu preciso calcular o endere√ßo. Ent√£o, eu preciso que o `ALUSrc` seja 1. Afinal.",
        "video_source": "OAC_2022-04-18.mp4"
    },
    {
        "id": 8,
        "timestamp_start": 2937.65,
        "timestamp_end": 2947.66,
        "slide_description": "Como Engenheiro de Computa√ß√£o S√™nior, analisei o slide de uma aula de Arquitetura de Computadores, focando na extra√ß√£o de conte√∫do t√©cnico para um sistema de busca sem√¢ntica (RAG).\n\n**Conte√∫do do Slide:**\n\nO slide apresenta o t√≠tulo principal \"RISC-V Uniciclo\", indicando um diagrama de caminho de dados (datapath) para uma implementa√ß√£o de processador RISC-V de ciclo √∫nico. O cabe√ßalho da apresenta√ß√£o detalha o contexto acad√™mico: \"UnB - CIC0099 - Organiza√ß√£o e Arquitetura de Computadores\", da \"Universidade de Bras√≠lia\", \"Departamento de Ci√™ncia da Computa√ß√£o\", com o nome do professor \"Prof. Marcus Vinicius Camar\".\n\n**Diagrama de Caminho de Dados (Datapath) RISC-V Uniciclo:**\n\nO diagrama ilustra os principais componentes e o fluxo de dados e controle de um processador RISC-V de ciclo √∫nico, estendido com elementos de tratamento de exce√ß√µes.\n\n1.  **Est√°gio de Busca de Instru√ß√£o (IF - Instruction Fetch):**\n    *   O `PC` (Program Counter) armazena o endere√ßo da instru√ß√£o atual.\n    *   Um somador (`Add`) calcula `PC + 4`, que √© o endere√ßo da pr√≥xima instru√ß√£o sequencial.\n    *   O `Instruction memory` recebe o endere√ßo do `PC` e produz a instru√ß√£o de 32 bits (`Instruction [31-0]`).\n    *   M√∫ltiplas anota√ß√µes em vermelho indicam caminhos alternativos para o `PC`, como um `0x00000000` para reset ou vetor de interrup√ß√£o, e uma anota√ß√£o \"TRAP\" sugerindo a entrada em rotina de tratamento de exce√ß√£o.\n\n2.  **Est√°gio de Decodifica√ß√£o e Busca de Registradores (ID - Instruction Decode/Register Fetch):**\n    *   A `Control` unit decodifica o `opcode` (bits `Instruction [6-0]`) para gerar todos os sinais de controle necess√°rios para os demais est√°gios.\n    *   O banco de `Registers` (registrador de prop√≥sito geral) recebe os endere√ßos dos registradores-fonte (`Read register 1` de `Instruction [19-15]` e `Read register 2` de `Instruction [24-20]`) e produz os dados correspondentes (`Read data 1` e `Read data 2`).\n    *   O `Imm Gen` (Immediate Generator) utiliza partes da instru√ß√£o (`Instruction [30,14-12]`) para gerar o valor imediato de 32 bits, que √© utilizado por instru√ß√µes tipo I, S, B, U, J. Anota√ß√µes \"RA\" e \"RB\" est√£o presentes, provavelmente referindo-se aos dados lidos dos registradores.\n\n3.  **Est√°gio de Execu√ß√£o (EX - Execute):**\n    *   A `ALU` (Arithmetic Logic Unit) executa opera√ß√µes aritm√©ticas e l√≥gicas.\n    *   O primeiro operando da ALU √© `Read data 1`.\n    *   O segundo operando da ALU √© selecionado por um multiplexador (`MUX`), que escolhe entre `Read data 2` ou a sa√≠da do `Imm Gen`, controlado pelo sinal `ALUSrc`.\n    *   A `ALU` produz o `ALU result` e um sinal `Zero` (para testes de condi√ß√£o em branches).\n    *   Para opera√ß√µes de branch, um `Shift left 1` √© aplicado ao valor imediato (offset), que √© ent√£o somado ao `PC` por outro `Add` unit para calcular o endere√ßo do alvo do branch.\n\n4.  **Est√°gio de Acesso √† Mem√≥ria (MEM - Memory Access):**\n    *   A `Data memory` realiza opera√ß√µes de leitura ou escrita.\n    *   O `ALU result` √© usado como `Address` para a mem√≥ria de dados.\n    *   Para escritas, `Read data 2` dos registradores √© o `Write data`.\n    *   A `Data memory` produz `Read data` em caso de leituras.\n    *   Os sinais `MemRead` e `MemWrite` da `Control` unit habilitam as opera√ß√µes de leitura e escrita, respectivamente.\n\n5.  **Est√°gio de Escrita de Volta (WB - Write Back):**\n    *   Um multiplexador (`MUX`) seleciona os dados a serem escritos de volta no banco de `Registers`. As op√ß√µes s√£o o `ALU result` ou o `Read data` da `Data memory`, controlado pelo sinal `MemtoReg`.\n    *   O endere√ßo do registrador de destino (`Write register`) pode vir de `Instruction [11-7]` (para tipo R) ou `Instruction [24-20]` (para tipo J, U, I, S, B).\n    *   O sinal `RegWrite` da `Control` unit habilita a escrita no registrador.\n\n**Extens√£o de Tratamento de Exce√ß√µes:**\n\nO diagrama inclui anota√ß√µes em vermelho que indicam um sistema rudimentar de tratamento de exce√ß√µes:\n*   Sinais como `SC` (System Call), `CAUSE` (c√≥digo da causa da exce√ß√£o), `EC` (Exception Code), `EPC` (Exception Program Counter, para salvar o PC da instru√ß√£o que causou a exce√ß√£o), `VAL` e `EV` (Exception Vector) s√£o vis√≠veis.\n*   H√° multiplexadores para `SC` (selecionando entre entradas `0` e `1`) e `EPC` (selecionando entre `0` e `M_1`).\n*   Uma parte da l√≥gica do lado direito mostra `EC` conectada a uma porta AND (`C1`) e um sinal `POST`, sugerindo a ativa√ß√£o do tratamento de exce√ß√£o. Essas anota√ß√µes indicam que o datapath b√°sico foi estendido para lidar com interrup√ß√µes ou exce√ß√µes, desviando o fluxo de controle e salvando o estado do programa.\n\n**Tabela de Sinais de Controle:**\n\nUma tabela detalha os valores dos sinais de controle gerados pela `Control` unit para diferentes tipos de instru√ß√µes:\n\n| Instru√ß√£o  | ALUSrc | Mem2Reg | RegWrite | MemRead | MemWrite | (Coluna n√£o rotulada, presum√≠vel `Branch` ou `PCSrc`) |\n| :--------- | :----- | :------ | :------- | :------ | :------- | :---------------------------------------------------- |\n| Tipo-R     | 0      | 0       | 1        | 0       | 0        | 10                                                    |\n| lw         | 1      | 1       | 1        | 1       | 0        | 00                                                    |\n| sw         | 1      | X       | 0        | 0       | 1        | 00                                                    |\n| beq        | 0      | X       | 0        | 0       | 0        | 01                                                    |\n| *JALR*     | X      | X       | 1        | 0       | 0        | 1001 / 011 (valores incompletos ou multiplos)         |\n| *Lwda*     | 1      | X       | 0        | 1       | 1        | 1011 / 111 (valores incompletos ou multiplos)         |\n| *Swda*     | X      | X       | 0        | 0       | 1        | XXXX (valores incompletos)                            |\n\nAs entradas `X` indicam \"don't care\" (n√£o importa o valor). As √∫ltimas tr√™s linhas (`JALR`, `Lwda`, `Swda`) s√£o anota√ß√µes feitas √† m√£o e podem representar extens√µes ou exemplos espec√≠ficos discutidos na aula, sendo que `Lwda` e `Swda` parecem ser abrevia√ß√µes ou instru√ß√µes hipot√©ticas. A entrada `RegWrite=0` para `Lwda` √© not√°vel e poderia indicar uma opera√ß√£o de load que n√£o escreve em registradores de prop√≥sito geral, ou um erro de transcri√ß√£o.\n\n**Anota√ß√µes e Coment√°rios Adicionais:**\n\nNa parte inferior do slide, h√° a frase \"Quica, taca.\", uma express√£o informal do instrutor. No canto superior direito, h√° uma √°rea com anota√ß√µes adicionais do professor, incluindo n√∫meros e uma representa√ß√£o da l√≥gica para `EC` com uma porta AND, complementando a explica√ß√£o do tratamento de exce√ß√µes.\n\nEm resumo, o slide fornece uma vis√£o detalhada do datapath de um processador RISC-V de ciclo √∫nico, com particular aten√ß√£o aos sinais de controle e uma introdu√ß√£o aos mecanismos de exce√ß√£o, complementado por uma tabela de sinais de controle para instru√ß√µes-chave.",
        "transcription": "Que caca. Que caca.",
        "video_source": "OAC_2022-04-18.mp4"
    },
    {
        "id": 9,
        "timestamp_start": 2947.66,
        "timestamp_end": 2952.02,
        "slide_description": "A imagem exibe uma tela de videoconfer√™ncia de uma aula de Arquitetura de Computadores, apresentando um documento que detalha o plano de ensino da disciplina. O documento, identificado pelo nome de arquivo \"OAC_A_Plano_2021_2_v0.docx\", √© da Universidade de Bras√≠lia, Departamento de Ci√™ncia da Computa√ß√£o, e ministrado pelo Prof. Marcus Vinicius Lamar, cuja imagem aparece no canto inferior direito da tela.\n\nO conte√∫do central √© uma tabela com o cronograma e t√≥picos abordados no curso, divididos por datas e atividades de teoria ou laborat√≥rio, com algumas anota√ß√µes √† m√£o.\n\n**Transcri√ß√£o detalhada do conte√∫do da tabela:**\n\n*   **Linha 7 (7/3, 9/3):**\n    *   Esquerda: Lab 1B: Software ‚Äì Compilador C\n    *   Direita: Lab 1A: Software ‚Äì Kais (16)\n*   **Linha 8 (14/3, 16/3):**\n    *   Esquerda: 1¬™ Prova (P1)\n    *   Direita: Lab 2: Hardware ‚Äì Verilog ‚Äì ULA (T7)\n*   **Linha 9 (21/3, 23/3):**\n    *   Esquerda: 13) Processador Uniciclo: Unidade de Controle (C.4) (L1)\n    *   Direita: 12) Processador Uniciclo: Unidade Operativa (C.4) (T8)\n*   **Linha 10 (28/3, 30/3):**\n    *   Esquerda: 14) Processador Multiciclo: Unidade Operativa (C.4)\n    *   Direita: Lab 3: Processador Uniciclo (T9) (L2)\n*   **Linha 11 (4/4, 6/4):**\n    *   Esquerda: Lab 4: Processador Multiciclo\n    *   Direita: 15) Processador Multiciclo: Unidade de Controle (C.4) (T10)\n*   **Linha 12 (11/4, 13/4):**\n    *   Esquerda: 17) Pipeline: Unidade Operativa e Controle (C.4)\n    *   Direita: 16) Processador Pipeline: Conceitos (C.4) (T11)\n*   **Linha 13 (18/4, 20/4):**\n    *   Esquerda: 18) Exce√ß√£o e Interrup√ß√£o (C.4)\n    *   Direita: Lab 5: Processador Pipeline (T12) (L3)\n*   **Linha 14 (25/4, 27/4):**\n    *   Esquerda: 19.1) Mem√≥ria: Cache (C.5)\n    *   Direita: 19) Mem√≥ria: Hierarquia (C.5) (T13) (L4)\n*   **Linha 15 (2/5, 4/5):**\n    *   Esquerda: Prova Substitutiva\n    *   Direita: 2¬™ Prova (P2) (T14) (L5)\n*   **Linha 16 (parcialmente vis√≠vel, apenas coluna da direita):**\n    *   Direita: Apresenta√ß√£o dos Projetos (Pr) (T15)\n\n**Se√ß√£o \"Avalia√ß√£o\" (vis√≠vel abaixo da tabela):**\n\n*   P1: 1¬™ Prova: 14/03/2022\n*   P2: 2¬™ Prova: 27/04/2022\n\n**An√°lise Visual de Diagramas e Anota√ß√µes:**\n\nN√£o h√° diagramas expl√≠citos de Datapath, Pipeline ou Hierarquia de Mem√≥ria apresentados na forma visual de blocos ou fluxos de dados. O slide √© predominantemente textual, listando esses conceitos como t√≥picos de estudo.\n\nEntretanto, h√° uma anota√ß√£o gr√°fica manuscrita no documento, superposta ao conte√∫do. Uma seta desenhada manualmente aponta do t√≥pico \"15) Processador Multiciclo: Unidade de Controle (C.4) (T10)\" (coluna direita, linha 11) para \"Lab 4: Processador Multiciclo\" (coluna esquerda, linha 11). Adicionalmente, um s√≠mbolo estilizado que se assemelha a um \"T\" ou um visto de confirma√ß√£o est√° desenhado ao lado de \"Lab 4: Processador Multiciclo\". Essas anota√ß√µes indicam uma rela√ß√£o direta e possivelmente uma √™nfase na implementa√ß√£o pr√°tica ou laboratorial do conceito de Processador Multiciclo, conectando a teoria da unidade de controle com a atividade de laborat√≥rio designada.\n\nO conte√∫do aborda temas fundamentais de Arquitetura de Computadores, como a implementa√ß√£o de processadores Uniciclo e Multiciclo, conceitos de Pipeline, tratamento de Exce√ß√µes e Interrup√ß√µes, e a Hierarquia de Mem√≥ria, incluindo Cache. Os laborat√≥rios indicam pr√°ticas com compiladores C, descri√ß√£o de hardware usando Verilog para Unidade L√≥gica Aritm√©tica (ULA) e constru√ß√£o de processadores Uniciclo, Multiciclo e Pipeline.",
        "transcription": "Meu Deus do c√©u! O que aconteceu aqui?",
        "video_source": "OAC_2022-04-18.mp4"
    },
    {
        "id": 10,
        "timestamp_start": 2954.88,
        "timestamp_end": 2987.76,
        "slide_description": "Como Engenheiro de Computa√ß√£o S√™nior, analisei o slide e o contexto da aula de Arquitetura de Computadores conforme a imagem fornecida.\n\nO conte√∫do visual principal, que deveria ser a apresenta√ß√£o ou slide da aula, est√° completamente vazio, exibindo apenas um plano de fundo s√≥lido e escuro. N√£o h√° diagramas, texto, c√≥digo (Assembly, C, Verilog), imagens ou qualquer outro material did√°tico t√©cnico vis√≠vel na √°rea destinada ao conte√∫do da apresenta√ß√£o.\n\nNo entanto, h√° informa√ß√µes contextuais importantes vis√≠veis na interface do sistema de confer√™ncia:\n\n1.  **T√≠tulo da Aula:** Na barra superior do sistema de confer√™ncia, est√° claramente exibido o t√≠tulo \"Sala de Aula de OAC\". \"OAC\" √© uma sigla comum para \"Organiza√ß√£o e Arquitetura de Computadores\", indicando o dom√≠nio da aula.\n2.  **Dura√ß√£o da Sess√£o:** Um contador de tempo \"49:20\" est√° vis√≠vel na barra superior, possivelmente indicando o tempo decorrido ou restante da sess√£o.\n3.  **Participantes:** No painel lateral esquerdo, sob a se√ß√£o \"USU√ÅRIOS (8)\", s√£o listados os participantes:\n    *   Marcus Vinicius Lam... (identificado como \"Voc√™\", sugerindo que esta √© a visualiza√ß√£o do pr√≥prio apresentador ou anfitri√£o da sala, e tamb√©m aparece na barra superior como o foco da c√¢mera/microfone).\n    *   Luiz Carlos Da Sil...\n    *   Eduardo Ferreira ...\n    *   Jo√£o Alberto Trav...\n    *   Marcello Brandao ...\n    *   Maycon Vinnycus...\n    *   Michel Luis Duwe\n    *   Victor Hugo Rodri...\n4.  **Chat (Bate-papo p√∫blico):** O painel lateral esquerdo tamb√©m cont√©m um hist√≥rico de mensagens de chat n√£o t√©cnicas, caracterizando uma intera√ß√£o informal entre os participantes. As mensagens transcritas s√£o:\n    *   \"certo\"\n    *   \"4\" (por Marcello Brandao Sca... e Eduardo Ferreira Mar...)\n    *   \"serio/\" (por Eduardo Ferreira Mar...)\n    *   \"1\" (por Marcello Brandao Sca... e Eduardo Ferreira Mar...)\n    *   \"o da ula\" (provavelmente \"o da aula\", por Marcello Brandao Sca...)\n    *   \"s√≠\" (provavelmente \"sim\", por Eduardo Ferreira Mar...)\n    *   \"quica taca\" (por Marcello Brandao Sca...)\n    *   \"kkk\" (por Eduardo Ferreira Mar...)\n    *   \"√© um funk\" (por Marcello Brandao Sca...)\n    H√° tamb√©m um campo para \"Enviar mensagem para Bat...\".\n5.  **Outras Se√ß√µes da Interface:** As se√ß√µes \"MENSAGENS\" com \"Perguntas\" e \"Bate-papo p√∫blico\", e \"NOTAS\" com \"Notas compartilh...\", indicam funcionalidades da plataforma de confer√™ncia, mas n√£o cont√™m conte√∫do t√©cnico vis√≠vel.\n\nEm resumo, a an√°lise revela que a aula de \"Organiza√ß√£o e Arquitetura de Computadores\" est√° em andamento, com a presen√ßa de um apresentador (Marcus Vinicius) e outros 7 participantes. No entanto, a tela de apresenta√ß√£o est√° vazia, sem qualquer conte√∫do de slide. A informa√ß√£o extra√≠da √© primariamente contextual, baseada nos elementos da interface da plataforma de confer√™ncia.",
        "transcription": "Ai, meu Deus, vamos l√°. Voltemos. Esse √© o problema de botar as coisas muito embaixo no slide. Ent√£o, eu quero que o ALUsrc seja 1 para a ULA. Eu vou querer escrever no banco de registradores? N√£o. Ent√£o, pode ser qualquer. Eu quero escrever no banco de registradores? N√£o. Eu quero ler da mem√≥ria? N√£o. Eu quero escrever na mem√≥ria? Eu quero escrever na mem√≥ria do endere√ßo errado?",
        "video_source": "OAC_2022-04-18.mp4"
    },
    {
        "id": 11,
        "timestamp_start": 2992.87,
        "timestamp_end": 6273.6,
        "slide_description": "Como um Engenheiro de Computa√ß√£o S√™nior, apresento a an√°lise e descri√ß√£o do slide fornecido para um sistema de busca sem√¢ntica (RAG), focando nos detalhes t√©cnicos da arquitetura de computadores.\n\n---\n\n**T√≠tulo Principal do Slide:**\n\"RISC-V Pipeline\"\n\n**Informa√ß√µes do Curso/Institui√ß√£o:**\n\"UnB - CIC0099 - Organiza√ß√£o e Arquitetura de Computadores\"\n\"Universidade de Bras√≠lia\"\n\"Departamento de Ci√™ncia da Computa√ß√£o\"\n\"CIC0099 - Organiza√ß√£o e Arquitetura de Computadores\"\n\"Prof. Marcus Vinicius Lamar\"\n\n**Diagrama Principal: Pipeline de Processamento RISC-V**\nO slide exibe um diagrama detalhado de um *datapath* de pipeline para um processador RISC-V, com foco na detec√ß√£o e tratamento de *hazards* (interdepend√™ncias/perigos). O pipeline √© um design cl√°ssico de 5 est√°gios (Instruction Fetch - IF, Instruction Decode - ID, Execute - EX, Memory Access - MEM, Write Back - WB), interligados por registradores de pipeline.\n\n**Estrutura e Fluxo de Dados por Est√°gio:**\n\n1.  **Est√°gio IF (Instruction Fetch - Busca de Instru√ß√£o):**\n    *   Cont√©m o **PC (Program Counter)**, um registrador que armazena o endere√ßo da instru√ß√£o atual.\n    *   Um somador calcula `PC + 4` (para a pr√≥xima instru√ß√£o sequencial).\n    *   Um multiplexador (Mux) seleciona o pr√≥ximo endere√ßo do PC entre `PC + 4`, o endere√ßo de um *trap vector* (`UTVEC`) ou um endere√ßo calculado para *branch* ou *jump*.\n    *   A **Instruction Memory (Mem√≥ria de Instru√ß√µes)**, que recebe o endere√ßo do PC e fornece a instru√ß√£o para o pr√≥ximo est√°gio.\n    *   H√° um Mux adicional antes do PC, que permite a sele√ß√£o do `PC+4` ou do `UTVEC` ou do endere√ßo de *branch/jump*.\n    *   O registrador de pipeline **IF/ID** armazena o `PC+4` e a instru√ß√£o buscada.\n\n2.  **Est√°gio ID (Instruction Decode - Decodifica√ß√£o de Instru√ß√£o):**\n    *   O registrador de pipeline **IF/ID** passa a instru√ß√£o e `PC+4`.\n    *   A **Control Unit (Unidade de Controle)** recebe o *opcode* da instru√ß√£o e gera sinais de controle para todos os est√°gios do pipeline.\n    *   O **Registers (Arquivo de Registradores)**, que recebe os endere√ßos dos registradores de origem (Rs1, Rs2) da instru√ß√£o e fornece seus valores. Tamb√©m recebe o endere√ßo do registrador de destino (Rd), o dado de escrita e um sinal de *write enable* do est√°gio WB.\n    *   O **Imm Gen (Gerador de Imediato)**, que estende e gera os valores imediatos da instru√ß√£o.\n    *   Um m√≥dulo **Shift left 1** √© vis√≠vel, frequentemente usado para calcular offsets de *branch* (multiplicando por 2, pois endere√ßos de instru√ß√£o RISC-V s√£o alinhados a 4 bytes, e o offset √© dado em meias-palavras).\n    *   A **Hazard Detection Unit (Unidade de Detec√ß√£o de Hazards)** recebe informa√ß√µes de registradores de pipeline (e.g., campos de registradores de leitura e escrita de instru√ß√µes em voo) e gera sinais de controle para estagnar (stall) ou flushar o pipeline quando *data hazards* ou *control hazards* s√£o detectados.\n    *   Um Mux no caminho do `PC+4` seleciona entre `PC+4` e o valor `4` (provavelmente para estagnar o PC em caso de *hazard*), controlado pela unidade de detec√ß√£o de *hazards*.\n    *   O registrador de pipeline **ID/EX** armazena os valores lidos dos registradores, o valor imediato, o `PC+4`, e os sinais de controle gerados.\n\n3.  **Est√°gio EX (Execute - Execu√ß√£o):**\n    *   O registrador de pipeline **ID/EX** passa os dados necess√°rios.\n    *   A **ALU (Arithmetic Logic Unit - Unidade L√≥gica Aritm√©tica)** realiza opera√ß√µes aritm√©ticas e l√≥gicas nos operandos. Seus operandos s√£o selecionados por multiplexadores, que podem receber dados do est√°gio ID ou valores *forwarded* de est√°gios posteriores (EX, MEM, WB) para resolver *data hazards*.\n    *   A **ALU Ctrl (Controle da ALU)** gera o sinal de fun√ß√£o para a ALU com base nos bits de fun√ß√£o da instru√ß√£o e nos sinais da Unidade de Controle.\n    *   A **Forwarding Unit (Unidade de Encaminhamento)** detecta *data hazards* entre as instru√ß√µes em EX, MEM e WB e os operandos da instru√ß√£o atual no est√°gio EX, gerando sinais para os Muxes de entrada da ALU para \"encaminhar\" (forward) os dados corretos dos est√°gios posteriores.\n    *   Muxes adicionais selecionam o segundo operando da ALU (registrador Rs2 ou imediato).\n    *   Um Mux para o `EX.Flush` est√° presente antes do registrador de pipeline `EX/MEM`, indicando a capacidade de invalidar instru√ß√µes neste est√°gio.\n    *   Um Mux para endere√ßos de *branch/jump* √© vis√≠vel, utilizando o `PC+4` e o valor calculado pelo somador da ALU (que pode ser um endere√ßo de *branch*).\n    *   O registrador de pipeline **EX/MEM** armazena o resultado da ALU, o valor do segundo operando do registrador (para *store*), o endere√ßo de destino do registrador, e os sinais de controle relevantes para os est√°gios MEM e WB.\n\n4.  **Est√°gio MEM (Memory Access - Acesso √† Mem√≥ria):**\n    *   O registrador de pipeline **EX/MEM** passa os dados.\n    *   A **Data Memory (Mem√≥ria de Dados)**, que realiza opera√ß√µes de leitura ou escrita. O endere√ßo vem da ALU, o dado a ser escrito vem do registrador Rs2 (via EX/MEM), e o dado lido √© fornecido para o pr√≥ximo est√°gio.\n    *   O registrador de pipeline **MEM/WB** armazena o dado lido da mem√≥ria, o resultado da ALU (para instru√ß√µes que n√£o acessam a mem√≥ria), o endere√ßo de destino do registrador, e os sinais de controle relevantes para o est√°gio WB.\n\n5.  **Est√°gio WB (Write Back - Escrita de Volta):**\n    *   O registrador de pipeline **MEM/WB** passa os dados.\n    *   Um Mux final seleciona o dado a ser escrito de volta no arquivo de registradores: ou o dado lido da Data Memory, ou o resultado da ALU.\n    *   O dado selecionado e o endere√ßo do registrador de destino s√£o enviados de volta para o **Registers (Arquivo de Registradores)** no est√°gio ID, juntamente com o sinal de *write enable*.\n\n**Sinais de Controle e Tratamento de Hazards:**\n*   **Sinais de Flush:** `IF.Flush`, `ID.Flush` (acionado pela Hazard Detection Unit) e `EX.Flush` (vindo da Hazard Detection Unit via unidade de controle principal, ou de algum outro controle de exce√ß√£o) indicam a capacidade de invalidar (zerar) instru√ß√µes nos respectivos est√°gios do pipeline, tipicamente para resolver *control hazards* (branches/jumps mal-preditos) ou exce√ß√µes.\n*   **Hazard Detection Unit:** Recebe entradas de v√°rios registradores de pipeline (IF/ID, ID/EX, EX/MEM) para identificar depend√™ncias de dados e controla a estagna√ß√£o (via Mux no PC) e/ou o *flush* (via `ID.Flush` para o registrador ID/EX) do pipeline.\n*   **Forwarding Unit:** Recebe informa√ß√µes dos registradores ID/EX, EX/MEM, MEM/WB (como o endere√ßo do registrador de destino e o sinal de escrita) para detectar *data hazards* e direcionar os dados corretos (j√° calculados mas ainda n√£o escritos no registrador) para os operandos da ALU.\n\n**Diagramas Auxiliares:**\nNo canto superior direito, h√° dois diagramas simplificados de multiplexadores:\n1.  **Mux de 3 entradas:** Apresenta 3 entradas (rotuladas 0, 1, 2) e uma √∫nica sa√≠da. Ao lado, h√° um texto manuscrito \"CAUX\" (provavelmente 'Controle Auxiliar' ou 'Auxiliar de Chaveamento').\n2.  **Mux de 2 entradas:** Apresenta 2 entradas (rotuladas 0, 1) e uma √∫nica sa√≠da.\nA presen√ßa desses diagramas sugere uma discuss√£o sobre a l√≥gica de multiplexa√ß√£o e possivelmente os sinais de controle associados. H√° tamb√©m dois ret√¢ngulos vazios abaixo do texto manuscrito, que poderiam ser para anota√ß√µes adicionais.\n\n---\nEste conte√∫do √© denso em termos de arquitetura de computadores e processadores RISC-V, abordando aspectos cruciais de design de pipeline, otimiza√ß√£o de desempenho e tratamento de exce√ß√µes/hazards.",
        "transcription": "N√£o, n√©? Ent√£o, aqui √© zero tamb√©m. N√£o quero nem ler, nem escrever na mem√≥ria. √â um *branch*? Tanto faz. O *AWOP*, sim, tem que manter. Eu preciso que a ULA continue calculando a soma para dar o endere√ßo. Ent√£o, vamos l√°. Escreve o *UTVEC*? Quer dizer, seleciona l√° o multiplexador para selecionar o *UTVEC*? Sim. Seleciona a causa. Qual √© a causa? Que √© o *store* desalinhado? √â o 6. Ent√£o, 1 e 0 no multiplexador. Escreve causa? Sim. Seleciona qual √© o valor que eu quero que escreva no registrador de valor? O endere√ßo desalinhado tamb√©m. Ent√£o, √© 1. Escreve *EPC*? Sim. E eu preciso tamb√©m escrever o *EPC* que √© o endere√ßo do *store* desalinhado. Entendido, pessoal? Como √© que a gente gerou todos esses sinais de controle? Quer dizer, ele vai executar tudo como se fosse um *load* ou se fosse um *store*, at√© que ele detecte isso aqui. Quando ele detecta isso aqui, ao inv√©s de ele usar essa linha aqui da tabela verdade, ele passa a usar essa linha da tabela verdade. Certo? At√© o final do ciclo. √â, isso √© desse, desse, desse. √â, esse aqui, esse aqui, esse aqui s√£o iguais. Ent√£o, seriam de 4 controles, 1, 2, 3, 4. Ok. E se, por acaso, n√£o causar exce√ß√£o? Ent√£o, estou usando um tipo R. Tipo R, ele deu o tipo R direitinho, executou o tipo R e n√£o causou exce√ß√£o nenhuma. Ent√£o, a escolha do *UTVEC* tem que ser quanto? 0 ou 1? Quer dizer, qual vai ser o pr√≥ximo endere√ßo se n√£o aconteceu exce√ß√£o nenhuma, no caso do tipo R? Quanto vai ser a escolha? Olha, eu passei o endere√ßo, tem que vir de onde? Do *UTVEC* ou do caminho normal? Isso, do caminho normal. Ent√£o, 0. Eu vou querer escrever causa? Eu vou querer selecionar causa? N√£o, tanto faz, porque eu n√£o vou querer escrever nela. Eu vou selecionar o valor? N√£o, tanto faz, porque eu n√£o vou querer escrever esse valor. E vou querer escrever o *EPC*? Tamb√©m n√£o. 0x, 0x. Se for um *load*, quer dizer, todas as outras instru√ß√µes, se n√£o acontecer nenhuma exce√ß√£o, v√£o ter que gerar esses sinais de sa√≠da aqui. Certo? O tratamento de exce√ß√µes fica desligado. Quer dizer, eu nunca vou selecionar o endere√ßo da exce√ß√£o para ele passar a executar l√°. Ent√£o, se est√° tudo certinho, fica no zero. Quando acontece a exce√ß√£o, a√≠ sim, eu tenho que gravar esse, opa! Gravar o endere√ßo do *UTVEC* no PC ao final do ciclo. E quando tem exce√ß√£o, √© que eu preciso selecionar a causa, escrever a causa, selecionar o valor, escrever o valor e escrever o PC. Quer dizer, escrever o *EPC* esse aqui. Entendido, pessoal? N√£o √© complicado. D√∫vidas? Isso √© dif√≠cil, mas voc√™s entenderam? Eu n√£o iria pedir antes para voc√™s fazerem o neg√≥cio. D√∫vidas? Antes eu vou mostrar como √© que se faz. Mas agora, por exemplo, se eu quiser acrescentar uma nova exce√ß√£o, voc√™s j√° sabem como √©. Ent√£o, voc√™ nunca repete o endere√ßo, n√©? Se n√£o acha exce√ß√£o, ele n√£o vai repetir a leitura, ele vai para o pr√≥ximo endere√ßo para fazer a pr√≥xima instru√ß√£o. Sim, porque todas as instru√ß√µes acontecem em um per√≠odo de *clock*. Certo? Voc√™ l√™ a instru√ß√£o, come√ßa a executar a instru√ß√£o nesse per√≠odo de *clock*. De repente, ele viu que √© uma exce√ß√£o. Da√≠ o sinal de quando ele muda no meio do ciclo de *clock*. Certo? Durante o ciclo de *clock* ele muda de modo que no final do ciclo de *clock* aconte√ßa o que eu quero que aconte√ßa. Ele escrever aqui o endere√ßo do PC, escrever nos registradores. Entendeu? Ent√£o, ele come√ßa a executar a instru√ß√£o como se fosse uma instru√ß√£o normal. A instru√ß√£o inv√°lida. Ele detecta o endere√ßo do PC, ele detecta logo de cara. Certo? Ent√£o, ele j√° logo nesse in√≠cionho do ciclo ele j√° detecta uma instru√ß√£o inv√°lida e faz acertar o controle desse jeito que no final do *clock* √© que ele vai atrasar tudo de acordo com isso aqui. Se for um *load*, ele come√ßa a executar o *load* at√© que ele calcula o endere√ßo e v√™ que o endere√ßo √© desalinhado. Ent√£o, ele passa desse controle que est√° aqui para esse controle que est√° aqui. Por isso que eu digo, √© um *load* e o *load* est√° desalinhado, ou aqui √© um *load* e o *load* n√£o est√° desalinhado. √â um *store*, ele n√£o est√° desalinhado, ele faz isso. √â um *store*, ele est√° desalinhado, ele faz isso. Ent√£o, ele come√ßa a executar tipo isso aqui. Ok? Ok. Ent√£o, o *single-cycle* tranquilinho, n√©? Pr√≥ximo, *multi-cycle*. Ent√£o, est√° aqui o caminho de dados do *multi-cycle* e vamos ver o que a gente precisa modificar. Ent√£o, basicamente as modifica√ß√µes v√£o ser as mesmas, at√© que eu j√° tinha come√ßado a encher aqui, v√£o ser as mesmas do *single-cycle*. Ent√£o, nesse caso, vamos l√°. Nesse caso, a causa. Ent√£o, vamos colocar aqui o sinalzinho, esse aqui que eu seleciono a causa. Esse aqui √© o sinalzinho, seleciona o valor. O valor, ele pode vir de dois lugares. Uma, se a instru√ß√£o for inv√°lida, eu tenho que gravar aqui a instru√ß√£o inv√°lida. Onde que eu tenho a instru√ß√£o inv√°lida? Onde que eu vou conectar isso aqui? No PC? N√£o. √â a instru√ß√£o inv√°lida. Qual √© a instru√ß√£o que eu invalido? A mem√≥ria que foi inv√°lida, que eu preciso armazenar nesse registrador? Isso, no *IR*. Aqui no registrador de instru√ß√µes. Ent√£o, eu posso pegar daqui, aqui, que √© toda a instru√ß√£o e puxar pra c√°. Eita! Olha o *fan-out* a√≠. Ok. Se for um, um *load* e ele descobriu que o *load* ou o *store* est√° desalinhado, eu preciso salvar aqui o endere√ßo. Aonde que eu vou buscar esse endere√ßo que est√° desalinhado? Aonde que eu vou buscar esse endere√ßo que est√° desalinhado? Notem, aqui, o endere√ßo que eu quero, que est√° desalinhado, √© esse aqui. Certo? √â esse endere√ßo aqui que eu quero detectar se est√° desalinhado. Certo? Logo, se eu espero que no PC tenha o valor correto, logo, ent√£o, tem que desalinhado aqui. Ent√£o, onde que eu tenho o endere√ßo desalinhado? Aqui. N√£o, n√£o √© na ULA. Pode ser na ULA, que voc√™ j√° vai detectar os dois. √â, pode ser. Se eu pegar na ULA aqui, eu j√° detecto logo o *load* e o *store*. Isso. Pode ser, t√°? Ent√£o, aqui na sa√≠da da ULA, o que eu vou fazer? Eu vou fazer aquele nosso OR, t√°? Ent√£o, isso aqui √© um OR com os dois *BIT* BIT0 e o BIT1 do endere√ßo. Ok? Exatamente o que a gente fez antes. Um OR BIT0 e BIT1. E onde √© que vai, ent√£o, esse nosso desalinhamento? O *DA* vai l√° pro controle. Vai no controle, que vai ter que ser mais uma entrada aqui. Certo? Ent√£o, al√©m do *opcode*, a gente tem que entrar se o endere√ßo est√° desalinhado ou n√£o. Ok? Aqui, aqui eu calculei o endere√ßo. Ent√£o, aqui eu verifico se o endere√ßo est√° desalinhado ou n√£o. Tranquilo? E se o endere√ßo estiver desalinhado, √© esse endere√ßo que eu coloco aqui. Esse endere√ßo que na subida do *clock*, quando eu estou com o endere√ßo aqui, que na subida do *clock* eu quero gravar ele aqui. Aqui, a mesma coisa do outro. Eu vou botar aqui o multiplexador, aqui 0, aqui 1 e o endere√ßo vai vir pra c√° e aqui eu tenho o escreve *UTVEC*, t√°? O nosso *ET*. Entendido, pessoal? Ok. Ent√£o, isso aqui faz as modifica√ß√µes que eu precisei fazer no caminho de dados. Ainda, o *EPC*. O *EPC*. Qual √© o endere√ßo do PC que causou a instru√ß√£o inv√°lida? Onde que est√° o PC que causou, no caso, a instru√ß√£o inv√°lida ou o *load* inv√°lido? Onde que eu tenho esse endere√ßo aqui? Onde que est√° esse endere√ßo PC? T√°, quando ou a instru√ß√£o foi detectada como inv√°lida, certo? Quem √© que detecta a instru√ß√£o inv√°lida? √â o controle, certo? Ou quando eu descubro que o endere√ßo do *load* do *store* desalinhado, t√° desalinhado. Onde que eu tenho isso, pessoal? S√≥ vou achar em um desses dois lugares. Ou aqui, ou onde? No ponto A do lado de c√°, ou no *operand* B do lado de c√°? Antes do *PCWrite* ou depois do *PCWrite*? Lembrem-se o seguinte: o que que acontece no primeiro ciclo, na primeira etapa do *multi-cycle*? Eu leio da mem√≥ria e disponibilizo aqui, e j√° deixo *PC+4* pronto. De modo que no final do ciclo, *PC+4* √© escrito. Ent√£o, eu vou deixar o *PC+4* pronto e o endere√ßo de *PCWrite* √© escrito para a gente salvar o PC. Logo, onde que eu tenho *PC+4*? Quer dizer, onde eu tenho o valor de PC? N√£o *PC+4* no final do primeiro ciclo? Aqui eu tenho *PC+4* no final do primeiro ciclo. Eu s√≥ li a instru√ß√£o da mem√≥ria. Eu s√≥ vou saber se √© inv√°lida depois, no segundo ciclo. Ent√£o, o que eu tenho que pegar √© o sinal de *PCWrite* aqui. Ent√£o, esse sinal de *PCWrite* √© que eu tenho que colocar para c√°, tanto para instru√ß√£o inv√°lida quanto para o *load/store*. Entenderam isso? Porque passou o primeiro ciclo, aqui eu j√° tenho *PC+4*. E no primeiro ciclo eu s√≥ li a instru√ß√£o, eu nem gravei nos registradores ainda, quer dizer, nem gravei no registrador *IR* desculpa. Certo? Beleza. Ent√£o, agora sim, ligamos o que a gente tinha que ligar no circuito. O que que a gente tem que mudar agora? Al√©m do *datapath*, eu preciso mudar o controle. Certo? Marca aqui o nosso controle que a gente vai modificar agora. Modificar de que forma? Ora, vamos relembrar como √© que esse controle funcionava. Aqui eu li a instru√ß√£o e aqui eu decodificava a instru√ß√£o. Aqui √© que eu sei qual √© o *opcode* da instru√ß√£o. Ent√£o, aqui √© que eu vou poder dizer que o *opcode* √© igual a inv√°lido. Quer dizer, se n√£o for isso, n√£o for isso, o *opcode* √© inv√°lido. Eu tenho que vir para c√°. Ok? Entendido, pessoal? Na segunda etapa, quando eu vou descobrir qual √©, a partir do *opcode*, o que eu tenho que fazer? Qual vai ser o pr√≥ximo, o pr√≥ximo *cycle* √© que eu vou verificar o *opcode*. N√£o √© esse, nem esse, nem esse. Ent√£o, eu tenho que vir para c√°. Ok? Entendido isso? Beleza. E se ele vier para c√°, ent√£o, notem, esse aqui √© o terceiro *cycle*. No terceiro *cycle*, que sinais eu vou ter que modificar aqui para ele fazer o que a gente quer que ele fa√ßa? O que a gente quer que ele fa√ßa, caso seja uma instru√ß√£o inv√°lida, eu preciso selecionar o *ET*, selecionar o *PCWrite* porque se for instru√ß√£o inv√°lida eu quero escrever no PC o valor do *UTVEC*. Certo? Ent√£o, vamos come√ßar por a√≠. Ent√£o, eu vou colocar aqui *ET* igual a 1. Certo? Ent√£o, *ET* igual a 1 e acionar o *PCWrite*. Ent√£o, a primeira coisa, coloquei, selecionei esse, esse multiplexador para ser 1 e acionei o *PCWrite*. No pr√≥ximo *cycle* de *clock* eu j√° vou direto buscar a instru√ß√£o l√° da rotina de tratamento de exce√ß√£o. Beleza. Ok. O que mais que eu preciso fazer, ent√£o, no terceiro *cycle*? Eu preciso gravar esses valores aqui. Certo? Ent√£o, qual √©, qual √©? Selecione a causa. Preciso colocar selecione causa 0 e 0 e acionar o *CauseWrite*. Preciso colocar acionar o *PCWrite*, *ETWrite* e preciso selecionar o valor aqui. Eu quero que a instru√ß√£o seja gravada no *IR*. Selecione *SV* igual a 0. Ent√£o, *SV* igual a 0 e selecione o *ValueWrite*. Ent√£o, aqui eu t√¥ dizendo que a pr√≥xima instru√ß√£o vai do endere√ßo l√° da rotina de tratamento de sinal, rotina de tratamento de exce√ß√£o, e for√ßa escrita no PC. E depois fa√ßa *SC* igual a 0 e *CauseWrite*, *PCWrite*, aciona *CauseWrite*, aciona *PCWrite*, fa√ßo a sele√ß√£o do valor igual a 0. √â s√≥ 1, n√©? S√≥ 0, meu Deus, s√≥ 0 e aciona o *ValueWrite*. Entendem, pessoal? Ent√£o, para instru√ß√£o inv√°lida, ele detectou que a instru√ß√£o √© inv√°lida, ele vem pra, faz tudo isso que ao final do ciclo esse registrador vai ser escrito, esse registrador vai ser escrito, o *EPC* vai ser escrito, o *EPC* vai ser escrito e o *VAL* tamb√©m vai ser escrito. Causa vai ser escrito, *EPC* vai ser escrito e o *VAL* vai ser escrito. E volta a formular pro primeiro, n√©, para colocar novamente a instru√ß√£o um *load* e um depois que est√° no PC. Certo? Beleza. Ent√£o, o pr√≥ximo, pr√≥ximo. Eu li a instru√ß√£o, decodifiquei a instru√ß√£o e descobri que a instru√ß√£o √© um *load* ou √© um *store*. Ent√£o, ele veio para c√°. Ent√£o, agora aqui eu vou ter que, eita, t√¥ faltando duas coisinhas aqui agora. Esse aqui √© o caminho original, n√©? Ent√£o, agora aqui √© que eu calculo o endere√ßo, nessa etapa que eu calculo o endere√ßo. Ent√£o, nessa etapa, ao final dessa etapa, eu j√° sei se eu tive o endere√ßo desalinhado ou n√£o. Certo? E esse endere√ßo desalinhado, que √© o nosso *DA*, n√©, desalinhado, ele t√° entrando no controle. √â esse aqui, √≥, nosso *DA*. Ele t√° entrando no controle. Ent√£o, aqui eu posso fazer ent√£o uma escolha: se o *load* for um *store* e talvez venha em cima, t√°, porque sen√£o fica meio ruim aqui, o *DA* estiver desalinhado. Esse aqui √© um E, t√°? Comercial. Pelo amor de Deus, que coisa feia. Esse aqui √© um AND. Ent√£o, esse endere√ßo, se o *load* for de um *store* e o *DA* estiver desalinhado, ele segue normalmente o *store*. Se for um *load* e o afinal e o *DA* tiver desalinhado, ent√£o, *DA* barra. Ent√£o, ele segue o *load* normal. Certo? Porque nessa est√° exatamente isso a√≠, s√≥ que barra em cima de tudo, t√°? Ent√£o, ele segue o *store* normal e o *load* normal. Se for um *load* e o *DA* tiver acionado, eu vou para esse pr√≥ximo estado. Se for um *store*, se o *store* for um *store*, se for um *store* e o *DA* tiver acionado, eu venho para c√°. Ok? Ent√£o, notem que aqui, ao calcular o endere√ßo, eu j√° sei para onde que eu vou ter que ir. Ok? Calculei o endere√ßo e j√° vou ter o valor de, a√≠ eu j√° sei se eu tenho que vir para c√°, para c√°, ou para c√°. Ent√£o, beleza. Vamos supor que seja um *load* e o endere√ßo esteja desalinhado. O que que eu vou ter que fazer, ent√£o? Notem que a gente vai fazer isso aqui, √≥. A gente vai ter que fazer outra coisa tamb√©m, t√°? Ah, n√£o precisa. Lembrem-se que todos os sinais que n√£o est√£o aqui s√£o setados como zero. Ah, quanto √© que vale o *CauseWrite*, *ValueWrite*, *ETWrite*? Aqui, todos eles s√£o zero porque n√£o est√£o descritos na bolinha. Certo? Ent√£o, isso facilita muito esse nosso projeto aqui. Sempre que eu n√£o escrever essas carinhas aqui, eles n√£o s√£o acionados. Certo? Assim como o *ET*, o *ET* tamb√©m s√≥ √© acionado aqui. Todos os outros o *ET* vale zero. Quer dizer, eu n√£o coloco o endere√ßo do *UTVEC* para ser escrito no pr√≥ximo PC. Ok? Ent√£o, o que que vai ter aqui dentro? Vai ter isso aqui. O que que vai mudar? A causa n√£o vai ser zero zero, vai ser zero um. E o que salva aqui n√£o √© zero, √© um. T√°? Ent√£o, vai ter todos esses sinais aqui, aqui dentro. A √∫nica coisa que vai ter de diferente, deixa eu ver, a √∫nica coisa diferente √© que seleciona causa vai ser zero um e seleciona valor vai ser um. Todos esses outros sinais t√™m que ser igual. Ent√£o, aciona o *ET*, aciona *CauseWrite*, *PCWrite*, *ETWrite*. Certo? Tudo isso aqui. S√≥ muda os sinais de escolha. Seleciona a causa tem que ser um e o que vai ser escrito aqui tem que ser um. Ok. Putz, n√£o, aqui √©, aqui √© o *load*, aqui √© o *store*. Ent√£o, t√°. Ent√£o, aqui no *store* o que que vai ter? A mesma coisa, t√°? S√≥ que a causa vai ser dois. O resto √© tudo igual. Vamos l√°. Cad√™, cad√™, cad√™, cad√™, cad√™, cad√™, cad√™? Vou ter, vou ter, vou ter seleciona causa igual um e zero. Vou ter seleciona valor igual a um. Vou ter *CauseWrite*, *PCWrite* e *ETWrite*. Certo? Entendido? Modificamos o nosso controle. Tivemos que colocar tr√™s estados a mais por causa das tr√™s novas condi√ß√µes que o processador tem que funcionar. Ok? D√∫vidas? N√£o? N√£o. Podemos continuar, n√©? Tranquilo, pessoal. Que bolhas aqui no *single-cycle* n√£o tem bolhas, n√©? J√° queres bolha? Ent√£o, a gente vai pro agora sim v√£o aparecer as bolhas, tchan, tchan, tchan, tchan. Oh no. Para quando eu precisar da mesma instru√ß√£o. *Worxem*, t√°? Ent√£o, agora o que eu preciso acrescentar de *hardware*? Notem que aqui na figurinha do Patterson, ele j√° colocou o *UTVEC*, √≥. O *UTVEC* j√° t√° ali no nosso registradorzinho. Ent√£o, nem preciso ganhar isso. S√≥ vou ter que alterar aqui esse controle aqui, agora ao inv√©s de ser 1 bit, v√£o ser 2 bits, ok? Entendido isso, pessoal? Ent√£o, isso aqui poderia ser, por exemplo, a entrada 0 e 1, a entrada, essa aqui de baixo, 1 e 0, que quando deveria ser 0 e quando deveria ser 1, e essa aqui do meio, 0 e 0, 0 e 1, e essa do meio aqui, 1 e 0, t√°? De modo que o primeiro bit funciona como a sele√ß√£o original desse multiplexador, n√©? 0 √© o *PC+4*, que vira 0. 0 √© o *PC+4*, que vira 0. 0 √© o *PC+4*, que vira 0 que vem pra c√°. 1 √© o endere√ßo do *BEC* e do *JAL*. E agora eu tenho, n√©, esse 1, 0, n√©, que seleciona o *UTVEC*. Beleza. Ent√£o, sabe pra que que eu escrever aqui? Se eu preciso escrever aqui, t√°? Ent√£o, o *UTVEC* j√° t√° aqui, t√° aqui nos 3 registradores, n√©, que eu n√£o dei aqui. Esse aqui √© o *CAUSE*, que tem o *CauseWrite*. Esse aqui √© o *EPC*, aqui tem o *EPCWrite*. Aqui tem o *ValueWrite*. Aqui est√° ligado aqui, aqui est√° ligado aqui. Ent√£o, vamos l√°. Seguinte, primeiro, se for uma instru√ß√£o inv√°lida, quer dizer, causa igual a 2, 4 ou 6. Da onde que vem esses dois valores? Esse aqui √© a instru√ß√£o inv√°lida e esse aqui √© o endere√ßo inv√°lido. Ent√£o, quando eu tenho uma instru√ß√£o inv√°lida, onde, em que est√°gio do *pipeline*, eu detecto que a instru√ß√£o √© inv√°lida? E aqui tem que vir a instru√ß√£o. N√£o, √© um est√°gio e n√£o um registrador, Marcelo. Tu colocou a√≠ o nome desse registrador aqui. Eu quero saber em qual est√°gio, no est√°gio IF, no est√°gio ID, no est√°gio EX, no est√°gio MEM ou no est√°gio *WRITEBACK*? Nesse, porque aqui √© que est√° sendo feita a decodifica√ß√£o, o controle est√° aqui. Ent√£o, se o controle est√° aqui, nesse est√°gio √© que ele pode detectar se aconteceu a instru√ß√£o inv√°lida. Por exemplo, acionar aquele sinalzinho, j√° √© com a instru√ß√£o inv√°lida. Ent√£o, √© nesse est√°gio aqui. Eu vou clicar aqui no *output* e detectar, opa, aconteceu uma instru√ß√£o inv√°lida. Ent√£o, se aconteceu uma instru√ß√£o inv√°lida, onde que est√° a instru√ß√£o em si? Onde est√° a instru√ß√£o? Aqui, olha. Eu li a instru√ß√£o da mem√≥ria e gravei ele aqui nesse registrador. Ent√£o, aqui eu tenho a instru√ß√£o nesse ponto. Ent√£o, eu vou pegar desse ponto e levar para l√°. Beleza? Notem, o que o controle tem que fazer? Eu n√£o fiz nada, meu tio. Eu, hein? O que o controle tem que fazer? Uma vez que ele detectou que a instru√ß√£o √© inv√°lida? O que o controle precisa fazer no instante que ele detectou que a instru√ß√£o √© inv√°lida? Botar o endere√ßo no *UTVEC*. Quer dizer, para eu botar o endere√ßo no *UTVEC*, isso s√≥ vai acontecer no pr√≥ximo ciclo de *clock*. Logo, a instru√ß√£o que j√° est√° aqui, eu preciso matar essa instru√ß√£o aqui. √â como se fosse um *JAL*, certo? Um *JAL*, eu preciso acionar esse *flush*. Aqui, olha. Meu Deus do c√©u. Meu Deus do c√©u. Eu preciso acionar esse sinal de *flush* aqui, que √© o controle que gera. Certo? Certo? Ent√£o, acionando esse... Esse sinal de *flush*, ele vai escrever, ent√£o, no *IF/ID*, uma bolha. A de X0, X0, 0. Certo? √â isso que o *flush* faz. Beleza? E vai ter que acionar esse multiplexador para ser. Esse aqui √© 0, 0, 0, 1. E esse aqui √© 1, 0. Ent√£o, ele tem que acionar esse sinalzinho aqui. Para ser 1, 0. Agora, como √© que era o controle do *pipeline* mesmo? O controle do *pipeline* era o mesmo controle do *single-cycle*. Certo? Ent√£o, a gente s√≥ tem que pegar aquela tabela do *single-cycle*, a mesma tabela do *single-cycle*, e colocar os sinais em seus respectivos status. √â isso que a gente tem que fazer. A√≠, no *single-cycle* l√°, quando a gente fez, a gente acrescentou um outro multiplexador aqui. A gente tinha que acrescentar... √â, esse aqui, sim. Tinha acrescentado esse multiplexador. Certo? Ent√£o, ao inv√©s de a gente estar usando agora esse multiplexador, a gente est√° selecionando... Esse multiplexador aqui tem que vir do *EPC*. Ent√£o, a gente tem que acionar o *flush*. Tem que colocar nessa se√ß√£o desse multiplexador aqui, 1, 0. Certo? De modo que... No pr√≥ximo ciclo de *clock*, a instru√ß√£o que ele vai ler vai ser l√° do *TREC*, e a bolha que eu tinha colocado aqui vai para a frente. Ok? Ent√£o, detecto a instru√ß√£o inv√°lida aqui no est√°gio ID. Ent√£o, aqui no est√°gio ID, √© que eu tenho que mandar e selecionar o *SV* igual a 0. O *SC* igual a 0 tamb√©m, 0, 0, 0, 0. Acionar o *CauseWrite*. Ah, a gente esqueceu de ligar aqui o *EPC*. De onde que vem esse *EPC*? De onde que vem esse *EPC*? Eu preciso pegar o endere√ßo onde estava essa instru√ß√£o. Onde √© que est√° o endere√ßo onde estava essa instru√ß√£o? √â o PC. Aqui, olha. Aqui eu pego o PC e passo para o est√°gio seguinte. Ent√£o, aqui eu vou ter esse endere√ßo do PC, certo? Depois do *IF/ID*. √â nesse ponto aqui, nesse fio aqui. Aqui eu tenho o endere√ßo PC da instru√ß√£o que causou a instru√ß√£o inv√°lida. At√© a√≠ tudo bem? Ok. E esse aqui tem que ser qual? Tem que ser o endere√ßo. Tem que ser o endere√ßo. Tem que ser o endere√ßo. Tem que ser o endere√ßo. Tem que ser o endere√ßo. Tem que ser o endere√ßo inv√°lido de um *load* ou *store*, um endere√ßo desalinhado, certo? Onde que est√° o endere√ßo desalinhado? Quando que eu tenho o endere√ßo dispon√≠vel para endere√ßar a mem√≥ria? Aqui, certo? Ent√£o, aqui √© o *EX/MEM*. Aqui eu tenho o endere√ßo que vai ser endere√ßado √† mem√≥ria. Ent√£o, eu posso pegar esse endere√ßo daqui. Ou eu posso pegar... Eu posso pegar esse endere√ßo daqui. Que a princ√≠pio, se eu pegar o endere√ßo daqui, eu vou ter que matar uma, duas, tr√™s instru√ß√µes. Se eu pegar o endere√ßo daqui, eu tenho que matar s√≥ duas instru√ß√µes. Por qu√™? Quando eu der o endere√ßo inv√°lido, eu tenho que mandar ler a instru√ß√£o desse endere√ßo. Ent√£o, essas duas instru√ß√µes que foram lidas, eu vou ter que matar. Se eu pegar o endere√ßo daqui, eu vou ter que matar essa aqui tamb√©m. Certo? Ent√£o, vamos tentar. Vamos tentar pegar o endere√ßo daqui. Certo? Isso aqui √© o endere√ßo para *loads* e *stores*. Ent√£o, desalinhado. Como √© que eu sei que o endere√ßo √© desalinhado? Como √© que eu sei que o endere√ßo aqui est√° desalinhado? Dizendo a mesma coisa. Um OR desses primeiros dois bits aqui. Tamb√©m vou escrever. Beleza? Um OR desses primeiros dois bits desse endere√ßo, eu descubro que est√° desalinhado. Nosso *DA*. Por isso que eu n√£o escrevi aqui. Que √© endere√ßo desalinhado. Ent√£o, aqui √© esse aqui. E aqui est√° o *DA*. Muito bem. Eu descobri nesse est√°gio que o endere√ßo est√° desalinhado. O que eu preciso fazer? Melhor. Eu descobri que aqui o endere√ßo est√° desalinhado. Eu vou precisar salvar esse endere√ßo no *EPC*. Onde que eu tenho o endere√ßo dessa instru√ß√£o aqui? Que est√° nesse est√°gio. Onde que eu tenho, nesse est√°gio, o endere√ßo *load* ou do *store* que causou esse desalinhamento? Eu tenho o endere√ßo PC nesse est√°gio. E o *DST* √© o registrador. Eu tenho o PC nesse est√°gio? N√£o. O PC eu tenho nesse est√°gio. Passo para frente. Eu tenho o PC nesse est√°gio. Por isso que eu n√£o completei aqui. Porque se eu ligar isso aqui direto aqui. Quando for o endere√ßo desalinhado. Desalinhado. Ele vai estar pegando o endere√ßo errado. Ele est√° pegando o endere√ßo anterior. Da instru√ß√£o que veio seguinte. Ao *load* ou *store* desalinhado. Ent√£o como que eu fa√ßo para ter o endere√ßo PC aqui? Dif√≠cil, pessoal. N√£o √© s√≥ eu pegar o valor de PC. Esse aqui. Esse aqui √© o valor de PC. E jogar ele para o registrador aqui. De modo que nesse est√°gio. Aqui eu tenho o valor do PC. Da instru√ß√£o que est√° aqui. Que deve ser um *load* ou um *store*. E que vai detectar se o endere√ßo est√° desalinhado. N√£o tem. Tem que colocar esse filtro. Ent√£o o PC est√° passando para frente aqui. S√≥ calcular o endere√ßo do *branch* do *JAL*. Mas agora eu quero pegar esse PC tamb√©m. Jogar para frente. Para quando o *load* ou *store* estiver nesse est√°gio. Quer dizer, nessa etapa. Eu posso usar esse endere√ßo aqui em cima. Ent√£o notem. Da onde que vem o PC aqui? Esse PC que vai vir aqui. Vem daqui. Quando eu tenho uma instru√ß√£o inv√°lida. Ou vem daqui. Eu tenho um *load* ou um *store* inv√°lido. Exato. Vem ou. A√≠ no caso Marcelo. Eu tenho um *load* ou um *store* inv√°lido. Exato. Vem ou. A√≠ no caso Marcelo. √â registrador. Ou vem do registrador *IF/ID*. Aqui. Ou vem daqui. Do registrador *ID/EX*. Logo. Isso aqui pode vir de duas. Duas. Duas partes diferentes do circuito. O que eu vou fazer aqui ent√£o. J√° que ele pode vir daqui. Ou pode vir dali. Se algu√©m disser. Coloca um ou a√≠. Ele iria matar. Isso mesmo. Com um *Mux* aqui. Ent√£o selecionando 0. Ou selecionando 1. Se eu selecionar 0. Eu vou pegar. Esse endere√ßo aqui. Se eu selecionar 1. Vou pegar esse endere√ßo aqui. Ok. E vamos fazer uma coisa aqui. Que n√£o √© muito boa. T√°. Em termos de projeto. Qual √© o sinal que controla. Esse multiplexador. Que saco. Pena que eu n√£o posso apagar. Qual √© o sinal que controla. Esse multiplexador aqui. Tem algum sinal desses. Que a gente j√°. Tenha gerado. Que controla esse multiplexador. √â assim. Exato. Ent√£o no *SV*. Se for 0. Eu vou gravar a instru√ß√£o. E vou selecionar o PC. Daqui. Se o *SV* for 1. Eu vou gravar. O endere√ßo desalinhado. E vou pegar o PC. Daqui. Ent√£o esse aqui. √â o mesmo sinal *SC*. Isso n√£o √© muito. N√£o √© uma boa pr√°tica. O bom √©. Tu criar um novo sinal. Para esse ali. T√°. Por exemplo. Seleciona. *EPC*. Aqui no final. Vai dar. Seleciona. *EPC*. Igual. *SV*. T√°. Entendido. Por que. Que eu preciso fazer isso. Ali. N√£o √© controle. Menor. Menor. Menor que isso. Pode ser. T√°. Mas fica mais. Dif√≠cil. De dar manuten√ß√£o. A um circuito. Desse tipo. Que se mexer. Num sinal. Aqui. Que t√° mexendo. Tamb√©m. Nesse sinal. Isso aqui. √â o que eu chamo. De efeito colateral. T√°. Mexo. Nesse sinal. Ent√£o. Quero selecionar. O valor. A√≠. Ao mesmo tempo. Eu t√¥. Selecionando. O valor. De. Do. PC. Aqui. Se. For. Outra. Pessoa. Ele. Vai. Pensar. Pra. Que. Que. Tem. Esse. V. Aqui. N√©. Bom. Ok. Vamos l√°. Ent√£o. Revisando. Se. For. Instru√ß√£o. Inv√°lida. O que. Que. Vai. Acontecer. Ent√£o. Tem. Que. Acionar. Escrever. O. PC. T√°. Pra. Ir. Aqui. No. Pr√≥ximo. Ciclo. De. Clock. A. A. Mem√≥ria. Vai. Ler. Esse. Endere√ßo. Que. √â. L√°. Da. Rotina. De. Tratamento. Tem. Que. Dar. Um. *Flush*. Ent√£o. Eu. Detectei. Instru√ß√£o. Inv√°lida. Aqui. Eu. Tive. Que. Acionar. Essa. Bolha. Transformar. Isso. Aqui. Numa. Bolha. E. O. Que. Eu. Vou. Fazer. Com. Ent√£o. Eu. Tenho. Que. Dar. Um. *ID.Flush*. Esse. Sinalzinho. Aqui. Ent√£o. *Flush*. No. *ID*. Quer. Dizer. Colocar. Todos. Os. Controles. Desse. Que. Eu. Ia. Fazer. Como. Zero. Se. Eu. Ent√£o. Quando. Eu. Detecto. Isso. Eu. J√°. Tenho. Que. Acionar. O. *ID.Flush*. Acionar. O. *IF.Flush*. Para. Que. Essa. Instru√ß√£o. Se. Transforme. Numa. Bolha. E. Eu. Mate. A. Ok. Ok. Isso. Para. Instru√ß√£o. Inv√°lida. Ent√£o. Acrescento. Duas. Bolhas. Tem. Que. Fazer. Isso. N√£o. Tem. Bom. E. Se. Por. Acaso. O. Endere√ßo. For. Desalinhado. Ent√£o. Eu. Li. O. Certo. Certo. Ent√£o. Quando. Tiver. Nessa. Etapa. Aqui. Est√°. Calculando. O. Endere√ßo. E. Descobrir. Que. O. Endere√ßo. Est√°. Desalinhado. O. Que. Que. O. Controle. Vai. Ter. Que. Fazer. No. Ciclo. Ent√£o. Preciso. Dar. O. *Flush*. No. *IF/ID*. Preciso. Dar. Um. *Flush*. No. *ID/EX*. Matar. A. Instru√ß√£o. Que. Est√°. Aqui. Tamb√©m. E. Essa. Instru√ß√£o. *Load*. Desalinhada. Tamb√©m. Tem. Que. Quer. Dizer. Escrevendo. O. Registrador. Um. Note. Eu. Dou. Um. *Flush*. No. *ID*. Colocando. Os. Controles. Do. *ID*. Aqui. Como. Zero. Como. √â. Que. Eu. Dou. Um. *Flush*. No. Para. Mem√≥ria. E. Zero. Para. Todos. Os. Controles. *Write Back*. Ent√£o. Aqui. Eu. N√£o. Vou. Permitir. Escrever. Na. Mem√≥ria. Nem. Ler. Na. Mem√≥ria. E. Eu. N√£o. Vou. Permitir. Escrever. Neste. Est√°gio. Aqui. Entendido. Isso. Pessoal. Est√°. A√≠. As. Nossas. Implementa√ß√µes. N√£o. Tem. Nenhum. S√≥. N√£o. Escrevi. A. Tabelinha. Verdade. Aqui. Porque. Eu. Nunca. Tive. Oportunidade. De. Entrar. A fundo. Na. 15. Como. 19. √â. Complicado. Certo. Ent√£o. Essa. Que. √â. Efetivamente. A. Aplica√ß√£o. Que. Eu. Tenho. Que. Fazer. Agora. A. Tabelinha. Na. Tabelinha. De. Controle. Com. Todos. Esses. Sinais. Olha. T√°. Eu. Eu. Eu. N√£o. Estou. E. Mais. Eu. Escrevi. E. Se. Ele. Tem. Se. For√ßado. A. Ser. Que. Vai. Escrever. Esse. √â. S√≥. Selecionar. Aqui. Eu. N√£o. Tr√™s sinais ali e mais o *EPC*. Esse aqui. √â uma boa pra voc√™s fazerem a tabela. T√°? Tabela. Que √© a mesma tabela do, a mesma tabela do *single-cycle* com essas tr√™s outras situa√ß√µes aqui. Certo? Al√©m desses sinais aqui de controle, tu tem que colocar o *IF.Flush*, o *ID.Flush* e o *EX.Flush*. A√≠ tr√™s sinais a mais aqui. T√°? Sinais que o controle tem que gerar. Al√©m de todos esses aqui. Certo? Quanto que tem que dar o *ID.Flush*, o *IF.Flush*? Nesse caso tu d√° o *ID.Flush* e tu n√£o d√° quando a instru√ß√£o √© inv√°lida. Quanto que vai dar o *ID.Flush*, o *IF.Flush* e o *EX.Flush*? N√©? Assim que t√°, pode fazer isso aqui. Ent√£o, vamos chamar isso aqui de *FLUSH*, o est√°gio *ID.FLUSH*, o *EX.FLUSH*, t√°? Jesus, olha s√≥ o cara que me escreve reto. T√°? Esse aqui vai estar sempre tudo zero. Porque se a instru√ß√£o est√° rodando normalmente, n√£o tem que dar *FLUSH* em nada aqui. Certo? Esse aqui tem que ser o *IF.FLUSH*. Esse aqui tem que ser o *IF.FLUSH* se acionado e *ID.FLUSH* se acionado. E esse aqui o *IF.FLUSH* e *ID.FLUSH*. E o *EX.FLUSH*. Opa, eu t√¥ escrevendo e a gente n√£o deve. E o *EX.FLUSH* √© aqui. Um e esse aqui √© o *ID.FLUSH*. Beleza. Ent√£o, aqui tamb√©m √© um. T√°? Ent√£o, por instru√ß√£o inv√°lida, eu tenho que dar um *FLUSH* no *IF* e um *FLUSH* no *ID*. E n√£o preciso dar *FLUSH* no *EX*. Mas, quando eu tenho *LOAD* e *STORES* desalinhados, j√° que eu dei a entrada do controle agora, eu tenho que dar *FLUSH* nos tr√™s aqui. Certo? Pronto, t√° a√≠ a tabela. Tranquilo, n√©? A tabela do. Ent√£o, pode ser, parecer complicado, mas √© tranquil√≠ssimo. Gostei, Eduardo. Tranquiliss√≠ssimo. Ok? D√∫vidas? Agora tem que fazer uma prova sobre isso. Sim. Pessoal, sei que voc√™s est√£o muito atarefados, n√©? Mas, quem tiver um tempinho e quiser assistir a apresenta√ß√£o do *PAETIN*, por acaso, respondo a presen√ßa de voc√™s do *PAETIN* hoje tamb√©m. E hoje √© dia, mas n√£o √© testinho. Ent√£o, respondam a presen√ßa l√° no Aprender tamb√©m. Ok? Tem que ser, n√©? Porque √© aquele tipo de mat√©ria. Se o professor quiser tornar ela imposs√≠vel de passar, basta duas vezes, da√≠ um pouco todos j√° se quebram. Certo? Agora que acabou a aula, quero saber se o meu grupo s√≥ desistiu da mat√©ria a√≠, o que que eu fa√ßo? Faz o projeto final sozinho. Ah, meu Deus. Posso me juntar num grupo, n√£o? Ah, meu Deus. O Luiz Carlos j√° deu a dica pra voc√™s que o jogo √© dificilmente zer√°vel, n√©? Mas eu n√£o consigo fazer o jogo n√£o. Isso √© verdade. Pega l√°, sei l√°, pega dois diazinhos a√≠ seu. Eu sei que √© dif√≠cil, mas pega dois dias, bota m√∫sica, hist√≥ria, faz o relat√≥rio, c√™ j√° ganha. J√° √© quatro pontos, j√° √© quatro ponto a√≠ quase. S√≥ o relat√≥rio j√° √© dois pontos. Tr√™s pontos, dois pontos, dois de relat√≥rio, meio de m√∫sica, meio de hist√≥ria. Ent√£o, j√° tem tr√™s pontos a√≠ pra voc√™ fazendo s√≥ isso. Bem-vindo. N√£o, eu queria dizer que s√≥ o relat√≥rio j√° √© dois, ent√£o s√≥ de fazer o relat√≥rio e mais. Ent√£o, se eu fizer dois, voc√™ tem que fazer dois. A√≠, a√≠ os tr√™s pontos. Ent√£o, eu fiz um bot√£o aqui, hein? Sim, sim, sim. E agora √© meio ponto de m√∫sica e meio ponto de hist√≥ria. Voc√™ fica com tr√™s pontos. Brava. √â, tirar dez na P3, entendi. T√° bom. Fede que se o grupo desistir, n√£o √© s√©rio. T√°, pessoal, vou parar a grava√ß√£o aqui ent√£o, porque eu j√°",
        "video_source": "OAC_2022-04-18.mp4"
    },
    {
        "id": 12,
        "timestamp_start": 6273.6,
        "timestamp_end": 6280.64,
        "slide_description": "Como um Engenheiro de Computa√ß√£o S√™nior, procedi √† an√°lise do slide de Arquitetura de Computadores. Abaixo, detalho o conte√∫do visual para um sistema de busca sem√¢ntica, priorizando a informa√ß√£o t√©cnica e densidade.\n\n---\n\n**T√≠tulo do Slide:** RISC-V Pipeline\n\n**Informa√ß√µes da Aula/Curso (canto superior direito):**\nUnB ‚Äì CIC0099 ‚Äì Organiza√ß√£o e Arquitetura de Computadores\nDepartamento de Ci√™ncia da Computa√ß√£o\nProf. Marcus Vinicius Lamar\nUniversidade de Bras√≠lia\n\n**Diagrama Principal: Datapath de Pipeline RISC-V de Cinco Est√°gios com Detec√ß√£o e Encaminhamento de Hazards e Suporte a Exce√ß√µes/Interrup√ß√µes**\n\nO diagrama representa um pipeline cl√°ssico de cinco est√°gios para a arquitetura RISC-V, complementado com unidades para lidar com hazards de dados e controle, al√©m de componentes para tratamento de exce√ß√µes e interrup√ß√µes.\n\n**Estrutura e Fluxo de Dados por Est√°gio:**\n\n1.  **Est√°gio IF (Instruction Fetch - Busca de Instru√ß√£o):**\n    *   **PC (Program Counter):** Registrador que armazena o endere√ßo da instru√ß√£o atual. √â alimentado por um multiplexador (Mux) que seleciona entre:\n        *   PC + 4 (pr√≥xima instru√ß√£o sequencial).\n        *   Endere√ßo de desvio (branch target) ou salto (jump target), calculado a partir do est√°gio EX.\n        *   Endere√ßo de tratamento de exce√ß√£o/interrup√ß√£o, como o **UTVEC** (User Trap Vector, anotado em vermelho), que direciona para a rotina de interrup√ß√£o/exce√ß√£o.\n    *   **Instruction Memory:** Recebe o endere√ßo do PC e fornece a instru√ß√£o correspondente.\n    *   **Registrador de Pipeline IF/ID:** Armazena a instru√ß√£o buscada e o PC + 4 para o pr√≥ximo est√°gio.\n    *   **Sinal IF.Flush (anotado em vermelho):** Ativado pela Hazard Detection Unit para invalidar a instru√ß√£o sendo buscada, tipicamente ap√≥s um branch mal previsto ou uma exce√ß√£o.\n\n2.  **Est√°gio ID (Instruction Decode - Decodifica√ß√£o de Instru√ß√£o):**\n    *   **Registrador de Pipeline IF/ID:** Fornece a instru√ß√£o e PC + 4.\n    *   **Registers (Register File):** L√™ os valores dos registradores-fonte (rs1, rs2) conforme especificado na instru√ß√£o.\n    *   **Imm Gen (Immediate Generator):** Gera o valor imediato para a instru√ß√£o, dependendo do tipo da instru√ß√£o (I-type, S-type, B-type, U-type, J-type).\n    *   **Control Unit:** Decodifica o opcode da instru√ß√£o e gera todos os sinais de controle para os multiplexadores e unidades funcionais nos est√°gios seguintes. Interage com a Hazard Detection Unit.\n    *   **Hazard Detection Unit:** Monitora os registradores-fonte e destino para detectar hazards de dados e controle. Gera sinais de stall e flush.\n    *   **Sinal ID.Flush (anotado em vermelho):** Ativado pela Hazard Detection Unit para invalidar a instru√ß√£o no est√°gio ID, geralmente para lidar com branches, jumps ou exce√ß√µes.\n    *   **Registrador de Pipeline ID/EX:** Armazena os valores dos registradores lidos, o valor imediato, os sinais de controle e outras informa√ß√µes para o est√°gio de execu√ß√£o.\n\n3.  **Est√°gio EX (Execute - Execu√ß√£o):**\n    *   **Registrador de Pipeline ID/EX:** Fornece as entradas para este est√°gio.\n    *   **ALU (Arithmetic Logic Unit):** Realiza opera√ß√µes aritm√©ticas e l√≥gicas, baseadas no **ALU Ctrl** (ALU Control) gerado pelo Control Unit. Suas entradas s√£o selecionadas por Muxes, que podem receber dados do ID/EX ou valores encaminhados.\n    *   **Forwarding Unit:** Detecta hazards de dados e, quando poss√≠vel, encaminha os resultados dos est√°gios MEM ou WB diretamente para as entradas da ALU, evitando stalls. Os Muxes de entrada da ALU s√£o controlados por esta unidade.\n    *   **Sinal EX.Flush (anotado em vermelho):** Usado para invalidar instru√ß√µes no est√°gio de execu√ß√£o, frequentemente em resposta a exce√ß√µes ou branches.\n    *   **Registrador de Pipeline EX/MEM:** Armazena o resultado da ALU, o segundo operando para escrita em mem√≥ria (se for store), o endere√ßo de destino para escrita no banco de registradores (se for write back), e sinais de controle relevantes.\n\n4.  **Est√°gio MEM (Memory Access - Acesso √† Mem√≥ria):**\n    *   **Registrador de Pipeline EX/MEM:** Fornece as entradas.\n    *   **Data Memory:** Usada para opera√ß√µes de carga (load) e armazenamento (store). O endere√ßo √© fornecido pelo resultado da ALU. A opera√ß√£o (leitura ou escrita) √© controlada por sinais do Control Unit.\n    *   **Registrador de Pipeline MEM/WB:** Armazena os dados lidos da mem√≥ria (para loads), o resultado da ALU (para opera√ß√µes aritm√©ticas/l√≥gicas), e o endere√ßo de destino do registrador para o est√°gio de escrita.\n\n5.  **Est√°gio WB (Write Back - Escrita de Volta):**\n    *   **Registrador de Pipeline MEM/WB:** Fornece os dados.\n    *   **Mux de Write Back:** Seleciona qual valor ser√° escrito de volta no Register File:\n        *   Dados lidos da Data Memory (para loads).\n        *   Resultado da ALU (para opera√ß√µes aritm√©ticas/l√≥gicas).\n        *   PC + 4 (para jumps e branches com link, para armazenar o endere√ßo de retorno).\n    *   **Registers (Register File):** O valor selecionado √© escrito no registrador de destino, conforme instru√≠do pelos sinais de controle.\n\n**Componentes Adicionais e Anota√ß√µes Manuscritas:**\n\n*   **Intera√ß√£o com o PC:** M√∫ltiplas linhas vermelhas indicam que o valor do PC pode ser atualizado a partir de diferentes fontes, incluindo resultados da ALU, endere√ßos de branch/jump e, notavelmente, **UTVEC** (User Trap Vector) para tratamento de interrup√ß√µes/exce√ß√µes.\n*   **Se√ß√£o de Tratamento de Exce√ß√µes/Interrup√ß√µes (canto superior direito):** Uma parte do diagrama, fortemente anotada em vermelho, detalha um multiplexador que parece selecionar o pr√≥ximo PC ou um valor a ser salvo/lido de registradores de estado/controle (CSRs) em cen√°rios de exce√ß√£o ou interrup√ß√£o. As entradas vis√≠veis e anotadas para este Mux s√£o:\n    *   **SV:** Provavelmente um valor de System Vector ou Supervisor Vector.\n    *   **EPC (Exception Program Counter):** Registrador que armazena o endere√ßo da instru√ß√£o que causou a exce√ß√£o.\n    *   **JVAL:** Pode ser um valor de Jump Value ou similar.\n    *   Outras entradas s√£o rotuladas com n√∫meros \"2\", \"4\", \"6\", \"0\", \"1\".\n    *   As sa√≠das desse bloco parecem ser **IC**, **EP**, **EV** (possivelmente Interrupt Cause, Exception PC, Exception Value), e **BND / RSAL** (Bounds / Return Address Save Link), indicando funcionalidades de tratamento de armadilhas, gerenciamento de contexto ou extens√µes espec√≠ficas da arquitetura.\n*   **Conex√µes de controle:** Linhas finas azuis representam os sinais de controle que permeiam o pipeline, originando-se principalmente da Control Unit e interagindo com a Hazard Detection Unit e Forwarding Unit.\n*   **Anota√ß√µes no PC Mux:** A anota√ß√£o \"10\" e \"arx, xB, xC\" (parcialmente cortada) s√£o notas adicionais, possivelmente refer√™ncias a registradores espec√≠ficos ou endere√ßos utilizados em exemplos de aula.\n\nO diagrama ilustra um projeto de pipeline robusto para RISC-V, abordando os desafios de desempenho e corre√ß√£o atrav√©s do uso de unidades de controle, detec√ß√£o de hazards, encaminhamento e mecanismos de tratamento de exce√ß√µes.",
        "transcription": "Passei l√° para a apresenta√ß√£o do F√°tima, que √© agora, √†s quatro horas, ent√£o est√° todo mundo convidado.",
        "video_source": "OAC_2022-04-18.mp4"
    },
    {
        "id": 13,
        "timestamp_start": 6280.64,
        "timestamp_end": 6282.6,
        "slide_description": "Como um Engenheiro de Computa√ß√£o S√™nior, analisei o slide e o contexto fornecidos.\n\nO conte√∫do visual principal consiste na tela compartilhada do apresentador, que atualmente exibe a √°rea de trabalho do sistema operacional Windows, e o feed de v√≠deo do pr√≥prio professor.\n\n**1. Transcri√ß√£o de Texto e T√≠tulos:**\n\n*   **T√≠tulo da Sala de Aula Virtual:** \"Sala de Aula de OAC\" (prov√°vel abrevia√ß√£o de Organiza√ß√£o e Arquitetura de Computadores).\n*   **Informa√ß√µes no canto superior direito da tela compartilhada:**\n    *   \"Universidade de Bras√≠lia\"\n    *   \"Departamento de Ci√™ncia da Computa√ß√£o\"\n    *   \"CIC0009 - Organiza√ß√£o e Arquitetura de Computadores\"\n    *   \"Prof. Marcus Vinicius Lamar\"\n*   **Texto na barra superior da janela do navegador (parcialmente vis√≠vel):** \"Confer√™nciaWeb - Sala de Au...\"\n*   **Elementos de UI do player de v√≠deo e chat foram ignorados conforme solicitado, pois n√£o fazem parte do conte√∫do da aula em si.**\n\n**2. Descri√ß√£o de Diagramas e Fluxo de Dados:**\n\n*   **N√£o h√° diagramas de datapath, pipeline, hierarquia de mem√≥ria, ou qualquer representa√ß√£o gr√°fica complexa relacionada √† arquitetura de computadores vis√≠vel no momento.** A tela compartilhada exibe o wallpaper padr√£o do Windows (o logotipo do Windows 10/11 em um fundo azul gradiente), indicando que o professor est√° na tela inicial de seu desktop, possivelmente antes de iniciar a apresenta√ß√£o dos slides da aula. Um cursor do mouse vermelho est√° vis√≠vel na parte inferior central da tela.\n\n**3. Conte√∫do Visual Adicional:**\n\n*   O feed de v√≠deo do professor, Marcus Vinicius Lamar, √© vis√≠vel no canto inferior direito da tela compartilhada. Ele √© um homem com barba e √≥culos, e parece estar engajado na transmiss√£o, provavelmente falando.\n\nEm resumo, a imagem apresenta o in√≠cio de uma aula de \"Organiza√ß√£o e Arquitetura de Computadores\" da Universidade de Bras√≠lia, com o Prof. Marcus Vinicius Lamar. No momento da captura, a tela compartilhada exibe o desktop do professor (wallpaper do Windows) e n√£o h√° conte√∫do t√©cnico espec√≠fico do curso, como diagramas de arquitetura ou c√≥digo, vis√≠vel. O foco atual √© a identifica√ß√£o do curso e do professor.",
        "transcription": "N√£o tinha que marcar o *fetch*.",
        "video_source": "OAC_2022-04-18.mp4"
    },
    {
        "id": 14,
        "timestamp_start": 6282.6,
        "timestamp_end": 6291.24,
        "slide_description": "Atuando como um Engenheiro de Computa√ß√£o S√™nior, analisei o slide de uma aula de Arquitetura de Computadores, focado na arquitetura de pipeline RISC-V. Abaixo, descrevo o conte√∫do visual para um sistema de busca sem√¢ntica (RAG), transcrevendo textos e detalhando diagramas.\n\n---\n\n**T√≠tulo do Slide:**\nRISC-V Pipeline\n\n**Informa√ß√µes da Aula/Curso (canto superior direito):**\nUnB ‚Äì CIC0099 ‚Äì Organiza√ß√£o e Arquitetura de Computadores\nUniversidade de Bras√≠lia\nDepartamento de Ci√™ncia da Computa√ß√£o\nProf. Marcus Vinicius Lamar\n\n**Diagrama Principal: Pipeline RISC-V de 5 Est√°gios**\n\nO slide apresenta um diagrama detalhado do *datapath* de um processador RISC-V segmentado (pipelined) de 5 est√°gios (Instruction Fetch - IF, Instruction Decode - ID, Execute - EX, Memory Access - MEM, Write Back - WB), com implementa√ß√µes de detec√ß√£o de *hazard* (conflito), *forwarding* (encaminhamento) e mecanismos para tratamento de *flush* (esvaziamento do pipeline) e exce√ß√µes.\n\n**Estrutura e Fluxo de Dados:**\n\n1.  **Est√°gio IF (Instruction Fetch - Busca de Instru√ß√£o):**\n    *   Um registrador `PC` (Program Counter) armazena o endere√ßo da instru√ß√£o atual.\n    *   Um somador `+4` calcula o endere√ßo da pr√≥xima instru√ß√£o sequencial (`PC+4`).\n    *   Um multiplexador (`Mux`) seleciona a pr√≥xima instru√ß√£o, com entradas para `PC+4`, um endere√ßo de desvio/salto (calculado via `Shift left 1` e `ALU` do est√°gio EX) e uma entrada manuscrita \"10\" que aponta para `UTVEC` (User Trap Vector), sugerindo um endere√ßo de vetor de interrup√ß√£o/exce√ß√£o. H√° um Mux com entradas `0`, `U` (User?), `M` (Machine?), `PC` (valor do PC) controlando a escrita no registrador PC.\n    *   `Instruction memory` (Mem√≥ria de Instru√ß√µes) busca a instru√ß√£o no endere√ßo fornecido pelo PC.\n    *   O sinal `IF Flush` (manuscrito \"r\" ao lado) √© vis√≠vel, indicando a capacidade de esvaziar este est√°gio.\n    *   Dados do IF s√£o passados para o registrador de pipeline `IF/ID`.\n\n2.  **Est√°gio ID (Instruction Decode - Decodifica√ß√£o de Instru√ß√£o):**\n    *   Registrador de pipeline `IF/ID` propaga a instru√ß√£o e o `PC+4` para este est√°gio.\n    *   `Registers` (Arquivo de Registradores): Leitura de dois operandos de registradores com base nos campos `rs1` e `rs2` da instru√ß√£o.\n    *   `Imm Gen` (Immediate Generator): Gera o valor imediato dependendo do tipo da instru√ß√£o.\n    *   `Control` unit (Unidade de Controle): Decodifica a instru√ß√£o e gera sinais de controle para todos os est√°gios do pipeline.\n    *   `Hazard detection unit` (Unidade de Detec√ß√£o de Conflitos): Recebe informa√ß√µes dos campos de registradores lidos e dos registradores destino de est√°gios posteriores (`EX/MEM`, `MEM/WB`). Gera sinais de `ID Flush` e `IF Flush` para pausar ou esvaziar o pipeline em caso de conflitos de dados.\n    *   `Shift left 1`: Usado para calcular deslocamentos para desvios (branches).\n    *   Sinal `ID Flush` presente.\n    *   Dados do ID s√£o passados para o registrador de pipeline `ID/EX`. Um Mux no caminho do registrador de destino para o registrador `ID/EX` √© anotado com \"7C\".\n\n3.  **Est√°gio EX (Execute - Execu√ß√£o):**\n    *   Registrador de pipeline `ID/EX` propaga instru√ß√£o, operandos lidos, valor imediato e sinais de controle.\n    *   `Mux`s para sele√ß√£o dos operandos da `ALU` (Arithmetic Logic Unit): Permitem a escolha entre valores de registradores, valores imediatos ou dados encaminhados (`forwarded`) de est√°gios posteriores para resolver conflitos de dados.\n    *   `ALU` (Arithmetic Logic Unit): Realiza opera√ß√µes aritm√©ticas e l√≥gicas.\n    *   `ALU Ctrl` (ALU Control): Unidade de controle espec√≠fica para a ALU.\n    *   `Forwarding unit` (Unidade de Encaminhamento): Observa os registradores de destino dos est√°gios `EX/MEM` e `MEM/WB` e os registradores de leitura do est√°gio EX. Se houver um conflito de dados (o operando necess√°rio no EX est√° dispon√≠vel em um est√°gio posterior), ela direciona o resultado apropriado via Muxes para a entrada da ALU.\n    *   Um sinal manuscrito \"PC\" (em vermelho) sai do registrador `ID/EX` e se conecta a um Mux antes do registrador `EX/MEM`, indicando que o `PC+4` √© propagado.\n    *   Um sinal manuscrito \"DT\" (Data Target) aponta da sa√≠da da `ALU` para o campo de endere√ßo da `Data memory` no est√°gio MEM.\n    *   Dados do EX s√£o passados para o registrador de pipeline `EX/MEM`.\n\n4.  **Est√°gio MEM (Memory Access - Acesso √† Mem√≥ria):**\n    *   Registrador de pipeline `EX/MEM` propaga resultado da ALU, dados para escrita na mem√≥ria (se for uma opera√ß√£o de loja), e o endere√ßo de destino do registrador.\n    *   `Data memory` (Mem√≥ria de Dados): Realiza opera√ß√µes de leitura (`LW`) ou escrita (`SW`) no endere√ßo calculado pela ALU.\n    *   Sinal `EX Flush` presente, indicando a capacidade de esvaziar este est√°gio.\n    *   Dados do MEM s√£o passados para o registrador de pipeline `MEM/WB`.\n\n5.  **Est√°gio WB (Write Back - Escrita de Volta):**\n    *   Registrador de pipeline `MEM/WB` propaga o dado a ser escrito de volta no arquivo de registradores (seja o resultado da ALU ou o dado lido da mem√≥ria).\n    *   Um `Mux` final seleciona entre o dado lido da mem√≥ria e o resultado da ALU para ser escrito no `Registers` file.\n    *   O dado √© escrito no `Registers` file no endere√ßo de destino especificado pela instru√ß√£o.\n\n**Mecanismos de Controle e Interconex√£o Adicionais:**\n\n*   **Sinais de Flush:** `IF Flush`, `ID Flush`, `EX Flush` s√£o acionados pela `Hazard detection unit` ou por l√≥gica de controle de desvios/exce√ß√µes para esvaziar est√°gios espec√≠ficos do pipeline, por exemplo, ap√≥s um desvio condicional tomado ou uma interrup√ß√£o.\n*   **Encaminhamento (Forwarding):** V√°rias linhas tracejadas e s√≥lidas (`7C` anotado em algumas) conectam as sa√≠das dos registradores de pipeline `EX/MEM` e `MEM/WB` de volta aos Muxes de entrada da `ALU` no est√°gio EX, permitindo que os resultados intermedi√°rios sejam usados como operandos sem esperar a fase de Write Back, mitigando conflitos de dados.\n*   **Tratamento de Exce√ß√µes/Interrup√ß√µes (Manuscrito em vermelho, canto superior direito):**\n    *   Um bloco de Muxes recebe diversas entradas, incluindo valores do `PC` (`SV`, `0`, `2`, `4`, `6`) de diferentes est√°gios ou fontes.\n    *   Sa√≠da do primeiro Mux (entradas 0, 2, 4, 6): Rotulado `CAUX` (provavelmente Cause Auxiliary, indicando a causa da exce√ß√£o).\n    *   Sa√≠da do segundo Mux (entradas 1, SV): Rotulado `EPC` (Exception Program Counter, que armazena o endere√ßo da instru√ß√£o que causou a exce√ß√£o).\n    *   Sa√≠da do terceiro Mux (entradas 0, 1): Rotulado `JVAL` (Jump Value, talvez um endere√ßo de retorno ou um valor de salto espec√≠fico para exce√ß√µes).\n    *   Uma linha `EV` (Exception Vector) √© mostrada saindo deste bloco, indicando o endere√ßo para onde o PC deve saltar para iniciar a rotina de tratamento de exce√ß√£o.\n    *   Duas anota√ß√µes adicionais: `BND` (provavelmente Bound, relacionado a verifica√ß√£o de limites de mem√≥ria) e `RRSAL` (significado incerto sem contexto adicional, poderia ser um registrador de status ou controle de exce√ß√µes).\n\n**Anota√ß√µes Adicionais (manuscritas):**\n\n*   \"7C\": Aparece em diversos pontos, como na sa√≠da do `Hazard detection unit` para o `Control`, na entrada de um Mux no est√°gio ID, e pr√≥ximo √† sa√≠da da ALU. Sugere um valor de controle espec√≠fico ou um identificador de sinal.\n*   \"artix?, xb,0\": Anota√ß√£o no canto inferior esquerdo, possivelmente relacionada a discuss√µes sobre implementa√ß√£o em hardware (por exemplo, FPGAs Artix da Xilinx) ou campos de registradores/instru√ß√µes (`xb` como um registrador ou por√ß√£o de uma instru√ß√£o).\n\nEste slide descreve um pipeline RISC-V fundamental, incorporando t√©cnicas avan√ßadas de otimiza√ß√£o e tratamento de exce√ß√µes, essenciais para o desempenho e a robustez de processadores modernos.",
        "transcription": "N√£o tinha que marcar uma coisa l√° para quem vai apresentar?",
        "video_source": "OAC_2022-04-18.mp4"
    }
]