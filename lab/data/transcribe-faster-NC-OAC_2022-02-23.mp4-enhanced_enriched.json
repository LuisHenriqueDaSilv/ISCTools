[
    {
        "id": 1,
        "timestamp_start": 0.94,
        "timestamp_end": 39.38,
        "slide_description": "A an√°lise do slide apresenta um plano de ensino detalhado para uma disciplina de Arquitetura de Computadores (OAC), provavelmente de n√≠vel universit√°rio, como indicado pelo t√≠tulo do documento \"OAC_A_Plano_2021-2_v0\". O conte√∫do √© apresentado em formato de tabela, listando t√≥picos, datas e avalia√ß√µes. N√£o h√° diagramas visuais (como datapath, pipeline ou hierarquia de mem√≥ria) presentes no slide, apenas a men√ß√£o textual desses conceitos nos t√≥picos.\n\nA transcri√ß√£o fiel do conte√∫do da tabela √© a seguinte:\n\n| Semana/Data Inicial | Data Final | T√≥picos Principais (Esquerda) | T√≥picos Complementares ou Avalia√ß√µes (Direita) |\n| :------------------ | :--------- | :------------------------------ | :--------------------------------------------- |\n| 24/1                | 26/1       | 2) Desempenho: Fatores (C.1)    | 3) Desempenho: Medidas (C.1)(T1)               |\n| 31/1                | 2/2        | 4) Ling. de M√°quina: ISA (C.2)  | 5) Ling. de M√°quina: Assembly (C.2)(T2)        |\n| 7/2                 | 9/2        | 6) Ling. de M√°quina: Procedimentos (C.2) | 7) Ling. de M√°quina: Recursividade e I/O (C.2)(T3) |\n| 14/2                | 16/2       | 8) Arit. Computacional: Inteiros (C.3) | 9) Arit. Computacional: ULA (C.3)(T4)         |\n| 21/2                | 23/2       | 10) Arit. Computacional: Fracion√°rios, IEEE 754 (C.3) | 11) Outras Arquiteturas (T5)                   |\n| 28/2                | 2/3        | FERIADO                         | Lab 1A: Software - pars (T6)                   |\n| 7/3                 | 9/3        | Lab 1B: Software - Compilador C | Lab 2: Hardware - Verilog - ULA (T7)           |\n| 14/3                | 16/3       | 1¬™ Prova (P1)                   | 12) Processador Uniciclo: Unidade de Controle (C.4) (T8) |\n| 21/3                | 23/3       | 13) Processador Uniciclo: Unidade de Controle (C.4) (L1) | Lab 3: Processador Uniciclo (T9)               |\n| 28/3                | 30/3       | 14) Processador Multiciclo: Unidade Operativa (C.4) | 15) Processador Multiciclo: Unidade de Controle (C.4) (T10) |\n| 4/4                 |            | Lab 4: Processador Multiciclo   | 16) Processador Pipeline: Conceitos (C.4)(L3)  |\n| 11/4                | 13/4       | 17) Pipeline: Unidade Operativa e Controle (C.4) | Lab 5: Processador Pipeline (T12)              |\n| 18/4                | 20/4       | 18) Exce√ß√£o e Interrup√ß√£o (C.4) (L4) | 19) Mem√≥ria: Hierarquia (C.5) (T13)           |\n| 25/4                | 27/4       | 19.1) Mem√≥ria: Cache (C.5)      | 2¬™ Prova (P2) (L5)                             |\n| 2/5                 | 4/5        | Prova Substitutiva              | Apresenta√ß√£o dos Projetos (P4) (T15)           |\n\n**Descri√ß√£o do Conte√∫do para um Sistema RAG:**\n\nEste documento √© um plano de curso para a disciplina de Arquitetura de Computadores (OAC), referente ao per√≠odo 2021-2. Ele detalha uma progress√£o l√≥gica de t√≥picos, come√ßando com **desempenho** (fatores e medidas), seguido por **linguagem de m√°quina** (ISA, Assembly, procedimentos, recursividade, I/O). A seguir, aborda a **aritm√©tica computacional** (n√∫meros inteiros, Unidade L√≥gica e Aritm√©tica - ULA, n√∫meros fracion√°rios conforme IEEE 754) e introduz o conceito de **outras arquiteturas**.\n\nA ementa inclui sess√µes pr√°ticas de laborat√≥rio (Labs) focadas tanto em **software** (parsing, compilador C) quanto em **hardware** (Verilog para ULA). Os t√≥picos avan√ßam para o estudo de **processadores**, come√ßando com o modelo **uniciclo** (unidade de controle e operativa), e progredindo para o **multiciclo** (unidade operativa e de controle). Em seguida, foca em **pipeline** (conceitos, unidade operativa e controle), **exce√ß√£o e interrup√ß√£o**, e finalmente na **hierarquia de mem√≥ria**, com √™nfase em **cache**.\n\nO plano de avalia√ß√£o inclui duas provas regulares (1¬™ Prova P1, 2¬™ Prova P2), uma prova substitutiva e a apresenta√ß√£o de projetos (P4). Os t√≥picos s√£o categorizados com c√≥digos como C.1, C.2, etc., que podem indicar cap√≠tulos ou unidades conceituais, e T1, T2, etc., que possivelmente se referem a tarefas ou tutoriais, enquanto L1, L3, L4, L5 indicam laborat√≥rios espec√≠ficos ou atividades pr√°ticas. \"FERIADO\" indica uma interrup√ß√£o no calend√°rio das aulas.\n\nN√£o h√° c√≥digo Assembly, C ou Verilog diretamente vis√≠vel, mas a men√ß√£o de \"Ling. de M√°quina: Assembly\", \"Software - Compilador C\" e \"Hardware - Verilog - ULA\" indica que esses idiomas e ferramentas ser√£o utilizados ou estudados no contexto da disciplina.",
        "transcription": "Bom, ent√£o, boa tarde. Vamos dar in√≠cio a mais uma aula de OAC. Hoje √© dia 23 de fevereiro. 23 de fevereiro √© para n√≥s vermos, ent√£o, outras arquiteturas, uma vez que a gente acabou de ver a arquitetura RISC-V. S√≥ que a gente n√£o acabou ainda, faltou uma partezinha dessa de Aritm√©tica Computacional de N√∫meros Fracion√°rios. Ent√£o, vamos primeiro terminar a aula passada e depois a gente entra na aula de hoje.",
        "video_source": "OAC_2022-02-23.mp4"
    },
    {
        "id": 2,
        "timestamp_start": 39.38,
        "timestamp_end": 388.3,
        "slide_description": "Este slide de uma aula de Arquitetura de Computadores, da disciplina \"CIC0099 - Organiza√ß√£o e Arquitetura de Computadores\" da Universidade de Bras√≠lia, ministrada pelo Prof. Marcus Vinicius Lamar, aborda o tema de **Ponto Flutuante na ISA RISC-V, especificamente a extens√£o RV32IMFD**.\n\nO conte√∫do textual principal do slide detalha as caracter√≠sticas da unidade de ponto flutuante:\n1.  **Tipos de Precis√£o Suportados:**\n    *   `[ ] F: Single precision` (Precis√£o Simples)\n    *   `[ ] D: Double precision` (Precis√£o Dupla)\n    *   `[ ] Q: Quad precision` (Precis√£o Qu√°drupla)\n    Esses marcadores indicam as extens√µes de ponto flutuante que a ISA RISC-V pode incorporar, sendo 'F' e 'D' as mais comuns e presentes na especifica√ß√£o `RV32IMFD` (onde F e D representam Floating-point Single e Double precision, respectivamente).\n\n2.  **Registradores de Ponto Flutuante:**\n    *   `32 Registradores de 64 bits:`\n    *   `f0, f1,..., f30, f31 com conven√ß√£o`\n    Esta se√ß√£o especifica que a arquitetura RISC-V possui 32 registradores de ponto flutuante, cada um com 64 bits de largura. Isso permite o armazenamento direto de valores de dupla precis√£o (64 bits) e a representa√ß√£o de valores de precis√£o simples (32 bits) dentro desses registradores, ou pares de registradores para precis√£o qu√°drupla. A men√ß√£o \"com conven√ß√£o\" sugere que h√° um padr√£o de uso para esses registradores (e.g., para argumentos, valores de retorno, tempor√°rios, salvos, etc.), similar √† conven√ß√£o de chamada para registradores inteiros.\n\n3.  **Float-point Control and Status Register (fcsr):**\n    O slide apresenta um diagrama esquem√°tico do registrador de controle e status de ponto flutuante (fcsr), um componente crucial para o gerenciamento de opera√ß√µes de ponto flutuante. O diagrama detalha a estrutura de bits do fcsr:\n    *   Bits 31 a 8: Marcados como `Reserved` (Reservado), ocupando 24 bits.\n    *   Bits 7 a 5: Designados para `Rounding Mode (frm)` (Modo de Arredondamento), ocupando 3 bits.\n    *   Bits 4 a 0: Designados para `Accrued Exceptions (fflags)` (Flags de Exce√ß√£o Acumuladas), ocupando 5 bits. Dentro de `fflags`, h√° 5 bits individuais, cada um representado por um `1` abaixo: `NV`, `DZ`, `OF`, `UF`, `NX`.\n\n    Abaixo do diagrama do fcsr, s√£o detalhados os significados dos campos:\n    *   **Modos de Arredondamento (`frm`):**\n        *   `000: ao n√∫mero par (round)` - Round to Nearest, ties to Even.\n        *   `001: para o zero (round)` - Round Toward Zero.\n        *   `010: para baixo (floor)` - Round Down (Toward Negative Infinity).\n        *   `011: para cima (ceil)` - Round Up (Toward Positive Infinity).\n        *   `100: para a maior magnitude (round)` - Round to Nearest, ties to Away from Zero (similar ao round half up/down).\n        Estes s√£o modos de arredondamento padr√£o definidos pela norma IEEE 754.\n\n    *   **Flags de exce√ß√£o (`fflags`):**\n        *   `NV = Opera√ß√£o Inv√°lida` (Invalid Operation)\n        *   `DZ = Divis√£o por zero` (Divide by Zero)\n        *   `OF = Overflow`\n        *   `UF = Underflow`\n        *   `NX = Inexato` (Inexact)\n        Estas s√£o as exce√ß√µes padr√£o de ponto flutuante definidas pela IEEE 754.\n\n**Tabelas de Registradores:**\nNo lado direito do slide, h√° duas tabelas que exibem o estado de diversos registradores, presumivelmente em um ambiente de simula√ß√£o ou depura√ß√£o, com a maioria dos valores inicializados para zero.\n\n1.  **Tabela de Registradores de Ponto Flutuante:**\n    Esta tabela lista os 32 registradores de ponto flutuante (`f0` a `f31`) com seus respectivos nomes convencionais (`ft0`-`ft11`, `fs0`-`fs11`, `fa0`-`fa7`), n√∫meros de registradores (0 a 31) e valores hexadecimais atuais. Todos os valores mostrados s√£o `0x0000000000000000`, indicando um estado inicial ou resetado. Os nomes `ftx` (temporary), `fsx` (saved), e `fax` (argument) refletem as conven√ß√µes de chamada em RISC-V.\n\n2.  **Tabela de Registradores de Controle e Status (CSRs):**\n    Esta tabela, parcialmente vis√≠vel, lista v√°rios registradores de controle e status (CSRs) com seus nomes, n√∫meros e valores. Inclui:\n    *   `ustatus` (0): `0x00000000`\n    *   `fflags` (1): `0x00000000` (reflete o campo fflags do fcsr)\n    *   `frm` (2): `0x00000000` (reflete o campo frm do fcsr)\n    *   `fcsr` (3): `0x00000000` (o pr√≥prio registrador fcsr)\n    *   `uie` (4): `0x00000000`\n    *   `utvec` (5): `0x00000000`\n    *   `uscratch` (64): `0x00000000`\n    *   `uepc` (65): `0x00000000`\n    *   `ucause` (66): `0x00000000`\n    *   `utval` (67): `0x00000000`\n    *   `uip` (68): `0x00000000`\n    *   `misa` (769): `0x4001128` (Registrador Machine ISA, indicando extens√µes suportadas)\n    *   `cycle` (3072): `0x00000000`\n    *   `time` (3073): `0x00000000`\n    *   `instret` (3074): `0x00000000`\n    *   `cycleh` (3200): `0x00000000`\n    *   `timeh` (3201): `0x00000000`\n    *   `instreth` (3202): `0x00000000`\n    A maioria dos valores √© zero, exceto para `misa`, cujo valor `0x4001128` indica as extens√µes de ISA presentes no processador simulado ou hardware. Os registradores `cycle`, `time`, `instret` e seus equivalentes `_h` s√£o contadores de performance e tempo, comuns em arquiteturas RISC-V.\n\nEm resumo, o slide fornece uma vis√£o detalhada da unidade de ponto flutuante em uma arquitetura RISC-V RV32IMFD, cobrindo os tipos de precis√£o, a estrutura dos registradores de ponto flutuante e, de forma abrangente, o papel e a configura√ß√£o do registrador de controle e status de ponto flutuante (fcsr), incluindo modos de arredondamento e flags de exce√ß√£o conforme a especifica√ß√£o IEEE 754. As tabelas complementam essas informa√ß√µes mostrando o estado dos registradores.",
        "transcription": "Acho que foi aqui que a gente parou, n√©? A gente acabou de ver os modos de arredondamento: sempre para baixo, sempre para cima. E, nesse caso aqui, eu posso arredondar sempre para cima, posso arredondar sempre para baixo, ou ent√£o usar uma dessas tr√™s formas de realizar esse arredondamento, t√°? Arredondamento para o zero, maior magnitude ou para o n√∫mero par. Por que que isso aqui √© importante? Porque, dependendo da aplica√ß√£o, as √∫ltimas casas decimais podem fazer diferen√ßa. Por exemplo, uma institui√ß√£o financeira como o IBAN, os 0,05 centavos, n√©, pode ser importante. Vamos dar uma olhada para isso e depois iremos para o pr√≥ximo est√°gio. Dizer se ele vai para a conta do cliente ou se ele vai ficar com o resto no banco, n√©? Ent√£o, esse modo de arredondamento serve justamente para a gente ter controle sobre isso.\n\nOk, como √© que isso funciona no RISC-V, n√©? Ent√£o, no RISC-V, a gente tem, a gente viu, a gente t√° vendo a RV32I, n√©? Vimos o m√≥dulo M de multiplica√ß√£o e divis√£o, e agora o RISC-V tem outros, na realidade, tem outros tr√™s m√≥dulos, t√°: I, M, F, D e Q, t√°? Mas o Q n√£o √© t√£o comum assim de implementar. Ent√£o, o m√≥dulo F, que √© de precis√£o simples, e o m√≥dulo D, que √© de precis√£o dupla, t√°, que s√£o os dois m√≥dulos que o RISC-V tem implementado. Ent√£o, para trabalhar com ponto flutuante, n√©, os arquitetos do RISC-V resolveram colocar um outro banco de registradores, tamb√©m de 32 registradores. S√≥ que, se o m√≥dulo D est√° implementado, ent√£o esses registradores t√™m 64 bits, t√°? Notem que isso aqui est√° em hexadecimal, t√°? Ent√£o, tem 64 bits aqui. Se o m√≥dulo D tiver implementado. Se o m√≥dulo D n√£o tiver implementado, esses registradores s√£o de 32 bits, j√° que isso vai ser a precis√£o simples do ponto flutuante. E esses, bom, esse m√≥dulo de ponto flutuante, de floating-point, n√©, tamb√©m tem a sua conven√ß√£o, t√°? Ent√£o, tem os registradores FTs, n√©, de tempor√°rios; FSs, n√©, de salvos; os FAs, de argumentos. S√≥ n√£o tem ponteiros, por qu√™? Porque n√£o faz sentido a gente escrever o ponteiro com o n√∫mero de ponto flutuante, n√©? Ent√£o, a gente tem os registradores tempor√°rios, registradores salvos e os registradores de argumentos somente, ok? Ent√£o, a gente tem essa conven√ß√£o.\n\nAl√©m desse banco de registradores aqui, al√©m do banco de registradores normal de ponto flutuante, o RISC-V, obrigatoriamente, tem um banco de registradores chamado de Controle e Status, t√°, Control Status Registers (CSRs). Esse Control Status, se voc√™s observarem, qual √© o n√∫mero desse √∫ltimo registrador aqui? Come√ßa no registrador 0, 1, 2, 3, 4, 5, da√≠ passa para 64, 65, 66, 67, 3202. Ent√£o, na realidade, esse banco de registradores de Controle e Status, eles t√™m 4.096 registradores. Mas s√£o iguais a esses aqui? N√£o, t√°, porque o acesso a esses bancos de registradores √© no registro espor√°dico. Ent√£o, esse aqui √© implementado com uma pequena quantidade de mem√≥ria RAM est√°tica, certo? Ent√£o, 4.096 endere√ßos de mem√≥ria RAM. Ent√£o, a mem√≥ria RAM est√°tica, como se fosse a mem√≥ria cache, t√°, que √© a de acesso mais r√°pido, t√°? Ent√£o, n√£o chega a ser implementado como um banco de registradores normal, s√≥ que se considera isso aqui como um banco de registradores, porque cada um desses registradores, n√©, cada uma dessas posi√ß√µes dessa mem√≥ria, vai significar alguma coisa. Ent√£o, primeiro √© o ustatus, depois o uie, a gente vai tudo ver isso aqui, o utvec, o uscratch, o uepc, o ucause, o utval, o uip. Esse aqui a gente n√£o vai ver. Ent√£o, vamos ver. E tem um registradorzinho aqui, t√°, o fcsr, t√°, que √© o Floating-Point Control and Status Register. √â um registrador s√≥, e os bits desse registrador, n√©, te d√£o algumas informa√ß√µes sobre as opera√ß√µes de ponto flutuante que est√£o sendo executadas, t√°? Ent√£o, √© um registrador de 32 bits tamb√©m, esse aqui, que √© o registrador n√∫mero 3, n√©? Atrav√©s dele eu consigo saber qual √© o modo de arredondamento que est√° sendo utilizado, n√©, para fazer as opera√ß√µes de ponto flutuante, n√©? Ent√£o, aqui tem 3 bits, n√©, que definem o modo de arredondamento, que s√£o esses aqui, t√°? Ent√£o, 000 define que √© o arredondamento para o n√∫mero par; 001 √© o para o zero, desculpe; 010 √© o para baixo; 011 √© o para cima e 100 para a maior magnitude. N√£o, n√£o, tenho que arredondar isso aqui. Isso aqui √© 0, que s√£o justamente esses modos aqui, t√°? Esses modos, 1, 2, 3, 4, 5 modos. 1, 2, 3, 4, 5 modos. S√≥ vou corrigir uma coisinha aqui antes que eu",
        "video_source": "OAC_2022-02-23.mp4"
    },
    {
        "id": 3,
        "timestamp_start": 388.3,
        "timestamp_end": 412.59,
        "slide_description": "A an√°lise do conte√∫do visual da imagem revela um ambiente de sala de aula virtual, focado em uma aula de Arquitetura de Computadores (OAC), mas sem conte√∫do t√©cnico diretamente no slide principal.\n\n**1. Transcri√ß√£o de Texto e T√≠tulos:**\n\n*   **T√≠tulo da Sala:** \"Sala de Aula de OAC\" (provavelmente \"Organiza√ß√£o e Arquitetura de Computadores\").\n*   **Informa√ß√µes de Sess√£o:** Um contador de tempo \"06:41\" √© exibido no canto superior direito da √°rea de conte√∫do.\n*   **Identifica√ß√£o do Participante Principal:** \"Marcus Vinicius Lam...\" √© vis√≠vel na parte superior central, indicando um palestrante ou moderador ativo.\n*   **Elementos da Barra Lateral (UI da Confer√™ncia):**\n    *   **Menu Superior:** \"MENSAGENS\", \"Perguntas\", \"Bate-papo p√∫blico\" (selecionado).\n    *   **Menu Central:** \"NOTAS\", \"Notas comparti...\".\n    *   **Menu Inferior:** \"USU√ÅRIOS (19)\".\n*   **Conte√∫do do Bate-papo P√∫blico:**\n    *   Michel Luis Duwe 13:46: Boa Tarde\n    *   Eduarda Costa de M... 13:47: Tudo bem? Preparado pro feriado?\n    *   Michel Luis Duwe 13:50: Quero estar preparado! Tirando todas as atividades do atraso.\n    *   Eduarda Costa de M... 13:51: Am√©m üôè\n    *   Michel Luis Duwe 13:52: Tomara. Passar o feriado estudando √© punk hehehe\n    *   Eduarda Costa de M... 13:52: Demais kkkkk espero que vc atinja seus objetivos antes de quarta\n    *   Eduarda Costa de M... 13:52: Pior que quarta tem aula kkkkkry\n    *   Eduarda Costa de M... 13:53: Nesse caso, tor√ßo para consiga fazer tudo at√© segunda\n    *   Michel Luis Duwe 13:53: sim kkk\n    *   Jo√£o Alberto Travas... 14:00: boa tarde Prof Lamar\n*   **Campo de Entrada do Chat:** \"Enviar mensagem para B\".\n\n**2. Descri√ß√£o de Diagramas e Fluxo de Dados:**\n\nA √°rea principal do slide, destinada √† apresenta√ß√£o do conte√∫do da aula, est√° completamente em branco. N√£o h√° diagramas vis√≠veis de qualquer tipo, sejam eles Datapath, Pipeline, Hierarquia de Mem√≥ria, ou qualquer outra ilustra√ß√£o t√©cnica relacionada √† Arquitetura de Computadores. De igual modo, n√£o h√° c√≥digo (Assembly, C, Verilog) exibido, tabelas, gr√°ficos ou textos explicativos sobre t√≥picos espec√≠ficos da disciplina.\n\n**Resumo para RAG:**\n\nO recurso visual representa o ambiente de uma aula online de \"Organiza√ß√£o e Arquitetura de Computadores\" (OAC), conforme indicado pelo t√≠tulo da sala. O conte√∫do principal do slide est√° ausente, exibindo apenas um fundo escuro. A intera√ß√£o √© mediada por um bate-papo p√∫blico vis√≠vel na lateral, contendo mensagens de alunos (Michel Luis Duwe, Eduarda Costa de M..., Jo√£o Alberto Travas...) sobre sauda√ß√µes, planejamento de estudos para o feriado, atividades atrasadas e o cumprimento de prazos acad√™micos, culminando com uma sauda√ß√£o ao \"Prof Lamar\". Um timer indica \"06:41\" e \"Marcus Vinicius Lam...\" √© destacado, provavelmente o nome do professor. N√£o h√°, contudo, qualquer conte√∫do t√©cnico instrutivo (diagramas de arquitetura, c√≥digo, texto explicativo) vis√≠vel na √°rea do slide.",
        "transcription": "Me esque√ßa, que aqui estava **round**, na realidade √© para o 0, n√©, ent√£o para o 0, t√°, esse aqui, n√£o, n√£o, n√£o, n√£o, n√£o, n√£o, n√£o, n√£o, n√£o, n√£o, n√£o, n√£o, n√£o, n√£o, n√£o, n√£o, esse aqui √© **round** mesmo, desculpa, agora que eu entendi o que eu estava querendo dizer.",
        "video_source": "OAC_2022-02-23.mp4"
    },
    {
        "id": 4,
        "timestamp_start": 420.04,
        "timestamp_end": 436.02,
        "slide_description": "Como um Engenheiro de Computa√ß√£o S√™nior analisando este artefato de uma aula de Arquitetura de Computadores, a √°rea principal do \"slide\" apresenta-se atualmente como um canvas escuro e vazio, sem qualquer conte√∫do visual direto, como diagramas de arquitetura (datapath, pipeline, hierarquia de mem√≥ria), blocos de c√≥digo (Assembly, C, Verilog), ou texto instrucional sendo exibido.\n\nNo entanto, o contexto da aula √© substancialmente fornecido pelos elementos circundantes da interface da plataforma de confer√™ncia web:\n\n1.  **T√≠tulo da Sala de Aula:** No topo da interface, √© vis√≠vel o t√≠tulo \"Sala de Aula de OAC\", o que consistentemente indica uma disciplina relacionada a Organiza√ß√£o e Arquitetura de Computadores.\n2.  **Dura√ß√£o da Grava√ß√£o:** Pr√≥ximo ao t√≠tulo da sala, um marcador de tempo \"07:00\" acompanhado de um √≠cone de grava√ß√£o vermelho sinaliza que a sess√£o est√° ativa e sendo registrada, com sete minutos decorridos.\n3.  **T√≥pico Relacionado (Aba do Navegador):** Uma das abas abertas no navegador exibe o t√≠tulo \"ADD: ADD (x86 Instruction Set Re...\", que √© uma refer√™ncia direta e t√©cnica a \"Conjuntos de Instru√ß√µes x86\". Este elemento √© crucial, pois sugere fortemente que o tema da aula ou material de apoio est√° relacionado √† arquitetura de processadores x86 e seus conjuntos de instru√ß√µes, um t√≥pico central em arquitetura de computadores.\n4.  **Bate-papo P√∫blico (Transcri√ß√£o):** O painel lateral esquerdo mostra um 'Bate-papo p√∫blico' ativo, com as seguintes intera√ß√µes dos participantes e hor√°rios:\n    *   Michel Luis Duwe (13:46): \"Boa Tarde\"\n    *   Eduarda Costa de M... (13:47): \"Tudo bem? Preparado pro feriado?\"\n    *   Michel Luis Duwe (13:50): \"Quero estar preparado! Tirando todas as atividades do atraso.\"\n    *   Eduarda Costa de M... (13:51): \"Am√©m üôè\"\n    *   Michel Luis Duwe (13:52): \"Tomara. Passar o feriado estudando √© punk hehehe\"\n    *   Eduarda Costa de M... (13:52): \"Demais kkkkk espero que vc atinja seus objetivos antes de quarta\"\n    *   Eduarda Costa de M... (13:52): \"Pior que quarta tem aula kkkkkry\"\n    *   Eduarda Costa de M... (13:53): \"Nesse caso, tor√ßo para consiga fazer tudo at√© segunda\"\n    *   Michel Luis Duwe (13:53): \"sim kkk\"\n    *   Jo√£o Alberto ... (offline) (14:00): \"boa tarde Prof Lamar\"\n    Este hist√≥rico de chat fornece um vislumbre da intera√ß√£o dos alunos e a identifica√ß√£o do instrutor como \"Prof Lamar\", refor√ßando o ambiente de aula e a din√¢mica entre participantes e professor. As mensagens indicam discuss√µes sobre prepara√ß√£o para feriados e atividades acad√™micas.\n\nEm s√≠ntese, embora n√£o haja conte√∫do expl√≠cito no slide em si, o ambiente da confer√™ncia indica claramente uma aula online de Arquitetura de Computadores (OAC), com potencial foco no conjunto de instru√ß√µes x86, mediada por um professor (Prof Lamar) e com engajamento ativo dos alunos via chat.",
        "transcription": "Esse aqui √© o **controle de ponto flutuante**, e esses tr√™s para arredondamento, n√©: arredondamento para o n√∫mero par, arredondamento para zero, arredondamento para a maior magnitude. Ent√£o esses tr√™s bits aqui do FSR e do **FCSR** definem esse modo de arredondamento.",
        "video_source": "OAC_2022-02-23.mp4"
    },
    {
        "id": 5,
        "timestamp_start": 437.64,
        "timestamp_end": 1790.39,
        "slide_description": "O slide analisado √© de uma aula de Arquitetura de Computadores, focado em \"Ponto Flutuante - ISA RV32IMF ‚Äì Float-point Single\" (precis√£o simples de ponto flutuante na arquitetura RISC-V de 32 bits com extens√µes de inteiros, multiplica√ß√£o/divis√£o e ponto flutuante). O conte√∫do √© apresentado pela Universidade de Bras√≠lia, disciplina \"Organiza√ß√£o e Arquitetura de Computadores\" (CIC0099), ministrada pelo Prof. Marcus Vinicius Lamar.\n\nO slide detalha instru√ß√µes Assembly RISC-V para manipula√ß√£o de dados de ponto flutuante, divididas em tr√™s categorias:\n\n1.  **Transfer√™ncias de dados:**\n    *   `Load: flw f1, -100(t0)`: Esta instru√ß√£o (\"load float word\") carrega um valor de ponto flutuante de precis√£o simples da mem√≥ria para o registrador de ponto flutuante `f1`. O endere√ßo de mem√≥ria √© calculado como o valor do registrador de prop√≥sito geral `t0` subtra√≠do de 100 bytes (deslocamento). A anota√ß√£o `# f1 = Mem[t0 - 100]` descreve semanticamente a opera√ß√£o.\n    *   `Store: fsw f1, -100(t0)`: Esta instru√ß√£o (\"store float word\") armazena o valor do registrador de ponto flutuante `f1` na mem√≥ria. O endere√ßo de mem√≥ria √© calculado da mesma forma que no `load`. A anota√ß√£o `# Mem[t0 - 100] = f1` descreve semanticamente a opera√ß√£o.\n\n2.  **Movimenta√ß√£o sem convers√£o:**\n    *   `fmv.x.s t0, f1`: Esta instru√ß√£o (\"float move, bits from float to general purpose\") transfere os bits exatos do registrador de ponto flutuante `f1` para o registrador de prop√≥sito geral `t0` sem qualquer interpreta√ß√£o ou convers√£o de formato. A anota√ß√£o `# transfere os bits t0 = f1` refor√ßa que √© uma c√≥pia bit a bit.\n    *   `fmv.s.x f1, t0`: Similarmente, esta instru√ß√£o (\"float move, bits from general purpose to float\") transfere os bits exatos do registrador de prop√≥sito geral `t0` para o registrador de ponto flutuante `f1`, tamb√©m sem convers√£o de formato. A anota√ß√£o `# transfere os bits f1 = t0` descreve a opera√ß√£o.\n\n3.  **Movimenta√ß√£o com convers√£o:**\n    *   `fcvt.s.w f1, t0`: Esta instru√ß√£o (\"float convert to single precision from word\") converte um valor inteiro com sinal (assumindo que `t0` cont√©m um) para um valor de ponto flutuante de precis√£o simples e armazena o resultado em `f1`. A anota√ß√£o `# converte inteiro ‚Üí float` esclarece a funcionalidade.\n    *   `fcvt.s.wu f1, t0`: Similar √† anterior, mas esta instru√ß√£o (\"float convert to single precision from unsigned word\") converte um valor inteiro sem sinal (em `t0`) para um valor de ponto flutuante de precis√£o simples em `f1`. A anota√ß√£o `# converte inteiro sem sinal ‚Üí float` detalha.\n    *   `fcvt.w.s t0, f1`: Esta instru√ß√£o (\"float convert to word from single precision\") converte um valor de ponto flutuante de precis√£o simples (em `f1`) para um valor inteiro com sinal e armazena o resultado em `t0`. A anota√ß√£o `# converte float ‚Üí inteiro` explica a opera√ß√£o.\n    *   `fcvt.wu.s t0, f1`: Por fim, esta instru√ß√£o (\"float convert to unsigned word from single precision\") converte um valor de ponto flutuante de precis√£o simples (em `f1`) para um valor inteiro sem sinal e armazena o resultado em `t0`. A anota√ß√£o `# converte float ‚Üí inteiro sem sinal` descreve a convers√£o.\n\nN√£o h√° diagramas visuais (como datapath, pipeline ou hierarquia de mem√≥ria) presentes no slide; o conte√∫do √© puramente textual, descrevendo as instru√ß√µes e suas opera√ß√µes.",
        "transcription": "E tamb√©m a gente tem esses cinco bits aqui que s√£o exce√ß√µes, que s√£o flags, que √© chamado F-flag, ent√£o, flag de ponto flutuante. E elas, ent√£o, te d√£o informa√ß√µes sobre o que aconteceu na instru√ß√£o que acabou de ser executada. Ent√£o, por exemplo, foi executada uma instru√ß√£o inv√°lida, uma opera√ß√£o inv√°lida. Ent√£o, por exemplo, raiz quadrada de menos um, ent√£o, uma opera√ß√£o inv√°lida, certo? Porque o resultado d√° complexo, seria tipo um Not a Number. Ent√£o, eu tenho esse Not Valid, certo? E esse bit aqui, ent√£o, seria como se fosse um Not a Number. Divis√£o por zero √© o DZ, ent√£o, se der divis√£o por zero, ele vai sinalizar aqui que aconteceu uma divis√£o por zero. Depois, Overflow, ent√£o, se aconteceu Overflow, ele sinaliza aqui. Se aconteceu Underflow... ele sinaliza aqui. E esse √∫ltimo, esse primeiro bit aqui, indica que se o n√∫mero pode ser perfeitamente represent√°vel na precis√£o, ou seja, simples, seja dupla, ou n√£o. Seria um n√∫mero inexato que precisaria de mais d√≠gitos para ser perfeitamente representado. Ent√£o, ele chama aqui de n√∫mero inexato. Quer dizer, ele indica que se aquele n√∫mero que obteve √© o exato ou n√£o, isso precisaria de mais d√≠gitos. Entendeu isso? O que eu quis dizer aqui com esse inexato? Por exemplo, raiz quadrada de 2. OK, a raiz quadrada de 2 vai dar um n√∫mero que vai ser inexato, porque precisa de infinitas casas decimais. Ent√£o, ele vai te representar aqui. Ah, mas tirar a raiz quadrada de... Ele vai ser exato. Ent√£o, ele vai te indicar aqui que foi zero, quer dizer, n√£o √© inexato. Certo? Mas, justamente, nos d√° uma ideia se o resultado √© exato ou √© uma aproxima√ß√£o. OK. As instru√ß√µes que o modo F possibilita. Eu queria at√© fazer aqui uma coisa para voc√™ ver, mas n√£o fiz. Ent√£o, para a opera√ß√£o... Ah, est√° escrito aqui. As opera√ß√µes I, E, M... OK. Adi√ß√£o. Ent√£o, adi√ß√£o, subtra√ß√£o, multiplica√ß√£o e divis√£o. Ent√£o, todas elas come√ßam com F. `FADD`, `FSUB`, `FMUL` e `FDIV`. Ponto. Qual √© a precis√£o? Certo? Ent√£o, S √© precis√£o simples, que significa float. Se eu botar D aqui, significa que eu estou usando precis√£o dupla. Ent√£o, `FADD.D`, ele vai pegar esse n√∫mero em precis√£o dupla, somar com esse n√∫mero e colocar o resultado aqui. Mas, como aqui eu estou tratando s√≥ a precis√£o simples, os exemplos aqui est√£o todos em precis√£o simples. Mas, tudo que tem aqui em precis√£o simples, vai ter igual que em precis√£o dupla, s√≥ trocando o S por D. Certo? Ent√£o, subtra√ß√£o, `FSUB.S F0, F1, F2`. `FMUL.S F0, F1, F2`. OK. Da√≠, a gente pergunta: a multiplica√ß√£o de um n√∫mero de ponto flutuante de 32 bits por um n√∫mero de ponto flutuante de 32 bits, vai dar um n√∫mero de quantos bits? Vamos l√°. Vamos acordar, pessoal. Ent√£o, olha a pergunta que eu fiz. A multiplica√ß√£o de um n√∫mero de ponto flutuante de 32 bits vezes um n√∫mero de ponto flutuante de 32 bits, vai te dar o resultado com quantos bits? Me falaram 64, que para mim √© certo, se fosse divis√£o inteira, divis√£o de n√∫meros inteiros. E o resultado fica em 64 bits. Tanto √© que tem o `MUL` e o `MULH`, para a gente pegar a parte baixa e a parte alta da multiplica√ß√£o. Mas, aqui, a multiplica√ß√£o de um n√∫mero de 32 com um n√∫mero de precis√£o simples, com um n√∫mero de precis√£o simples, vai dar um n√∫mero de precis√£o simples tamb√©m. Certo? Assim como a divis√£o. A divis√£o de um n√∫mero de precis√£o simples com um n√∫mero de precis√£o simples tamb√©m, vai dar um n√∫mero de precis√£o simples. E faz parte desse m√≥dulo aqui a raiz quadrada. Ent√£o, `FSQRT.S F0, F1`. A raiz quadrada desse coloca no `F0`. OK? Ent√£o, essas aqui s√£o as opera√ß√µes aritm√©ticas b√°sicas que tem implementadas nesse F. Pode ter outras opera√ß√µes, tipo cosseno, tangente, exponencial, logaritmo? Pode. S√≥ que o hardware implementa isso. O hardware implementa esses aqui. Entendeu? Beleza. Compara√ß√£o. Clico, comparo dois n√∫meros em ponto flutuante. Ent√£o, eu tenho essas tr√™s instru√ß√µes aqui: `FEQ`, `FLE` e `FLT`. Todos eles, ponto S ou ponto D. Ent√£o, `FEQ` aqui, ele vai verificar: F1 √© igual a F2? Se for, notem, esse registrador T1, ou o T ou o registrador que voc√™s quiserem botar aqui, mas do banco de registradores principal, √© que vai assumir o valor 0 ou 1. Certo? Ent√£o, os operandos s√£o do banco de registradores de ponto flutuante. Mas, o resultado dessa compara√ß√£o vai ser um registrador l√° do banco de registradores principal. Certo? Porque o resultado te d√° um inteiro. Mais especificamente, 0 ou 1. Ent√£o, verifica se os dois s√£o iguais. Verifica se esse √© menor ou igual a esse: F1 √© menor ou igual a F2. E se F1 √© menor que F2. E s√≥ tem essas tr√™s instru√ß√µes. Voc√™s est√£o sentindo falta de alguma coisa aqui? De alguma condi√ß√£o? Como √© que eu faria uma instru√ß√£o que verificasse que fosse maior que? Ent√£o, `FGT`. Eu preciso implementar o `FGT`? E isso √© s√≥ trocar. Eu tenho a ordem desses dois aqui. Ent√£o, se eu usar o `FLE` e ir trocando esses dois de posi√ß√£o, eu tenho o `FGT`. Se eu trocar esses dois de posi√ß√µes, eu tenho um `FGE` (Greater or Equal). Certo? Ent√£o, eu n√£o preciso dessas compara√ß√µes. Bastam essas aqui. OK? E outras duas fun√ß√µezinhas que tamb√©m eles disponibilizam para o F √© o valor maior. Quer dizer, dados dois n√∫meros F1 e F2, o valor de F0 vai ser o maior desses dois n√∫meros. Ent√£o, o m√°ximo desses dois n√∫meros. E a mesma coisa no m√≠nimo. Dados esses dois n√∫meros, o F0 vai assumir o valor menor deles. Certo? Ent√£o, para saber qual √© o maior de dois n√∫meros e o menor de dois n√∫meros, a gente tem essa fun√ß√£ozinha aqui. Duas instru√ß√µezinhas. Outra coisa que √© importante. Transfer√™ncia de dados. Ent√£o, primeiro, transfer√™ncia de dados para mem√≥ria e da mem√≥ria. Tinham instrutores de inteiros. A gente usava `LOAD` e `STORE`. Ent√£o, `LOAD WORD`, `LOAD HALF WORD`, `LOAD BYTE`, `STORE WORD`, `STORE HALF WORD`, `STORE BYTE`. Aqui, a gente tamb√©m vai trabalhar a mesma coisa. `LOAD WORD`. Porque a gente est√° trabalhando aqui no F. Ent√£o, `FLOAD WORD`, ou o famoso `FLW`. O que ele vai fazer? Ele vai pegar esse endere√ßo aqui, que √© T0 menos 100, que √© T0 mais esse n√∫mero imediato, da mem√≥ria. E o que tiver na mem√≥ria, ele vai colocar no registrador F1. Ent√£o, os bits que tiverem l√° na mem√≥ria, nesse endere√ßo, ele coloca dentro de F1. E se eu quero escrever o valor de um registrador na mem√≥ria, ent√£o tem o `FSW`. Ent√£o, ele vai escrever na mem√≥ria, nesse endere√ßo T0 menos 100. Ent√£o, a gente s√≥ tem o `LOAD` e o `STORE`. Se fosse o D, teria o `FLD` e o `FSD`. Que seria de double, ao inv√©s de word. Beleza. Ent√£o, isso aqui √© para transfer√™ncia de dados da mem√≥ria para o banco de registradores de ponto flutuante e vice-versa. Eu posso querer fazer a movimenta√ß√£o de dados entre o banco de registradores de ponto flutuante e o banco de registradores de inteiros. Eu poderia transferir uma coisa para o banco. Ent√£o, ele tem as seguintes fun√ß√µes, instru√ß√µes: `FMV.X.S T0, F1`. N√£o me pergunte por que eles resolveram colocar X aqui, que at√© hoje eu n√£o entendo. X ponto S, o que ele vai fazer? `T0, F1`. Quer dizer, eu recebo como um registrador de destino T0, o registrador de origem o F1. Ent√£o, o que essa instru√ß√£o `FMV.X.S` faz? Ele transfere os bits que est√£o em F1 para o T0. √â uma transfer√™ncia de bits mesmo. Pega a palavra que est√° em F1 e coloca em T0. Vamos continuar, pessoal. N√£o custa nada a gente se esfor√ßar. E, al√©m disso, o Marcelo Vasconcelos muito provavelmente vai ser professor de voc√™s. Ao contr√°rio, eu tamb√©m tenho. Ent√£o, aqui nesse caso, √© `FMV.S.X F1, T0`. Ent√£o, o X aqui significa o registrador de banco de inteiros. Ent√£o, o registrador de destino √© um F, o registrador de origem √© o registrador de banco de inteiros, nesse caso, T0. Ele vai transferir os bits de T0 para o F1. Ent√£o, o que eu tenho aqui? C√≥pia de bits. Eu n√£o tenho convers√£o de n√∫meros. Eu tenho c√≥pia de bits aqui, simplesmente. Agora, se eu quero converter, quer dizer, ent√£o aqui eu tenho as condi√ß√µes `FCVT`. Certo? `FCVT.S.W F1, T0`. Aqui est√° um pouco mais certo. Por que eles n√£o colocaram W aqui? N√£o entendo. Aqui ele vai converter de inteiro, o inteiro que est√° em T0 para o mesmo n√∫mero escrito em ponto flutuante em F1. OK? Ent√£o, considerando T0 um n√∫mero com sinal, ele converte, por exemplo, aqui em T0 est√° -5. Em F1 vai ter aquela sequ√™ncia de bits que a gente viu aqui, quer dizer, essa aqui. Esse aqui √© o valor em T0, por exemplo, inteiro -5. O que vai gerar em F1 vai ser esse n√∫mero aqui, que √© o -5, s√≥ que em 32 bits de ponto flutuante. Ent√£o, esses aqui, efetivamente, fazem a convers√£o. Certo? Converte de inteiro para flutuante. Eu preciso pedir que meu inteiro seja sem sinal. Que eu esteja trabalhando com n√∫meros sem sinal, que s√£o n√∫meros naturais. Ent√£o, eu tenho `FCVT.S.WU F1, T0`. Ent√£o, converte meu inteiro sem sinal para float. E eu preciso ter os inversos. Eu tenho um n√∫mero float aqui que eu vou converter para inteiro. Certo? Ent√£o, se esse n√∫mero no float for um n√∫mero j√° inteiro, ele vai ficar um n√∫mero inteiro em T0. Se ele for quebrado, ele vai aproximar para fazer um arredondamento para colocar o n√∫mero mais pr√≥ximo dentro de T0. O n√∫mero inteiro mais pr√≥ximo. OK? Por exemplo, se aqui tiver 1.7, aqui vai ter 2. Certo? Mas n√£o deixem isso aqui para o processador fazer. T√°? E aqui a mesma coisa, converte de ponto flutuante para um inteiro sem sinal. OK? Ent√£o, desse modo aqui, a gente faz as convers√µes entre ponto flutuante e inteiros. Inteiros com sinal e inteiros sem sinal. E a forma que ele vai aproximar isso aqui √© o Rounding Mode, esse aqui, que vai te dizer. Ent√£o, aqui um exemplinho... Oi, fala, Michel. No slide anterior, na √∫ltima instru√ß√£o, se o float for negativo, o que que acontece? Aqui? Se o float... Voc√™ pergunta, pode pegar o Card e fazer esse teste. Beleza. E depois me diz aqui o que que aconteceu. OK, aqui um exemplinho de utiliza√ß√£o dessas instru√ß√µes ent√£o, um programa, uma fun√ß√£ozinha que faz a convers√£o de graus Fahrenheit para Celsius. Ent√£o, ele recebe como argumento a temperatura em Fahrenheit e te devolve a temperatura em graus Celsius. E o que ele faz aqui √© essa continha. Ent√£o, para graus Fahrenheit diminui de 32, multiplica por 5 e divide por 9. OK? Para a gente compilar isso aqui. Ent√£o, primeira coisa. Ah, esse aqui √© para eu. Ent√£o, est√° aqui. Fahrenheit para Celsius. E agora, eu preciso fazer essa conta. Eu sei que esse registrador aqui... Qual √© o registrador que vai estar esse n√∫mero aqui? Em que registrador ele vai estar? N√£o no `A0`. Isso aqui √© float. Ent√£o, ele vai estar no `FA0`. N√£o, n√£o √© no `F0` tamb√©m. √â no `FA0`. Isso a√≠. No banco de registradores, a gente tem os registradores de argumentos, que s√£o esses aqui. Certo? Ent√£o, nem tem registrador `F0`. Tem `FT0` e `FS0`. Fica melhor aqui. Aqui. Certo? Ent√£o, √© o `FA0` que vai receber esse valor. E onde que ele tem que devolver o resultado? Tamb√©m no registrador `FA0`. Para eu fazer essa conta aqui, eu tenho umas constantes. Eu tenho essa constante 5, tenho essa constante 32, tenho essa constante 9. Onde que eu posso armazenar essas constantes? Que eu vou precisar no meu programa. Ent√£o, aqui esse programinha ele te mostra duas formas de fazer esses armazenamentos. Um √© na mem√≥ria. Ent√£o, por exemplo, no ponto data eu estou dizendo a constante 5 √© um `.FLOAT 5.0`. Que √© essa constante aqui. E constante 9 √© um `.FLOAT 9.0`. Ent√£o, eu estou colocando as constantes 5 e 9 na mem√≥ria. No formato. Ent√£o, o que que eu vou fazer? Ent√£o, eu vou ler essas constantes para os registradores `FT0` e `FT1`. Ent√£o, eu vou pegar o endere√ßo da constante 5 da mem√≥ria e vou ler do registrador. O `T0` aqui √© o endere√ßo. `LA T0, constante5`. Ent√£o, o que que essa pseudo-instru√ß√£o faz? Carrega T0 e conte√∫do, quer dizer, esse endere√ßo desse label aqui. Ent√£o, o T0 vai conter o endere√ßo de 5 na mem√≥ria. Ent√£o, eu vou ler de `T0 mais 0` e colocar em `FT0`. Ent√£o, `FT0` recebe 5. E eu vou ler de `T0 mais 4`. J√° que o float aqui s√£o 4 bytes tamb√©m. Ent√£o, eu vou ler de `T0 mais 4`. Precis√£o simples. E colocar o resultado em `FT1`. `FT1` fica com 9. Ent√£o, essa aqui √© uma forma da gente armazenar constantes. Mas tem em outro lugar que a gente pode armazenar constantes tamb√©m. Ent√£o, esse tipo aqui √© interessante quando a constante n√£o √© inteira. Nesse caso aqui, a constante √© inteira. Ent√£o, poderia fazer de outra forma. Por exemplo, em 32 a constante √© inteira. Ent√£o, eu vou mostrar como seria uma outra forma. Ent√£o, a gente faz um `LI T0, 32`. Ent√£o, a pseudo-instru√ß√£o Load Imediato. Ent√£o, eu coloco o n√∫mero 32 em T0. E depois eu converto de inteiro para ponto flutuante. Ent√£o, de T0 que tem 32, eu vou colocar isso em ponto flutuante no FT2. Ent√£o, dessa maneira, eu estou colocando a minha pr√≥pria constante no programa. N√£o estou precisando colocar na mem√≥ria. Por que √© ruim colocar na mem√≥ria? Por que √© ruim colocar essas constantes na mem√≥ria? Essa aqui √© uma forma mais interessante de se fazer para constantes inteiras. Se voc√™ quiser colocar œÄ, voc√™ tem que escrever aqui. Por que colocar essas constantes na mem√≥ria n√£o √© muito legal? Exatamente. Acesso √† mem√≥ria √© o gargalo dos nossos sistemas computacionais modernos. Certo? N√£o, n√£o √©. √â tempo de processamento. O acesso ao dado que est√° l√° vai demandar mais ciclos de clock. N√£o √© processando. Ent√£o, n√£o √© tempo de processamento. Entendeu? Ent√£o, √© tempo de acesso. Aqui n√£o. Aqui √© o imediato para na pr√≥pria instru√ß√£o, para ele j√° ler direto. E aqui s√≥ converte. Ent√£o, esse aqui √© mais r√°pido. OK. O que eu preciso fazer? Pegar o meu argumento de entrada, que √© o FA0, subtrair de 32 com `FSUB.S FA0, FA0, FT2`, que √© o 32. Coloco o resultado ali. Pode ser no pr√≥prio FA0. Depois pego o resultado de FA0, que √© esse aqui. FA0 menos 32 e vou multiplicar por `FMUL.S FA0, FA0, FT0`, que √© 5. E depois vou pegar esse resultado e dividir por `FDIV.S FA0, FA0, FT1`, que √© 9. OK? E retorno. Teria uma maneira mais eficiente de fazer isso? Voc√™s conseguem notar algo que d√° para ele fazer para tornar isso mais eficiente ainda? Se eu pedisse otimiza√ß√£o desse programa a√≠, o que voc√™s iam fazer para diminuir a quantidade de instru√ß√µes e quantidade de acesso √† mem√≥ria? Tinha uma ideia, professor. Tinha uma ideia. T√° bem. Vou dar uma solu√ß√£o. 5 n√£o √© uma constante? 9 n√£o √© uma constante? Para que eu tenho que calcular essa conta aqui? Eu n√£o posso simplesmente dividir 5 por 9? 5 dividido por 9? √â 0.555... Ent√£o, ao inv√©s de eu colocar 2 n√∫meros na mem√≥ria, eu vou colocar um float de valor 0.555 aqui. E aqui eu tiro essa multiplica√ß√£o e fa√ßo a divis√£o s√≥ por esse 0.555. Faz sentido para voc√™s? A quantidade de acesso √† mem√≥ria e diminuir a quantidade de instru√ß√µes tamb√©m. Certo? Ent√£o, tudo aquilo que der para voc√™s simplificarem, simplifiquem. Para n√£o fazer o processador gastar tempo calculando essa multiplica√ß√£o e depois calculando essa divis√£o. E voc√™s v√£o ver no laborat√≥rio, na segunda parte do laborat√≥rio 1, que o GCC, o compilador C, faz isso aqui para voc√™s. Ele √© esperto. Complexidades do banco de ponto flutuante. Tem Overflow, tem Underflow. O IEEE 754 mant√©m 2 bits de guarda para arredondamento, para ter certeza se ele vai arredondar para cima ou para baixo ou para o mais pr√≥ximo. Tem 5 modos de arredondamento. Positivo, dividido por 0, d√° infinito, mas ele sinaliza que foi divis√£o de 0. 0 dividido por 0 produz um Not a Number. J√° que √© uma opera√ß√£o 0 dividido por 0 √© uma... Esqueci o nome. Indetermina√ß√£o. Certo? O pessoal de voc√™s est√° come√ßando a ficar com Alzheimer. Indetermina√ß√£o. Ent√£o, ele te d√° um Not a Number. Tem outras complexidades. O x86 teve o famoso bug com a atitude de PENTIUM que a Intel aprendeu com isso aqui. √â sempre esconder muito bem os bugs que ela apresenta ou se ela achar um bug corrigir mesmo. N√£o deixar passar assim. Tem coisas que se procurem sobre isso aqui. √â bem divertido. Eu vivi isso aqui. OK.",
        "video_source": "OAC_2022-02-23.mp4"
    },
    {
        "id": 6,
        "timestamp_start": 1790.39,
        "timestamp_end": 1792.39,
        "slide_description": "Atuando como um Engenheiro de Computa√ß√£o S√™nior, procedo √† an√°lise do slide e conte√∫do anotado desta aula de Arquitetura de Computadores, extraindo informa√ß√µes cruciais para um sistema de busca sem√¢ntica (RAG).\n\n**Conte√∫do Transcrito e Descrito:**\n\nA imagem representa uma interface de uma sala de aula virtual em uma plataforma de confer√™ncia web, intitulada \"Sala de Aula de OAC\", sugerindo uma disciplina de Organiza√ß√£o e Arquitetura de Computadores. No canto superior esquerdo do navegador, uma aba parcial exibe \"ADD: ADD (x86 Instruction Set Re\", indicando que um t√≥pico relacionado ao conjunto de instru√ß√µes x86, especificamente a instru√ß√£o `ADD`, foi ou est√° sendo abordado na aula.\n\nO painel lateral esquerdo exibe as se√ß√µes \"MENSAGENS\", \"NOTAS\" e \"USU√ÅRIOS (23)\". Na se√ß√£o de mensagens, designada como \"Bate-papo p√∫blico\", s√£o observadas intera√ß√µes entre alunos e o professor. As mensagens incluem:\n\n*   **Eduarda Cos...:** \"Nesse caso, tor√ßo para consiga fazer tudo at√© segunda\" (13:53) - Indica√ß√£o de um prazo ou tarefa.\n*   **Michel Luis Duwe:** \"sim kkk\" (13:53) - Intera√ß√£o informal.\n*   **Jo√£o Alberto Travas...:** \"boa tarde Prof Lamar\" (14:00) - Sauda√ß√£o ao professor.\n*   **Maycon Vinnycius S...:** \"64\" (14:11) - Um valor num√©rico, possivelmente uma quantidade, um endere√ßo de mem√≥ria, ou um dado em discuss√£o.\n*   **Maycon Vinnycius S...:** \"s√≥ trocar a ordem\" (14:14) - Sugest√£o de reordena√ß√£o, que pode se referir a instru√ß√µes, dados ou uma sequ√™ncia l√≥gica.\n*   **Eduardo Ferreira M...:** \"esqueci de perguntar sobre a elei√ß√£o do representante do CIC/IE\" (14:17) - Uma quest√£o administrativa relacionada aos Centros de Inform√°tica e Engenharia.\n*   **Maycon Vinnycius S...:** \"a0 acho\" (14:21) - Um valor hexadecimal (\"a0\"), possivelmente um endere√ßo, um registrador ou um c√≥digo de opera√ß√£o.\n*   **Eduardo Ferreira M...:** \"f0\" (14:22) - Outro valor hexadecimal (\"f0\").\n*   **Eduardo Ferreira M...:** \"fa0\" (14:22) - Mais um valor hexadecimal (\"fa0\"), possivelmente em sequ√™ncia ou relacionado aos anteriores. Esses valores hexadecimais s√£o comuns em discuss√µes sobre assembly, endere√ßamento de mem√≥ria ou representa√ß√£o de dados em Arquitetura de Computadores.\n*   **Victor Hugo Rodrig...:** \"Acesso mais devagar?\" (14:25) - Quest√£o sobre desempenho ou lat√™ncia de acesso, crucial em arquitetura de mem√≥ria ou I/O.\n*   **Jo√£o Alberto Travas...:** \"gasta t de processamento\" (14:25) - Complemento √† quest√£o anterior, sugerindo que o acesso lento consome tempo de processamento, indicando uma preocupa√ß√£o com efici√™ncia e ciclos de clock.\n*   **Jo√£o Alberto Travas...:** \"ob prof\" (14:25) - Agradecimento ao professor.\n*   **Jo√£o Alberto Travas...:** \"j√≥ia\" (14:28) - Confirma√ß√£o ou aprova√ß√£o.\nA caixa de entrada do chat exibe \"Enviar mensagem para B\", indicando a funcionalidade de envio de mensagens.\n\nNa √°rea principal da tela, um temporizador de grava√ß√£o indica \"29:58\". Uma janela flutuante exibe \"Marcus Vinicius Lam...\" com a descri√ß√£o \"Projetor em janela (pr√©via)\". O conte√∫do central da tela est√° predominantemente preto, com a mensagem \"Fim da apresenta√ß√£o de slides. Clique para sair.\", indicando que a parte expositiva da aula por meio de slides foi conclu√≠da e a sess√£o pode estar na fase de perguntas e respostas ou discuss√£o.\n\nNo canto inferior direito da tela principal, sobreposto ao fundo preto, √© vis√≠vel o rodap√© de um slide anterior ou um template padr√£o da universidade:\n*   \"Universidade de Bras√≠lia\"\n*   \"Departamento de Ci√™ncia da Computa√ß√£o\"\n*   \"OAC0000 - Organiza√ß√£o e Arquitetura de Computadores\"\n*   \"Prof. Marcus Vin√≠cius Lamar\"\nEsta informa√ß√£o confirma o contexto acad√™mico, a institui√ß√£o (Universidade de Bras√≠lia), o departamento (Ci√™ncia da Computa√ß√£o), a disciplina (OAC0000 - Organiza√ß√£o e Arquitetura de Computadores) e o docente respons√°vel (Prof. Marcus Vin√≠cius Lamar), que √© vis√≠vel em v√≠deo no canto inferior direito da tela.\n\n**An√°lise de Diagramas e C√≥digo:**\nN√£o h√° diagramas (Datapath, Pipeline, Hierarquia de Mem√≥ria) vis√≠veis neste slide. Tamb√©m n√£o h√° blocos de c√≥digo (Assembly, C, Verilog) formalmente apresentados. No entanto, os valores hexadecimais \"64\", \"a0\", \"f0\", \"fa0\" e a discuss√£o sobre \"trocar a ordem\" no chat, juntamente com a aba do navegador mencionando \"x86 Instruction Set\", sugerem uma discuss√£o que envolve diretamente aspectos de baixo n√≠vel da arquitetura, como endere√ßamento de mem√≥ria, manipula√ß√£o de registradores ou o comportamento de instru√ß√µes de m√°quina. A men√ß√£o de \"acesso mais devagar\" e \"gasta t de processamento\" aponta para discuss√µes sobre desempenho do sistema, hierarquia de mem√≥ria (caches, RAM), lat√™ncia e otimiza√ß√µes, t√≥picos fundamentais em Arquitetura de Computadores.\n\n**Conclus√£o para RAG:**\nEste artefato de aula de Arquitetura de Computadores da Universidade de Bras√≠lia, ministrada pelo Prof. Marcus Vin√≠cius Lamar, foca na intera√ß√£o p√≥s-apresenta√ß√£o de slides. O conte√∫do vis√≠vel e transcrito inclui refer√™ncias a t√≥picos t√©cnicos como o conjunto de instru√ß√µes x86, representa√ß√£o hexadecimal de dados ou endere√ßos, e discuss√µes sobre desempenho e otimiza√ß√£o de acesso (e.g., \"acesso mais devagar\", \"gasta t de processamento\"). O chat serve como um reposit√≥rio de perguntas e coment√°rios que complementam o material da aula, oferecendo insights sobre as dificuldades e os pontos de interesse dos alunos em rela√ß√£o √† disciplina. A aus√™ncia de diagramas expl√≠citos no slide atual n√£o invalida a riqueza de contexto t√©cnico infer√≠vel das intera√ß√µes e t√≠tulos.",
        "transcription": "A imagem representa uma interface de uma sala de aula virtual em uma plataforma de confer√™ncia web, intitulada \"Sala de Aula de OAC\", sugerindo uma disciplina de Organiza√ß√£o e Arquitetura de Computadores. No canto superior esquerdo do navegador, uma aba parcial exibe \"ADD: ADD (x86 Instruction Set Re\", indicando que um t√≥pico relacionado ao conjunto de instru√ß√µes x86, especificamente a instru√ß√£o `ADD`, foi ou est√° sendo abordado na aula.\n\nO painel lateral esquerdo exibe as se√ß√µes \"MENSAGENS\", \"NOTAS\" e \"USU√ÅRIOS (23)\". Na se√ß√£o de mensagens, designada como \"Bate-papo p√∫blico\", s√£o observadas intera√ß√µes entre alunos e o professor. As mensagens incluem:\n\n*   **Eduarda Cos...:** \"Nesse caso, tor√ßo para consiga fazer tudo at√© segunda\" (13:53)\n*   **Michel Luis Duwe:** \"sim kkk\" (13:53)\n*   **Jo√£o Alberto Travas...:** \"boa tarde Prof Lamar\" (14:00)\n*   **Maycon Vinnycius S...:** \"64\" (14:11)\n*   **Maycon Vinnycius S...:** \"s√≥ trocar a ordem\" (14:14)\n*   **Eduardo Ferreira M...:** \"esqueci de perguntar sobre a elei√ß√£o do representante do CIC/IE\" (14:17)\n*   **Maycon Vinnycius S...:** \"a0 acho\" (14:21)\n*   **Eduardo Ferreira M...:** \"f0\" (14:22)\n*   **Eduardo Ferreira M...:** \"fa0\" (14:22)\n*   **Victor Hugo Rodrig...:** \"Acesso mais devagar?\" (14:25)\n*   **Jo√£o Alberto Travas...:** \"gasta t de processamento\" (14:25)\n*   **Jo√£o Alberto Travas...:** \"ob prof\" (14:25)\n*   **Jo√£o Alberto Travas...:** \"j√≥ia\" (14:28)\nA caixa de entrada do chat exibe \"Enviar mensagem para B\", indicando a funcionalidade de envio de mensagens.\n\nNa √°rea principal da tela, um temporizador de grava√ß√£o indica \"29:58\". Uma janela flutuante exibe \"Marcus Vinicius Lam...\" com a descri√ß√£o \"Projetor em janela (pr√©via)\". O conte√∫do central da tela est√° predominantemente preto, com a mensagem \"Fim da apresenta√ß√£o de slides. Clique para sair.\", indicando que a parte expositiva da aula por meio de slides foi conclu√≠da e a sess√£o pode estar na fase de perguntas e respostas ou discuss√£o.\n\nNo canto inferior direito da tela principal, sobreposto ao fundo preto, √© vis√≠vel o rodap√© de um slide anterior ou um template padr√£o da universidade:\n*   \"Universidade de Bras√≠lia\"\n*   \"Departamento de Ci√™ncia da Computa√ß√£o\"\n*   \"OAC0000 - Organiza√ß√£o e Arquitetura de Computadores\"\n*   \"Prof. Marcus Vin√≠cius Lamar\"\nEsta informa√ß√£o confirma o contexto acad√™mico, a institui√ß√£o (Universidade de Bras√≠lia), o departamento (Ci√™ncia da Computa√ß√£o), a disciplina (OAC0000 - Organiza√ß√£o e Arquitetura de Computadores) e o docente respons√°vel (Prof. Marcus Vin√≠cius Lamar), que √© vis√≠vel em v√≠deo no canto inferior direito da tela.\n\n**An√°lise de Diagramas e C√≥digo:**\nN√£o h√° diagramas (Datapath, Pipeline, Hierarquia de Mem√≥ria) vis√≠veis neste slide. Tamb√©m n√£o h√° blocos de c√≥digo (Assembly, C, Verilog) formalmente apresentados. No entanto, os valores hexadecimais \"64\", \"a0\", \"f0\", \"fa0\" e a discuss√£o sobre \"trocar a ordem\" no chat, juntamente com a aba do navegador mencionando \"x86 Instruction Set\", sugerem uma discuss√£o que envolve diretamente aspectos de baixo n√≠vel da arquitetura, como endere√ßamento de mem√≥ria, manipula√ß√£o de registradores ou o comportamento de instru√ß√µes de m√°quina. A men√ß√£o de \"acesso mais devagar\" e \"gasta t de processamento\" aponta para discuss√µes sobre desempenho do sistema, hierarquia de mem√≥ria (caches, RAM), lat√™ncia e otimiza√ß√µes, t√≥picos fundamentais em Arquitetura de Computadores.\n\n**Conclus√£o para RAG:**\nEste artefato de aula de Arquitetura de Computadores da Universidade de Bras√≠lia, ministrada pelo Prof. Marcus Vin√≠cius Lamar, foca na intera√ß√£o p√≥s-apresenta√ß√£o de slides. O conte√∫do vis√≠vel e transcrito inclui refer√™ncias a t√≥picos t√©cnicos como o conjunto de instru√ß√µes x86, representa√ß√£o hexadecimal de dados ou endere√ßos, e discuss√µes sobre desempenho e otimiza√ß√£o de acesso (e.g., \"acesso mais devagar\", \"gasta t de processamento\"). O chat serve como um reposit√≥rio de perguntas e coment√°rios que complementam o material da aula, oferecendo insights sobre as dificuldades e os pontos de interesse dos alunos em rela√ß√£o √† disciplina. A aus√™ncia de diagramas expl√≠citos no slide atual n√£o invalida a riqueza de contexto t√©cnico infer√≠vel das intera√ß√µes e t√≠tulos.\n\nBeleza.",
        "video_source": "OAC_2022-02-23.mp4"
    },
    {
        "id": 7,
        "timestamp_start": 1792.39,
        "timestamp_end": 1802.39,
        "slide_description": "Como Engenheiro de Computa√ß√£o S√™nior, procedo com a an√°lise do slide e do conte√∫do anotado apresentado em uma aula de Arquitetura de Computadores.\n\nO conte√∫do principal exibido √© um documento do Microsoft Word intitulado \"OAC_A_Plano_2021-2_v0\", que representa o plano de curso ou cronograma da disciplina de Organiza√ß√£o e Arquitetura de Computadores (OAC). O documento √© estruturado como uma tabela, detalhando a progress√£o do curso em semanas, com datas espec√≠ficas e os t√≥picos abordados.\n\n**Transcri√ß√£o e Descri√ß√£o do Conte√∫do Visual:**\n\nO documento apresenta um plano de ensino dividido por semanas e t√≥picos, com refer√™ncias a cap√≠tulos (C), aulas te√≥ricas (T) e laborat√≥rios (L). A estrutura √© a seguinte:\n\n*   **Linha 1 (Semana de 24/1 a 26/1):**\n    *   T√≥pico 2: Desempenho: Fatores (C.1)\n    *   T√≥pico 3: Desempenho: Medidas (C.1)(T_1)\n*   **Linha 2 (Semana de 31/1 a 2/2):**\n    *   T√≥pico 4: Linguagem de M√°quina: ISA (C.2) (ISA - Instruction Set Architecture)\n    *   T√≥pico 5: Linguagem de M√°quina: Assembly (C.2)(T_2)\n*   **Linha 3 (Semana de 7/2 a 9/2):**\n    *   T√≥pico 6: Linguagem de M√°quina: Procedimentos (C.2)\n    *   T√≥pico 7: Linguagem de M√°quina: Recursividade e I/O (C.2)(T_3)\n*   **Linha 4 (Semana de 14/2 a 16/2):**\n    *   T√≥pico 8: Aritm√©tica Computacional: Inteiros (C.3)\n    *   T√≥pico 9: Aritm√©tica Computacional: ULA (C.3)(T_4) (ULA - Unidade L√≥gica e Aritm√©tica)\n*   **Linha 5 (Semana de 21/2 a 23/2):**\n    *   T√≥pico 10: Aritm√©tica Computacional: Fracion√°rios, IEEE 754 (C.3)\n    *   T√≥pico 11: Outras Arquiteturas (T_5)\n*   **Linha 6 (Semana de 28/2 a 2/3):**\n    *   Indica um FERIADO\n    *   Lab 1A: Software ‚Äì Rars (T_6) (Rars √© um simulador de MIPS Assembly)\n*   **Linha 7 (Semana de 7/3 a 9/3):**\n    *   Lab 1B: Software ‚Äì Compilador C\n    *   Lab 2: Hardware ‚Äì Verilog ‚Äì ULA (T_7) (Verilog √© uma Hardware Description Language - HDL)\n*   **Linha 8 (Semana de 14/3 a 16/3):**\n    *   Avalia√ß√£o: 1¬™ Prova (P1)\n    *   T√≥pico 12: Processador Uniciclo: Unidade Operativa (C.4) (T_8)\n*   **Linha 9 (Semana de 21/3 a 23/3):**\n    *   T√≥pico 13: Processador Uniciclo: Unidade de Controle (C.4) (L_1)\n    *   Lab 3: Processador Uniciclo (T_9) (L_2)\n*   **Linha 10 (Semana de 28/3 a 30/3):**\n    *   T√≥pico 14: Processador Multiciclo: Unidade Operativa (C.4)\n    *   T√≥pico 15: Processador Multiciclo: Unidade de Controle (C.4) (T_10)\n*   **Linha 11 (Semana de 4/4 a 6/4):**\n    *   Lab 4: Processador Multiciclo\n    *   T√≥pico 16: Processador Pipeline: Conceitos (C.4)(L_3)\n*   **Linha 12 (Semana de 11/4 a 13/4):**\n    *   T√≥pico 17: Pipeline: Unidade Operativa e Controle (C.4)\n    *   Lab 5: Processador Pipeline (T_12)\n*   **Linha 13 (Semana de 18/4 a 20/4):**\n    *   T√≥pico 18: Exce√ß√£o e Interrup√ß√£o (C.4) (L_4)\n    *   T√≥pico 19: Mem√≥ria: Hierarquia (C.5) (T_13)\n*   **Linha 14 (Semana de 25/4 a 27/4):**\n    *   T√≥pico 19.1: Mem√≥ria: Cache (C.5)\n    *   Avalia√ß√£o: 2¬™ Prova (P2) (L_5)\n*   **Linha 15 (Semana de 2/5 a 4/5):**\n    *   Avalia√ß√£o: Prova Substitutiva\n    *   Avalia√ß√£o: Apresenta√ß√£o dos Projetos (P_N) (T_15)\n\n**Diagramas:**\nO slide n√£o exibe diagramas visuais diretamente. Contudo, os t√≥picos listados (\"Processador Uniciclo: Unidade Operativa\", \"Processador Uniciclo: Unidade de Controle\", \"Processador Multiciclo\", \"Processador Pipeline\", \"Mem√≥ria: Hierarquia\", \"Mem√≥ria: Cache\") indicam que esses conceitos, frequentemente representados por diagramas de datapath e controle, bem como hierarquias de mem√≥ria, ser√£o abordados ao longo do curso. A men√ß√£o a \"Unidade Operativa\" e \"Unidade de Controle\" para processadores uniciclo e multiciclo, e \"Pipeline\", sugere a an√°lise detalhada da arquitetura de CPU, incluindo a descri√ß√£o de est√°gios de pipeline (IF, ID, EX, MEM, WB) e o fluxo de dados e controle. A hierarquia de mem√≥ria, incluindo cache, implica a discuss√£o sobre n√≠veis de cache (L1, L2, L3), pol√≠ticas de substitui√ß√£o e mapeamento, e seu impacto no desempenho.\n\n**Conte√∫do Adicional:**\n√Ä esquerda, h√° uma janela de chat intitulada \"Bate-papo p√∫blico\", com mensagens de alunos interagindo com o professor ou entre si, algumas delas contendo questionamentos sobre o andamento da aula ou temas administrativos. O professor, Marcus Vinicius Lamar, √© vis√≠vel na parte inferior direita da tela, aparentemente apresentando o material.\n\nEm resumo, o slide fornece uma vis√£o detalhada do plano de estudos de uma disciplina de Arquitetura de Computadores, cobrindo t√≥picos fundamentais desde o desempenho do sistema, conjunto de instru√ß√µes (ISA), linguagem Assembly, aritm√©tica computacional (inteiros, ponto flutuante, ULA), arquiteturas de processadores (uniciclo, multiciclo, pipeline), at√© gerenciamento de mem√≥ria (hierarquia, cache) e tratamento de exce√ß√µes. A inclus√£o de laborat√≥rios com Rars (Assembly MIPS) e Verilog (descri√ß√£o de hardware) denota uma abordagem pr√°tica para a compreens√£o dos conceitos te√≥ricos.",
        "transcription": "Depois voc√™s leem as conclus√µes. Ent√£o vamos para a aulinha de hoje. Para a aulinha de hoje ent√£o j√° que a gente acabou de ver a arquitetura RISC-V",
        "video_source": "OAC_2022-02-23.mp4"
    },
    {
        "id": 8,
        "timestamp_start": 1802.39,
        "timestamp_end": 1804.39,
        "slide_description": "Como Engenheiro de Computa√ß√£o S√™nior, procedo com a an√°lise do slide e do contexto da aula de Arquitetura de Computadores, conforme solicitado.\n\nA imagem apresenta uma tela de confer√™ncia web em tempo real, indicando uma aula online. No topo, h√° o t√≠tulo \"Confer√™nciaWeb - Sala de Aula de OAC\" (onde OAC provavelmente significa Organiza√ß√£o e Arquitetura de Computadores) e um temporizador exibindo \"30:09\". O professor, identificado como Marcus Vinicius Lamar, est√° vis√≠vel em um feed de webcam no canto inferior direito da tela.\n\nO conte√∫do central da apresenta√ß√£o, que seria o slide em tela cheia, n√£o est√° diretamente vis√≠vel. Em vez disso, o professor est√° compartilhando a √°rea de trabalho do Windows, que exibe um papel de parede com o logo da \"Universidade de Bras√≠lia\", \"Departamento de Ci√™ncia da Computa√ß√£o\", e a men√ß√£o ao \"Prof. Marcus Vinicius Lamar\".\n\nNa barra de tarefas inferior, h√° pr√©-visualiza√ß√µes de duas apresenta√ß√µes em PowerPoint abertas:\n1.  **\"OAC_10_Aritm√©tica_Fracion√°ria_.pptx\"**: Este arquivo sugere que o conte√∫do program√°tico anterior ou adjacente √† aula atual aborda t√≥picos de representa√ß√£o num√©rica fracion√°ria em sistemas computacionais. Isso tipicamente inclui Aritm√©tica de Ponto Fixo e Ponto Flutuante (normas IEEE 754), convers√µes, precis√£o, e o impacto dessas representa√ß√µes em opera√ß√µes aritm√©ticas. Embora o conte√∫do espec√≠fico do slide em miniatura n√£o seja leg√≠vel, a tem√°tica √© fundamental para a compreens√£o de c√°lculos em arquiteturas.\n2.  **\"OAC_11_Outras_Arquiteturas_a.pptx\"**: Este √© o arquivo que est√° atualmente selecionado (indicado por um cursor de mouse em forma de seta vermelha sobre ele). O t√≠tulo indica um foco em \"Outras Arquiteturas\", o que, no contexto de Arquitetura de Computadores, pode abranger uma vasta gama de t√≥picos para al√©m das arquiteturas cl√°ssicas Von Neumann ou Harvard. Potenciais subt√≥picos incluem:\n    *   **Arquiteturas Paralelas**: SIMD (Single Instruction, Multiple Data) como GPUs, MIMD (Multiple Instruction, Multiple Data) como sistemas multiprocessados ou multicore.\n    *   **Arquiteturas Espec√≠ficas**: VLIW (Very Long Instruction Word), EPIC (Explicitly Parallel Instruction Computing), processadores vetoriais, FPGAs (Field-Programmable Gate Arrays).\n    *   **Sistemas Distribu√≠dos**: Conceitos de cluster computing ou grid computing, embora menos prov√°vel para uma aula introdutinal de arquitetura.\n    *   **Hierarquias de Mem√≥ria Avan√ßadas**: Organiza√ß√£o de cache multi-n√≠vel, mem√≥ria n√£o-uniforme (NUMA), ou mem√≥rias especializadas (e.g., HBM).\n    A miniatura deste slide exibe o que parece ser um diagrama de blocos com interconex√µes, possivelmente ilustrando componentes de uma arquitetura espec√≠fica ou o fluxo de dados entre diferentes unidades de processamento ou mem√≥ria. N√£o √© poss√≠vel discernir detalhes textuais ou simb√≥licos do diagrama devido √† sua baixa resolu√ß√£o na pr√©-visualiza√ß√£o.\n\nNo lado esquerdo da interface de confer√™ncia, h√° um painel de chat p√∫blico (\"Bate-papo p√∫blico\") com v√°rias mensagens trocadas entre alunos e, possivelmente, o professor. Partes leg√≠veis das mensagens incluem:\n*   \"Nesse caso, tor√ßo para consiga fazer tudo at√© segunda\" (Eduardo)\n*   \"sim kkk\" (Michel Luis Duwe)\n*   \"boa tarde Prof Lamar\" (Jo√£o Alberto Travas)\n*   \"64\" (Maycon Vinnycys S...) ‚Äì Este n√∫mero pode ser uma resposta a uma pergunta, talvez sobre largura de barramento, quantidade de registradores, ou um valor de dado.\n*   \"s√≥ trocar a ordem\" (Maycon Vinnycys S...) ‚Äì Sugere uma discuss√£o sobre sequenciamento de instru√ß√µes ou organiza√ß√£o de dados.\n*   \"esqueci de perguntar sobre a elei√ß√£o do representante do CIC/IE\" (Eduardo Ferreira M...) ‚Äì Uma quest√£o administrativa.\n*   \"a0 acho\", \"f0\", \"fa0\" (Maycon Vinnycys S..., Eduardo Ferreira M...) ‚Äì Estes podem ser valores em hexadecimal, refer√™ncias a endere√ßos de mem√≥ria, registradores, ou identificadores de algum tipo.\n*   \"Acesso mais devagar?\" (Victor Hugo Rodrig...) ‚Äì Poss√≠vel discuss√£o sobre lat√™ncia de mem√≥ria, velocidade de E/S, ou gargalos de performance.\n*   \"gasta t de processamento\" (Jo√£o Alberto Travas...) ‚Äì Corrobora a discuss√£o sobre performance ou custo computacional.\n*   \"ob prof\", \"j√≥ia\" (Jo√£o Alberto Travas) ‚Äì Fechamento de uma intera√ß√£o.\n\nEm resumo, a aula de Arquitetura de Computadores, ministrada pelo Prof. Marcus Vinicius Lamar da Universidade de Bras√≠lia, est√° em um ponto de transi√ß√£o entre os t√≥picos de Aritm√©tica Fracion√°ria e \"Outras Arquiteturas\". A discuss√£o no chat sugere engajamento dos alunos com conceitos que podem envolver representa√ß√£o num√©rica, sequenciamento de opera√ß√µes e aspectos de performance, elementos cruciais para a compreens√£o de arquiteturas de computadores modernas e especializadas. O pr√≥ximo t√≥pico de \"Outras Arquiteturas\" √© de alta relev√¢ncia para sistemas de busca sem√¢ntica, indicando que o conte√∫do pode descrever modelos de computa√ß√£o al√©m do paradigma uniprocessador, como paralelismo e aceleradores.",
        "transcription": "Vamos ver, ent√£o.",
        "video_source": "OAC_2022-02-23.mp4"
    },
    {
        "id": 9,
        "timestamp_start": 1804.39,
        "timestamp_end": 1814.39,
        "slide_description": "Como Engenheiro de Computa√ß√£o S√™nior, analiso o slide e o contexto anotado da aula de Arquitetura de Computadores.\n\nO ambiente visual representa uma plataforma de confer√™ncia web ou aula online, com foco em uma sess√£o de \"Sala de Aula de OAC\" (Arquitetura de Computadores).\n\n1.  **Transcri√ß√µes de Texto:**\n\n    *   **Abas do Navegador:** \"Confer√™nciaWeb - Sala de Au\", \"ADD ADD (x86 Instruction Set Re\" (parcialmente vis√≠veis).\n    *   **Painel Esquerdo (Navega√ß√£o/Ferramentas):**\n        *   **MENSAGENS**\n            *   Perguntas\n            *   Bate-papo p√∫... (selecionado)\n        *   **NOTAS**\n            *   Notas comparti...\n        *   **USU√ÅRIOS (23)**\n            *   Marcus... (Voc√™)\n            *   Andre Carval...\n            *   Arthur Brasa ...\n            *   Bruno Vargas...\n            *   Eduardo Ferr...\n            *   Felipe Dantas...\n            *   Filipe de Sou...\n            *   Gabriel Kenji...\n            *   Gustavo Lope...\n            *   Gustavo Pierr...\n            *   Gustavo Rodr...\n    *   **Painel de Bate-papo (Bate-papo p√∫blico):**\n        *   **T√≠tulo:** `< Bate-papo p√∫blico`\n        *   **Mensagens (com remetente e timestamp):**\n            *   Ed: \"Nesse caso, tor√ßo para consiga fazer tudo at√© segunda\"\n            *   Michel Luis Duwe: \"sim kkk\" (13:53)\n            *   Jo√£o Alberto Travas...: \"boa tarde Prof Lamar\" (14:00)\n            *   Maycon Vinnycius S...: \"64\" (14:11)\n            *   Maycon Vinnycius S...: \"s√≥ trocar a ordem\" (14:14)\n            *   Eduardo Ferreira M...: \"esqueci de perguntar sobre a elei√ß√£o do representante do CIC/IE\" (14:17)\n            *   Maycon Vinnycius S...: \"a0 acho\" (14:21)\n            *   Eduardo Ferreira M...: \"f0\" (14:22)\n            *   Eduardo Ferreira M...: \"fa0\" (14:22)\n            *   Victor Hugo Rodrig...: \"Acesso mais devagar?\" (14:25)\n            *   Jo√£o Alberto Travas...: \"gasta t de processamento\" (14:25)\n            *   Jo√£o Alberto Travas...: \"ob prof\" (14:25)\n            *   Jo√£o Alberto Travas...: \"j√≥ia\" (14:28)\n        *   **Campo de entrada:** \"Enviar mensagem para B\" (parcialmente vis√≠vel).\n    *   **Barra Superior (Controles da Sala):**\n        *   \"Sala de Aula de OAC\"\n        *   **Indicador de Grava√ß√£o:** C√≠rculo vermelho com \"30:10\" (tempo decorrido da grava√ß√£o).\n        *   **Palestrante Ativo:** \"Marcus Vinicius Lam...\" (parcialmente vis√≠vel).\n    *   **Barra Inferior (Controles de M√≠dia):** √çcones para microfone (ativo), fone de ouvido (ativo), c√¢mera (inativo/riscado), e chat (ativo).\n\n2.  **Diagramas, Estrutura e Fluxo de Dados:**\n\n    *   A √°rea principal de exibi√ß√£o do conte√∫do da aula encontra-se completamente vazia e escura. N√£o h√° diagramas de Datapath, Pipeline, Hierarquia de Mem√≥ria, c√≥digo (Assembly, C, Verilog) ou qualquer outro conte√∫do visual t√©cnico relevante √† Arquitetura de Computadores sendo apresentado neste momento no slide.\n    *   O foco visual est√° unicamente na interface da plataforma de confer√™ncia, que inclui o painel de usu√°rios e, predominantemente, o painel de chat com as intera√ß√µes textuais dos participantes.\n\n3.  **An√°lise do Conte√∫do para RAG:**\n\n    O slide captura um momento de intera√ß√£o ass√≠ncrona ou secund√°ria √† apresenta√ß√£o principal da aula. Embora n√£o haja conte√∫do t√©cnico visual direto na tela principal, o chat fornece metadados e poss√≠veis t√≥picos de discuss√£o:\n\n    *   **Identifica√ß√£o do Curso:** Arquitetura de Computadores (OAC).\n    *   **Professor Mencionado:** Prof Lamar.\n    *   **T√≥picos Impl√≠citos/Quest√µes:**\n        *   \"64\" (pode referir-se a arquitetura de 64 bits, valores num√©ricos, endere√ßamento).\n        *   \"s√≥ trocar a ordem\" (pode indicar reordena√ß√£o de instru√ß√µes, pipeline, bytes em mem√≥ria ‚Äì endianness).\n        *   \"f0\", \"fa0\" (poss√≠veis refer√™ncias a registradores em arquiteturas RISC como MIPS ou RISC-V, ou valores hexadecimais).\n        *   \"Acesso mais devagar?\", \"gasta t de processamento\" (discuss√µes sobre desempenho, lat√™ncia de mem√≥ria, custo computacional).\n        *   \"elei√ß√£o do representante do CIC/IE\" (contexto administrativo ou institucional da aula).\n    *   **Estado da Aula:** Grava√ß√£o em andamento (30:10), indicando uma parte de uma aula maior. O conte√∫do visual da apresenta√ß√£o est√° ausente no momento da captura.\n\nPara um sistema RAG, este slide contribui com o contexto de comunica√ß√£o e intera√ß√£o dos alunos em uma aula de Arquitetura de Computadores, mencionando t√≥picos t√©cnicos de forma breve no chat, mas sem apresentar o material instrucional visual prim√°rio.",
        "transcription": "outras arquiteturas. Que outras arquiteturas? Mais especificamente ARM e x86.",
        "video_source": "OAC_2022-02-23.mp4"
    },
    {
        "id": 10,
        "timestamp_start": 1816.39,
        "timestamp_end": 1906.39,
        "slide_description": "Como Engenheiro de Computa√ß√£o S√™nior, a an√°lise do slide da aula de Arquitetura de Computadores revela o seguinte conte√∫do para um sistema de busca sem√¢ntica:\n\nO slide √© intitulado \"Aula 11: Arquiteturas ARMv7 e x86\", com a especifica√ß√£o \"32 Bits\", indicando um foco inicial nas vers√µes de 32 bits dessas arquiteturas de conjunto de instru√ß√µes. A afilia√ß√£o institucional √© claramente vis√≠vel, sendo a \"Universidade de Bras√≠lia\", do \"Departamento de Ci√™ncia da Computa√ß√£o\", com a men√ß√£o de que a aula faz parte da disciplina \"CIC0003 - Introdu√ß√£o aos Sistemas Computacionais\", ministrada pelo \"Prof. Marcus Vinicius Lamar\".\n\nA se√ß√£o principal do slide apresenta uma compara√ß√£o direta sob o t√≠tulo \"ARM VS x86\".\n1.  **ARM (lado esquerdo):** √â categorizado como uma arquitetura \"RISC\" (Reduced Instruction Set Computer). Acompanhando o texto, h√° uma colagem de imagens de diversos dispositivos tipicamente alimentados por processadores ARM, como smartphones, tablets, um mini-PC (possivelmente um single-board computer como Raspberry Pi) e outros dispositivos embarcados ou m√≥veis, ilustrando sua preval√™ncia em segmentos de baixo consumo de energia e alto volume.\n2.  **x86 (lado direito):** √â categorizado como uma arquitetura \"CISC\" (Complex Instruction Set Computer). As imagens associadas ao x86 mostram componentes de computadores de mesa e laptops, incluindo CPUs Intel (identific√°veis pela marca Intel), m√≥dulos de mem√≥ria, placas-m√£e, e uma torre de computador de mesa, destacando sua domin√¢ncia no mercado de desktops e servidores de prop√≥sito geral.\n\nO conte√∫do do bate-papo p√∫blico, embora informal, oferece insights sobre os t√≥picos de discuss√£o paralelos ou perguntas dos alunos:\n*   **\"64\" (14:11):** Sugere uma discuss√£o ou questionamento sobre a transi√ß√£o ou compara√ß√£o com arquiteturas de 64 bits, o que √© um tema natural ao abordar ARM e x86, mesmo quando o slide foca em 32 bits.\n*   **\"s√≥ trocar a ordem\" (14:14):** Pode referir-se a conceitos como reordena√ß√£o de instru√ß√µes (out-of-order execution), ordena√ß√£o de bytes (endianness) ou ordem de acesso √† mem√≥ria, todos pertinentes √† microarquitetura e organiza√ß√£o de computadores.\n*   **\"f0\", \"fa0\" (14:22):** S√£o valores hexadecimais que poderiam representar endere√ßos de mem√≥ria, valores de registradores, ou mesmo partes de opcodes em exemplos de Assembly, indicando uma discuss√£o t√©cnica detalhada.\n*   **\"Acesso mais devagar?\" (14:25):** E a resposta subsequente \"gasta t de processamento\" (gasta tempo de processamento) indicam um di√°logo sobre desempenho, lat√™ncia de acesso √† mem√≥ria, ou gargalos de processamento, aspectos cruciais na an√°lise comparativa de arquiteturas.\n\nEm resumo, o slide aborda fundamentalmente a compara√ß√£o entre as arquiteturas ARMv7 (RISC) e x86 (CISC) no contexto de 32 bits, ilustrando seus dom√≠nios de aplica√ß√£o e caracter√≠sticas gerais, complementado por uma intera√ß√£o de alunos que toca em t√≥picos avan√ßados como 64 bits, reordena√ß√£o, valores de registradores/endere√ßos e implica√ß√µes de desempenho.",
        "transcription": "ARM e x86. O ARM, tirando desse ano que eles lan√ßaram uma vers√£o v9 da arquitetura ARM, at√© o ano passado o ARM existia a vers√£o v7 e a vers√£o v8. A vers√£o v7 era de 32 bits e a v8 era de 64 bits. Nesse ano eles lan√ßaram uma nova vers√£o v9 que eu ainda n√£o estudei. Ent√£o vamos falar s√≥ dessas outras duas vers√µes que existiam at√© o ano passado. Continuam existindo, s√≥ que eles lan√ßaram uma vers√£o nova. A arquitetura ARM. E como a gente est√° trabalhando com 32 bits, a gente vai ver s√≥ a v7, a gente n√£o vai ver a v8. Para a gente poder comparar diretamente um processador ARM com o nosso RISC-V de 32 bits. Assim como o x86. O x86 mesmo √© de 32 bits. E o x64 e o... eu sempre me confundo com essa sigla. Especialmente me confundo com o x64 que √© o nome da ISA 64 bits do x86. Mas n√£o vai crer. A gente vai ver alguns aspectos do x86 original. Precisamente isso que prevalecia naquele tempo em que a Intel adotou a pr√°tica de retrocompatibilidade. Portanto, tudo que a gente v√™ aqui dos processadores tamb√©m √© obsoleto.",
        "video_source": "OAC_2022-02-23.mp4"
    },
    {
        "id": 11,
        "timestamp_start": 1908.39,
        "timestamp_end": 7019.01,
        "slide_description": "O slide de uma aula de Arquitetura de Computadores, da disciplina \"UnB - CIC0099 ‚Äì Organiza√ß√£o e Arquitetura de Computadores\" ministrada pelo Prof. Marcus Vinicius Lamar, foca nas \"Diferen√ßas: Instru√ß√µes com condi√ß√£o\".\n\nO conte√∫do textual principal na lateral esquerda explica que \"A maior parte das instru√ß√µes da ISA ARMv7 s√£o condicionais\". Complementa que \"Isto √©, possuem 4 bits (cond) que determinam se a instru√ß√£o deve ser executada ou n√£o, dependendo dos bits ZNCV do registrador CPSR.\"\n\nO elemento central do slide √© a \"Table A8-1 Condition codes\", que detalha as condi√ß√µes de execu√ß√£o para instru√ß√µes. A tabela √© composta por cinco colunas:\n1.  **cond**: Representa o c√≥digo bin√°rio de 4 bits para a condi√ß√£o.\n2.  **Mnemonic extension**: A extens√£o mnem√¥nica textual usada na instru√ß√£o.\n3.  **Meaning (integer)**: O significado da condi√ß√£o para opera√ß√µes com inteiros.\n4.  **Meaning (floating-point) a**: O significado da condi√ß√£o para opera√ß√µes de ponto flutuante (com uma nota de rodap√© \"a\").\n5.  **Condition flags**: As combina√ß√µes espec√≠ficas dos bits de flag (Z, N, C, V) no registrador CPSR que devem ser verdadeiras para que a condi√ß√£o seja atendida.\n\nAs linhas da tabela descrevem 15 condi√ß√µes distintas e uma condi√ß√£o incondicional:\n*   **0000 EQ**: Equal (Igual), para inteiros e ponto flutuante, quando `Z == 1`.\n*   **0001 NE**: Not equal (N√£o igual), para inteiros e ponto flutuante (ou n√£o ordenado), quando `Z == 0`.\n*   **0010 CS b**: Carry set (Carry definido), para inteiros (Maior que, igual a, ou n√£o ordenado para ponto flutuante), quando `C == 1`. (com nota de rodap√© \"b\")\n*   **0011 CC c**: Carry clear (Carry limpo), para inteiros (Menor que para ponto flutuante), quando `C == 0`. (com nota de rodap√© \"c\")\n*   **0100 MI**: Minus, negative (Menos, negativo), para inteiros e ponto flutuante, quando `N == 1`.\n*   **0101 PL**: Plus, positive or zero (Mais, positivo ou zero), para inteiros (Maior que, igual a, ou n√£o ordenado para ponto flutuante), quando `N == 0`.\n*   **0110 VS**: Overflow (Estouro), para inteiros (N√£o ordenado para ponto flutuante), quando `V == 1`.\n*   **0111 VC**: No overflow (Sem estouro), para inteiros (N√£o ordenado para ponto flutuante), quando `V == 0`.\n*   **1000 HI**: Unsigned higher (Sem sinal maior), para inteiros (Maior que, ou n√£o ordenado para ponto flutuante), quando `C == 1 and Z == 0`.\n*   **1001 LS**: Unsigned lower or same (Sem sinal menor ou igual), para inteiros (Menor ou igual para ponto flutuante), quando `C == 0 or Z == 1`.\n*   **1010 GE**: Signed greater than or equal (Com sinal maior ou igual), para inteiros e ponto flutuante, quando `N == V`.\n*   **1011 LT**: Signed less than (Com sinal menor), para inteiros (Menor que, ou n√£o ordenado para ponto flutuante), quando `N != V`.\n*   **1100 GT**: Signed greater than (Com sinal maior), para inteiros e ponto flutuante, quando `Z == 0 and N == V`.\n*   **1101 LE**: Signed less than or equal (Com sinal menor ou igual), para inteiros (Menor que, igual a, ou n√£o ordenado para ponto flutuante), quando `Z == 1 or N != V`.\n*   **1110 None (AL) d**: Always (unconditional) (Sempre, incondicional), para inteiros e ponto flutuante, aplica-se a `Any` (qualquer combina√ß√£o de flags). (com nota de rodap√© \"d\")\n\nO slide descreve um aspecto fundamental da arquitetura ARMv7, que √© o controle de fluxo atrav√©s de execu√ß√£o condicional de instru√ß√µes, diferenciando-se de outras arquiteturas que podem usar principalmente branches condicionais. N√£o h√° diagramas visuais como datapath, pipeline ou hierarquia de mem√≥ria. O foco √© puramente textual e tabular, delineando as regras para a execu√ß√£o condicional baseada nos flags do processador.",
        "transcription": "Ent√£o a arquitetura ARMv7, originalmente, ela foi desenvolvida na d√©cada de 80 e visava uma arquitetura de baixo consumo. Ent√£o, foi muito popular em sistemas port√°teis, celulares, tablets, sistemas GPS e um monte de outras coisas que utilizam ARM. Por que de baixo consumo? Foi produzida pela ARM Holdings, que era brit√¢nica. E eu n√£o tenho certeza se isso aqui se concretizou ou n√£o. Quer dizer, a ARM foi comprada pela Nvidia mesmo? Ou barraram essa compra devido a quebrar meio antitruste? Pelo que sei, tudo √© da Disney, essa √© boa. T√°? Eu acho que a Nvidia tentou comprar a ARM, mas eu acho que foi barrada por algum desses conselhos financeiros internacionais. Porque sen√£o a Nvidia ia ficar com um monop√≥lio muito grande. O pre√ßo era 40 bilh√µes. Da√≠ por isso que eu botei esse nome de continua√ß√£o, porque eu n√£o sabia se at√© hoje tinha sido concretizado isso ou n√£o. Mas pelo visto n√£o. ARM significa Acorn. Acorn RISC Machine. O nome de Acorn era o nome da empresa, que mais tarde se transformou em Advanced RISC Machine. Porque Advanced √© algo mais pra frente. Indicando que ele √© mais avan√ßado. Depois de 2020 eu preciso atualizar esses slides aqui, pelo amor de Deus. 6,7 bilh√µes de unidades vendidas em 2020. Enquanto isso, na mesma √©poca, o x86 vendeu menos de 500 milh√µes de processadores. Ent√£o nota-se que aqui o volume de processadores vendidos √© muito maior que esse aqui. S√≥ que esse aqui tem um custo muito maior que esse. Certo? Que torna ent√£o os lucros aqui maiores. Ent√£o √© de baixo consumo. A Intel tentou fazer uma arquitetura de baixo consumo que foi o Atom. N√£o deu certo. E agora a 12¬™ gera√ß√£o de processadores Core. Processadores Core. Eles est√£o pegando... Acho que eu j√° fiz isso pra voc√™s. A ideia do chip h√≠brido. A gente tem agora dentro do x86. Quatro processadores grandes e quatro processadores pequenos. Que √© a mesma ideia que a ARM utiliza. Quatro processadores grandes e quatro processadores pequenos. De modo a se n√£o estiver exigindo muito do computador, ent√£o usa os processadores pequenos, que economizam energia. J√° quando voc√™ precisa de um maior poder de computa√ß√£o, de processamento, a√≠ ele aciona os quatro maiores. Ent√£o a Intel com essa 12¬™ gera√ß√£o est√° tentando fazer coisas de baixo consumo. Ok. Ent√£o de baixo consumo. Custos acess√≠veis. Integrados a projetos propriet√°rios. O que isso aqui significa? Significa que se voc√™ est√° desenvolvendo um chip, voc√™ pode colocar dentro dele um processador ARM. Desde que voc√™ pague royalties por aquele processador ARM. Ent√£o voc√™ pode ter um processador ARM dentro de um chip e mais um monte de outras coisas. Certo? Usados em Raspberry Pi, BeagleBone Black, PandaBoard e outros single-board computers. Ent√£o Raspberry Pi √©... The Pi √© por um ARM. E assim tem o BeagleBone Black tamb√©m e v√°rios outros sisteminhas. S√≥ que em sistemas antigos. Quer dizer. Praticamente toda a circuitaria est√° aqui dentro, utilizando ARM. Ok. Vamos verificar ent√£o as semelhan√ßas que existem entre o ARM e o RISC-V. E depois as diferen√ßas. Ent√£o. Primeiro. O ARM foi lan√ßado em 1975. Mas o desenvolvimento dele j√° vinha desde o in√≠cio da d√©cada de 80. Enquanto o RISC-V √© mais moderno. O desenvolvimento dele come√ßou em 2010. E ele foi efetivamente lan√ßado em 2015. Instruction Size. Quer dizer. O tamanho da instru√ß√£o. Os dois t√™m instru√ß√µes de 32 bits. Ent√£o isso aqui n√£o √© s√≥ o tamanho do registrador, √© o tamanho da instru√ß√£o tamb√©m. Ent√£o os dois seguem a mesma filosofia. 32 bits para a instru√ß√£o. O endere√ßo de... O espa√ßo de endere√ßamento, n√©. J√° que a gente est√° trabalhando aqui com um de 32 bits. √â 32 bits flat. Quer dizer. Eu consigo acessar a mem√≥ria em qualquer um dos seus 4 giga endere√ßos. Certo. Ent√£o isso que significa 32 bits flat. Meu processador consegue acessar qualquer elemento da mem√≥ria de 4 giga. Ent√£o. Data align. Os dois requerem que os dados estejam alinhados. Quer dizer. Em outras palavras. Seria armazenados em endere√ßos m√∫ltiplos de 4. Ou m√∫ltiplos de 2. Ent√£o. Eles necessitam que os dados estejam alinhados. Existem processadores que trabalham com dados n√£o alinhados. Tem. S√≥ que o hardware fica mais complicado. Bem mais complicado. Ent√£o eles preferiram simplificar. E exigir que os dados estejam alinhados. Addressing modes. Isso aqui n√≥s vamos ver mais para frente. Mas s√≥ tem 3 b√°sicos. O ARM tem 9. E aqui j√° come√ßa a aparecer as diferen√ßas entre o ARM e o RISC-V. N√∫mero de registradores. Ent√£o. O RISC-V tem 31 registradores. Porque o R0 n√£o √© bem registrador. Por isso que eles colocam 31. E. De 32 bits. Enquanto aqui tem 15 registradores de general purpose register. GPR. Ent√£o. Registrador de prop√≥sito geral. Ent√£o. Tamb√©m. Isso aqui √© metade do n√∫mero de registradores que tem o RISC-V. E. I/O. Os dois s√£o memory mapped. Quer dizer. Se eu quero acessar um dispositivo de I/O. Eu vou acessar um endere√ßo da mem√≥ria. S√≥ que naquele endere√ßo da mem√≥ria. Tem o meu dispositivo l√°. Certo. O ARMv8 √© muito mais similar ao RISC-V 64 e ao MIPS64 do que o V7 com o RISC-V 32. Que √© o que a gente est√° vendo aqui. V7. E o RISC-V 32. J√° sei. Olha s√≥. Isso aqui era um dos livros do Patterson. Comparando o ARM com o MIPS. Essa figurinha aqui. Patterson tamb√©m comete erros. Principalmente em livros. Em geral. Ok. Exemplo de instru√ß√µes. Ent√£o. Para o ARM e para o RISC-V. Ent√£o. Para a adi√ß√£o. O ARM tem o ADD. E o RISC-V. A gente tem o ADD. E o ADDI. O RISC-V. O ARM tem o ADD que detecta overflow. Que √© o ADDS. Certo. Ent√£o. Esse ADDS. Ele detecta se aconteceu overflow. O RISC-V n√£o tem isso. O RISC-V n√£o detecta overflow. Subtra√ß√£o. SUB. Subtra√ß√£o. Com... Com... Com... Com... Com... Com... Multiplica√ß√£o. Ele tem o MUL. E n√≥s temos aqui. N√©. O MUL e o MULH. Divis√£o. O ARM n√£o tem. Divis√£o inteira. Isso aqui √© interessante. Certo. Por que. N√≥s vamos ver no laborat√≥rio. Que a implementa√ß√£o desse DIV, DIVU aumenta muito a complexidade do circuito. Aumenta muito. Ent√£o, o RISC-V tem o DIV e o DIVU. E aqui, Square Root, igual, muito. S√≥ tem o RISC-V, o ARM n√£o tem. Os shifts l√≥gicos e aritm√©ticos, n√≥s temos similares tamb√©m. Compara√ß√£o, o ARM tem instru√ß√£o de compara√ß√£o mesmo e de testes. E a gente tem aqui os SETs da vida. Acesso √† mem√≥ria. Ent√£o, tem os Load Byte, Load Halfword, Load Word, tal qual a gente tem aqui tamb√©m. Nesse caso aqui, leitura e escrita em registradores especiais. Aqui eles t√™m essas instru√ß√µes e a gente vai ter as instru√ß√µes CSR, que n√≥s vamos ver mais adiante, quando a gente v√™ interrup√ß√µes e exce√ß√µes. A√≠ a gente vai ver essas instru√ß√µes CSR. E atomic exchange, que √© para quando tem m√∫ltiplos n√∫cleos acessando a mem√≥ria. Ent√£o, a gente tem instru√ß√µes que previnem dois processadores estarem querendo escrever, quer dizer, acessar um determinado endere√ßo de mem√≥ria ao mesmo tempo. Ent√£o, tanto o ARM quanto o RISC-V, a gente tem instru√ß√µes que se tu tentar ler e o outro est√° escrevendo, esse aqui vai esperar esse aqui acabar de escrever para ent√£o ler. E a mesma coisa, se esse aqui est√° lendo e se ele quiser escrever, ele vai esperar esse aqui acabar de ler para depois escrever naquela posi√ß√£o. Ent√£o, √© o que se chama de instru√ß√µes at√¥micas. Modos de endere√ßamento. RISC-V, a gente s√≥ tem esses tr√™s modos aqui. Ent√£o, quais s√£o eles? Operando no registrador. Segundo, o operando √© imediato. Terceiro, o operando est√° na mem√≥ria, nesse endere√ßo aqui. Registrador, mais um offset e um registrador aqui. Registrador de base. Certo? Ent√£o, no RISC-V, a gente s√≥ tem esses tr√™s. No ARM, a gente ainda tem esses tr√™s. No ARM, a gente ainda tem esses tr√™s. Tem todos esses outros aqui. Ent√£o, vamos s√≥ entender o que √©. √â um registrador, mais um registrador indexado. O que isso aqui significa? Que eu posso estar somando aqui quantos registradores. Registrador 0, registrador 1, registrador 2, registrador 3. Selecionando isso atrav√©s do √≠ndice do registrador. Ent√£o, o endere√ßo vai ser dado por esse registrador, mais esse outro registrador aqui. Registrador, mais um registrador escalado. O que isso significa? Que tu pode ter o teu endere√ßo de base no registrador. E tu tem um outro registrador, que vai ter um n√∫mero, que tu vai poder escalar ele. Escalar significa o qu√™? Multiplicar por 2, multiplicar por 4, multiplicar por 8. E esse valor multiplicado, escalado, vai ser somado ao registrador original. Para identificar qual √© o endere√ßo que ele vai acessar. Registrador, mais um offset. Que seria igual a esse aqui, que s√≥ tem o displacement aqui. Ent√£o, registrador, mais um offset. E atualiza√ß√£o do registrador. Quer dizer, eu vou acessar a mem√≥ria nesse endere√ßo registrador, mais um offset. E esse valor aqui vai ser atualizado nesse registrador. Eu vou, a mesma coisa aqui. Um registrador, mais outro registrador. Eu vou acessar o dado que est√° nesse endere√ßo. E vou fazer update, atualizar esse registrador aqui. Quer dizer, calculo o endere√ßo a partir dessa soma. Ao finalizar a leitura, ele vai escrever nesse registrador aqui, esse endere√ßo para o qual ele leu. Autoincremento e autodecremento. Quer dizer, tem ent√£o, mais mais e menos menos. Que tem em Python e C. Ent√£o eles t√™m tamb√©m. Ent√£o uma instru√ß√£o que incrementa o registrador e decrementa o registrador. E outra coisa aqui. PC relative data. Quer dizer, um dado relativo ao PC. O que √© PC? PC √© o que mesmo? O que que tem no registrador PC? O que que tem no registrador PC? Algu√©m vai me dizer. A√≠ vai ser aquela que a resposta est√° correta. √â, n√£o √© a pr√≥xima instru√ß√£o. √â a instru√ß√£o que est√° sendo executada. Certo? Ent√£o, esse modo de endere√ßamento aqui que s√≥ tem no ARM. Ele vai pegar o endere√ßo da instru√ß√£o que est√° sendo executada. Somar com o offset. E a partir da instru√ß√£o. O endere√ßo da instru√ß√£o. Somar o offset. E a partir desse novo endere√ßo. Ele vai pegar o que tiver ali e considerar dado. Quer dizer, ele pode pegar o teu programa. E considerar como dado. Entenderam? A potencialidade disso aqui. Ent√£o, tu est√° l√° no segmento de texto. E tu quer pegar, por exemplo, tr√™s instru√ß√µes anteriores. E ler essa instru√ß√£o e considerar essa instru√ß√£o um dado. Esse modo de endere√ßamento ali. Que ele permite fazer isso. Ok. Ent√£o, notem. O ARM possui bem mais complexidades do que o RISC-V. Tudo isso aqui, pessoal. Dessa aula de hoje. Eu quero que voc√™s entendam. Eu n√£o quero que voc√™s decorem isso aqui. Eu quero que voc√™s entendam a filosofia geral. Quer dizer, existem mais coisas que podem ser feitas. Do que simplesmente aquilo que est√° no RISC-V. Olha s√≥. Ok. Outras diferen√ßas. S√£o os modos da CPU. A gente j√° viu. Que a CPU que o RISC-V permite o Machine Mode, Supervisor Mode e User Mode. Decora. Confira. A gente viu isso aqui. Acho que n√≥s vimos. Machine Mode, Supervisor Mode e User Mode. Voc√™s se lembram de terem visto isso aqui no curso? Ouvi-lo falar. Eu n√£o me lembro mesmo. A gente j√° viu isso. Em algum outro ponto. Mais ou menos. N√£o. User Mode, mais ou menos. Ent√£o, vamos l√°. Ent√£o, n√£o. Ent√£o, o RISC-V possui tr√™s modos de opera√ß√£o. O Machine Mode. Que seria o modo mais privilegiado. Que √© o que ele chama de Bare Metal. Bare Metal significa. Colocar o teu programa. Para ser rodado. No processador. Sem sistema operacional. Quer dizer. O processador vai rodar o teu programa. E s√≥ o teu programa. Esse aqui √© o modo. Que a gente roda. Por exemplo, o FPGA. √â o modo que. No caso do RISC-V. Ele tem um micro sistema operacional por baixo. Ent√£o, n√£o √© bem Bare Metal. No caso do hardware. Ele s√≥ usa o User Mode. Ele n√£o usa esses outros dois aqui. T√°. Mas. Antigamente. Quando a gente tinha aula de laborat√≥rio. Que a gente implementava. O RISC-V. No FPGA. Era esse modo que era otimizado. Ent√£o, s√≥ tinha o teu programa. Podendo rodar. Ent√£o, n√£o tinha restri√ß√£o nenhuma. Ent√£o, o teu programa. Tinha acesso. A tudo. De hardware. Que. Ele tinha dispon√≠vel. O Supervisor Mode. √â o modo privilegiado tamb√©m. S√≥ que √© usado. Pelo kernel do sistema. N√£o √© utilizado. Pelo kernel do sistema. Ent√£o. √â o modo utilizado. Pelo sistema operacional. Ele possibilita. Acessar um monte. De outro tipo de coisas. Que o Machine Mode. Acessa. Mas tem algumas coisas. Que o Machine Mode. Acessa. Que o kernel. N√£o √© permitido. Certo. Mas ele √©. Bem mais. Livre. Do que o User Mode. Ent√£o. O User Mode. √â um modo. N√£o privilegiado. Ent√£o. Tu n√£o pode. Acessar. Nenhuma das instru√ß√µes. N√©. Ent√£o. Aqui. √â um modo. Protegido. Para o usu√°rio. N√£o fazer. Cacaca. No sistema. Certo. Ent√£o. Ele protege. O usu√°rio. Encapsula. O usu√°rio. Para que ele. N√£o fa√ßa. Besteira. Entendido. S√£o esses tr√™s. Aqui. O ARM. T√°. O ARM. Ele tem. Um. Dois. Tr√™s. Quatro. Cinco. Seis. Sete. Ent√£o. Ele usa o User Mode daqui. Ent√£o. √â um modo. N√£o privilegiado. Que √©. Seguir. De se usar. Que. Tinha entendido. O modo. FIQ. √â o. Fast. Interrupt. Request. T√°. Significa o qu√™. O que que √© o. Interrupt. Request. √â isso aqui. Interrupt. Request. Significa. Um. Dispositivo. Externo. Por exemplo. O. Teclado. Quer mandar. Uma. Teclado. Foi. Pressionado. E. T√°. Querendo. Mandar. Um. C√≥digo. Da. Tecla. Pressionada. Pro. Processador. E. O. Processador. T√°. Rodando. N√©. Rodando. Programa. Da√≠. A. Interrup√ß√£o. Que. Faz com. Que. O. Processador. Pare de. Executar. O. Que. Est√°. Fazendo. E. V√°. Atender. Aquela. Que. Aquela. Interrup√ß√£o. T√°. Ent√£o. Por exemplo. Se. For. Uma. Tecla. Do. Teclado. Ele. Para. Uma. Interrup√ß√£o. S√≥. Que. Com. Mais. Alta. Prioridade. Quer. Dizer. O. Processador. Est√°. Fazendo. O. Teclado. Que. Pede. Uma. Interrup√ß√£o. Esse. Aqui. Primeiro. De. Terminar. De. Fazer. Esse. SVC. T√°. Que. √â. Um. De. Chamada. Similar. Ao. Syscall. Quando. Tu. Chama. Uma. Rotinazinha. Usando. Syscall. N√©. No. Isso. Que. Faz. Vai. Chamar. Uma. Rotina. Do. Sistema. T√°. Ent√£o. Ele. Vai. Executar. A. Rotina. Do. Sistema. Operacional. S√≥. Que. Nesse. Modo. Aqui. Abort. Mode. Quer. Dizer. Quando. Acontece. Alguma. Exce√ß√µes. Que. Tem. Que. Abortar. Os. Dados. Que. Traz. Nesse. Modo. Aqui. √â. Utilizado. Ent√£o. Pra. Escrever. Nos. Registradores. Que. Definem. Os. Modos. Que. √â. O. CPSR. CPSR. E n√≥s vamos ver somente nesse espa√ßo. Ele n√£o vai sair daquele espa√ßo de mem√≥ria que √© o N√£o Secure. Certo. Ent√£o seria o modo do sistema operacional. Ent√£o notem que tem muito mais. S√≥ que ele n√£o tem o registrador zero. Aquele R0. Que possui sempre o n√∫mero zero. Esse aqui n√£o tem o registrador zero. Aqui √© um registrador normal. O registrador. Ent√£o se tu escrever nesse registrador 15 um endere√ßo. O que que vai acontecer? Se ele √© o PC. Ent√£o meu programa vai l√° escrever nesse registrador. Certo. S√≥ que utilizando. Ent√£o. A escrita direto no PC. A gente n√£o tem um que faz. Nosso PC n√£o √© acess√≠vel pelo programador. Assim. Ele √© acess√≠vel nas instru√ß√µes. Se descer. Abort. Define. O que. FIQ. S√£o esses modos aqui. Para todos os modos de opera√ß√£o. Os registradores de 0 a 7. Esses 8 registradores aqui. S√£o os mesmos. Se eu estiver no modo FIQ. T√°. Ent√£o. Eu estou l√°. Tem um valor. Quando eu passo pro modo FIQ. Esse valor aqui √© salvo. E eu tenho dispon√≠vel aqui. Registradores espec√≠ficos pra esse modo aqui. Ent√£o. Eu n√£o tenho acesso mais a esses registradores. Eu tenho acesso a esses aqui. Complicado. N√©. E. Em todos os modos registradores. Ah. SP e LR. Eu tenho R13 do SP e R14 do LR. Se eu tenho modo FIQ. Eu tenho R13 para FIQ. R14 para FIQ. Quer dizer. Eu tenho registradores. N√©. Se eu estou no modo FIQ. No R13. Esse aqui. Se eu passar pro modo IRQ. No R13. √â outro. E. Registrador 13 e 14. Geralmente. S√£o utilizados como stack pointer e link register. T√°. O CPSR. Que ele possui tanto. Ah. Vers√µes. Para cada um desses outros modos aqui. O que que √© o CPSR? O aqui. S√≥ registrador aqui assim. O que que √© o CPSR? Ent√£o. CPSR. √â o registrador de status. O que que ele controla? Ele aqui est√° indicando qual √© o modo. Ent√£o, tem uma tabelinha para isso aqui. O bit 5 √© o modo de codifica√ß√£o com 16 bits. Ent√£o, seria um modo compactado. Se aqui eu tenho um 1, significa que as minhas instru√ß√µes n√£o t√™m mais 32 bits, elas t√™m 16 bits de tamanho. Ent√£o, s√£o instru√ß√µes compactadas. A gente tem os dois bits de desabilita√ß√£o das interrup√ß√µes. Se eu n√£o quero receber nenhuma interrup√ß√£o, eu desabilito esses dois bits, de Interrupt Request e de Fast Interrupt Request. Ent√£o, permite-me controlar se eu quero receber interrup√ß√£o ou n√£o. Esse aqui eu n√£o tenho ideia do que √©. O bit E9, que √© o bit 9, esse aqui, indica qual √© o endianness, quer dizer, se est√° trabalhando em Big Endian ou Little Endian, ent√£o, voc√™s se lembram que tem processadores que trabalham em Big Endian, tem outros que trabalham em Little Endian. O ARM era um que s√≥ pode trabalhar nos dois modos. Ent√£o, dependendo desse bit de configura√ß√£o aqui, eu certo se eu quero trabalhar com Big Endian ou Little Endian. Esse aqui √© o divertido. Est√° o DNN. DNN. Simplesmente n√£o modifique esses bits. Esse aqui √© superinteressante, bit 24. Que √© o bit que habilita o JAZZ. O que isso aqui faz? Ent√£o, o ARM, eles j√° programaram para celular? Faz curiosidade. J√° programaram para celular, fizeram aplicativo para celular? J√°? E ningu√©m nunca fez um appzinho l√° de Hello World, pelo menos em um celular, para ver como isso funcionava? Ok, Gabriel. Ok. A linguagem b√°sica, Flutter tamb√©m, a linguagem b√°sica de programa√ß√£o dos celulares √© Java. Ent√£o, o que o fabricante pode fazer? O fabricante do chip, ele pode habilitar um modo que ele execute os bytecodes Java diretamente no celular. Quer dizer, diretamente no processador. Ent√£o, n√£o sei se lembra do que estava. Voc√™s sabem como √© que Java funciona? N√£o, n√©? Java. J√° fizeram alguma coisa em Java? Ok, ent√£o como √© que Java funciona? Voc√™ escreve o seu c√≥digo, voc√™ compila ele, d√° bytecode e depois voc√™ pega esse bytecode e roda em uma m√°quina virtual. Certo? A JVM. M√°quina Virtual Java. E assim voc√™ roda o seu programa. Certo? A JVM. M√°quina Virtual Java. Certo? A JVM. M√°quina Virtual Java. Que √© um programinha em Java. Ent√£o Java √© livre. √â meio compilado, meio interpretado. Ent√£o, o que que acontece? Nesse caso aqui para tu ir rodar programas em bytecode, Java, tu n√£o precisa da m√°quina virtual. O pr√≥prio processador j√° executa o bytecode. O pr√≥prio processador j√° executa o bytecode. Ent√£o, isso aqui faz com que Java pode ir muito rapidamente nesse processador. Isso aqui faz com que Java possa rodar muito rapidamente nesse processador. Por isso que grande parte da... o RISC-V 32J est√° previsto, mas ningu√©m fez ainda isso aqui. Se ele ia fazer o RISC-V, ele ia rodar um bytecode Java. Ent√£o, reduz a compatibilidade? N√£o, porque isso aqui √© um bit opcional. Certo? Tu habilita ele se tu quiser que ele fa√ßa isso. Por que Java? Boa pergunta! N√£o sei porque eles escolheram Java. Porque acho que nenhuma outra gera bytecode. Tem v√°rias outras que geram bytecode sim, mas n√£o entendo porque escolheram Java. Ok. Overflow, bits, adi√ß√£o... E n√≥s temos esses quatro bits aqui. Esses quatro √∫ltimos bits. Esses quatro √∫ltimos bits v√£o indicar se aconteceu o overflow. Se aconteceu... Se aconteceu o carry out ou borrow. Quer dizer, vai 1 ou vem 1. Se o resultado √© 0. E se o resultado √© negativo. T√°? Ent√£o esses quatro funcionam como flags. Quer dizer, se a opera√ß√£o que tu estava fazendo deu overflow, esse bit vai ser ativado. Teve o vai 1 em final ou vem 1, o bit de carry √© ativado. Resultado √© 0, bit de zero √© ativado. Resultado √© negativo, o bit N √© ativado. Bit N negativo. Ent√£o, devido a isso aqui, t√°? Quem est√° nesse registrador de controle de status. O ARMv7 inovou, n√©? Fazendo com que todas as... Praticamente todas as instru√ß√µes sejam condicionais. Como assim? Quer dizer, ent√£o a maior parte das instru√ß√µes da ISA ARMv7 s√£o condicionais. Porque eles definem uma condi√ß√£o, certo? Com base nesses bits aqui. Se a instru√ß√£o deve ser executada ou n√£o. Ent√£o, por exemplo, a condi√ß√£o 00 significa que √© igual. Ent√£o, s√≥ simplesmente seta a condi√ß√£o, quer dizer. Vai verificar se o zero √© 1. Se o zero √© 1, se a √∫ltima instru√ß√£o for uma compara√ß√£o. Ent√£o, isso a√≠ significa que ele √© igual. E assim, a gente tem v√°rias outras condi√ß√µes mexendo nesses bits aqui. Tipo, de status. Que te permitem, ok, aconteceu overflow, n√£o aconteceu overflow. Se foi menor que, se foi maior ou igual. Se foi negativo. Se teve carry. Ent√£o, a gente tem v√°rias condi√ß√µes aqui. E essas condi√ß√µes v√£o ser utilizadas diretamente nas instru√ß√µes. Por exemplo. Ent√£o, vamos ver aqui um exemplo aqui. Esse compare aqui, que a gente n√£o tem. √â como se fosse R0 menos R1. Ele compara esse registrador R0 com o registrador R1. Ent√£o, ele tem que fazer essa compara√ß√£o. Ent√£o, esse aqui est√° implementando esse algoritmozinho aqui. Esqueci o nome dele. Esse aqui √© um algoritmozinho famoso de c√°lculo MDC. Voc√™s lembram qual √© o nome do carinha que inventou isso aqui? √â um grego, n√£o √©? N√£o me lembro. Voc√™s n√£o viram isso em nenhuma mat√©ria, n√£o? C√°lculo do MDC por isso aqui? O que √© MDC? M√°ximo Divisor Comum. Eita, parece que eu estou falando em grego. Ent√£o, ok. Ent√£o, o que esse algoritmozinho, essa fun√ß√£ozinha aqui faz? Enquanto i for diferente de j. Se for maior que j. i recebe i menos j. Caso contr√°rio, j recebe j menos i. E, enquanto isso aqui for diferente. Ele fica nesse loopzinho aqui, enquanto os dois forem diferentes. E, ao sair, quando os dois forem iguais. √â porque em i tem o MDC desses dois n√∫meros. Certo? Ent√£o, √© um modo iterativo de se calcular o MDC. E eu acho que √© melhor n√£o ser assim. Eu s√≥ n√£o tenho certeza se foi mesmo de outros n√≠veis. T√°? Por coisa nenhuma. Ent√£o, √© um algoritmo de Euclides. Deve ser isso aqui. T√°? E aqui √© uma implementa√ß√£o no ARMv7. Aqui √© a implementa√ß√£o no ARMv7. Aqui √© a implementa√ß√£o no RISC-V. T√°? Desse algoritmo. Bom, a implementa√ß√£o do RISC-V. Voc√™s pegam isso aqui e comprimem para isso aqui direto. T√°? Ent√£o, a primeira coisa que eu tenho que verificar. Se i √© diferente de j. Se i for diferente de j. Eu tenho que fazer isso aqui. N√©? Se i for igual a j. Eu tenho que voltar. Ent√£o, esse aqui √© o A0. Esse aqui √© o A1. E esse aqui √© o A0. N√©? Ent√£o, a primeira coisa. O A0 √© diferente do A1? A0 √© diferente do A1? Se for diferente. Ele vem para c√°. E faz esse loopzinho aqui. Fica nesse loopzinho. Se ele for diferente. N√©? Ent√£o, eu vou pegar. Um. Um. Um. Um. Um. Um. Um. Um. Um. Um. Um. Um. Um. Um. Um. Um. forma falsa, se essa aqui √© falsa √© porque o a0 e a1 s√£o iguais ent√£o n√£o precisava fazer isso aqui compara aqui que essa linha aqui s√≥ vai ser executada ah n√£o porque tem um loop aqui, desculpe tem esse loop aqui que pode dar problema tamb√©m, n√£o, ent√£o deixa assim ent√£o essa aqui √© a compila√ß√£o desse aqui e aqui a compila√ß√£o no ARMv7 ent√£o o que √© interessante chamar a aten√ß√£o aqui ele compara se r0 e r1 s√£o iguais r0 e r1 s√£o i, j aqui se eles forem diferentes not equal ele vai pular do valor do registrador para o endere√ßo que tiver no registrador LR, LR significa Link Register, aqui √© o nosso RA, quer dizer se eles forem diferentes n√£o, se eles forem diferentes LR me revolta ent√£o ele compara branch if not equal caso contr√°rio, se ele for igual ele vai fazer uma subtra√ß√£o se o r0 for maior que r1 vai fazer essa subtra√ß√£o aqui, se r0 for menor ou igual a r1 ent√£o notem que a gente tem opera√ß√µes de subtra√ß√£o condicional opera√ß√µes de subtra√ß√£o condicional ent√£o opera√ß√µes de branch condicional, e esse aqui √© um branch incondicional, que volta pra c√° pra fazer isso aqui ent√£o notem que essas opera√ß√µes, a maioria das opera√ß√µes do ARM v7 podem ser condicionais o que compacta bastante o c√≥digo notado? porque se um √© maior que o outro tem que fazer essa subtra√ß√£o, caso contr√°rio tem que fazer essa outra subtra√ß√£o essa subtra√ß√£o, caso contr√°rio tem que fazer essa subtra√ß√£o perceberam a engenhosidade disso aqui? vou comparar um com o outro ele compara r0 com r1 isso aqui √© que eu n√£o estou entendendo porque que ele est√° se n√£o forem iguais ele retorne eu vou dar uma conferida nisso aqui pra mim eu acho que se fossem iguais ele deveria retornar porque esse while n√£o entra quando i for igual a j ele sai do while mas o importante que eu queria mostrar para voc√™s √© essas opera√ß√µes aqui condicionais, Branch Condicionais, Subtra√ß√µes Condicionais, praticamente tudo condicional o salto condicional √© um salto incondicional com condi√ß√£o esse aqui √© um salto incondicional e esse aqui √© um salto incondicional isso aqui, notem que enquanto que digamos assim, foi uma inova√ß√£o n√© pra ISA de 32 bits do ARMv7 mais que o v8 que a ISA de 64 bits e agora o v9 descartaram isso aqui completamente ent√£o essa aqui √© uma boa ideia do que se poderia fazer mas notou-se que n√£o √© t√£o eficiente fazer todas as instru√ß√µes, todas n√£o, mas a maior parte das instru√ß√µes condicionais aqui est√° um exemplo de codifica√ß√£o das instru√ß√µes ent√£o primeiro √© a codifica√ß√£o ARM segundo o RISC-V que a gente est√° acostumado esse aqui √© o Thumb que a gente n√£o viu certo? ent√£o todas elas tem 32 bits esse aqui √© o tipo R ent√£o a gente tem os campos, o OPCODE, FUNC3 FUNC7 eu esqueci do FUNC7 aqui FUNC7 RS1, RS2, RD enquanto o ARM tem OPCODE mais esses dois OPCODES auxiliares RD, RS1 e RS2 nesses campos ent√£o esse aqui √© como se fosse um OPCODE auxiliar e o RS2 ent√£o esse aqui √© como se fosse um OPCODE auxiliar ent√£o esse aqui √© como se fosse um OPCODE auxiliar ent√£o esse aqui √© como se fosse um OPCODE auxiliar como se fosse o nosso FUNC7 para que define unicamente qual √© a instru√ß√£o ent√£o o Thumb tamb√©m tem isso esse aqui √© o OPCODE e aqui a complementa√ß√£o do OPCODE e para dar transfer√™ncia de dados loads mais especificamente para BRANCH e para JUMPS ent√£o uma das coisas que a gente pode ver aqui √© que ah s√≥ uma coisa esse primeiro aqui t√° esse primeiro aqui t√° esse primeiro aqui t√° esse primeiro aqui t√° esse primeiro aqui t√° esse primeiro aqui t√° esse primeiro aqui t√° esse primeiro aqui t√° esse primeiro aqui t√° s√£o exatamente esses bits aqui de condicionais certo ent√£o se eu quero fazer uma instru√ß√£o n√£o condicional, ele deve colocar 1110 ok entendeu ok a da filosofia de codifica√ß√£o de bits √© com isso na posi√ß√£o desses bits aqui muda ISA compactada, ISA de 16 bits, n√©, ent√£o o ARM, ele criou essa ISA compactada, para que que voc√™ precisaria de uma ISA compactada, ao inv√©s de gastar 32 bits pra uma instru√ß√£o, gasta 16, grande vantagem √© que teu programa fica menor, n√©, gasta menos mem√≥ria, n√©, pra fazer a mesma coisa que outra que uma instru√ß√£o de tamanho 32 faria, claro que tem v√°rias tenta√ß√µes aqui, tamanhos do anti-registrador diminu√≠ram, e coisas do tipo, mas aqui ele s√≥ est√° comparando o RISC-V no MIPS, que tamb√©m tem ISA compactada e o ARM, t√° a√≠ mais ainda o x86, e aqui a ISA de 64 bits, aqui a ISA de 32 bits, ent√£o, como que voc√™ observa esse gr√°fico aqui? Bom, isso aqui √© um gr√°fico. Em rela√ß√£o ao tamanho do c√≥digo, certo, obtido, t√°, ent√£o o que mais vai gerar o mesmo programa, s√≥ que escrito pra ISAs diferentes, ent√£o esse aqui seria o MIPS 32, seria 173% maior do que o comprimido do RISC-V, por isso que o ARM de 32C, C de compactado, ent√£o as instru√ß√µes tem 16 bits digitais, de tamanho, e esse aqui √© a ISA 32 n√£o compactada, ent√£o o compactado, n√©, economiza praticamente 40% de tamanho, t√°, se esse aqui √© 100%, t√°, esse aqui √© 140%. O x86 vai te gerar um c√≥digo desse tamanho aqui, ent√£o maior do que esse, mas menor do que esse, por qu√™? Porque o x86 tem uma estrutura CISC, ent√£o tem instru√ß√µes especializadas. Ent√£o o que a gente precisa fazer aqui com um conjuntinho de instru√ß√µes, aqui uma instru√ß√£o s√≥ j√° √© o suficiente, por isso que o c√≥digo fica menor. Aqui a ARMv7, e aqui seria a ARMv7 compactada, essa aqui, ent√£o esse igual de compacta√ß√£o, ent√£o esse √© praticamente igual a esse, n√©, e aqui o MIPS. E pra 64 bits, ent√£o, 64 bits compactado, do RISC-V, e 64 bits n√£o compactado, o x86, n√©, que n√£o tem compacta√ß√£o, do programa original, e o ARMv8, n√©, sem compacta√ß√£o, e o MIPS-64 sem compacta√ß√£o. Nesse caso aqui eles foram meio tendenciosos, que deveriam ter colocado aqui o ARM Thumb-2, e o MIPS-16E, que √© compactado esse aqui. Aqui eles s√≥ colocaram, compararam uma vers√£o compactada com as vers√µes n√£o compactadas, da√≠, das ISAs. Compara√ß√£o meio que tendenciosa, n√©. Esse aqui saiu do MIPS-24, ok? Ent√£o, s√≥ pra voc√™s saberem que tem, ent√£o, ISAs compactadas. Ah, ent√£o, afinal, ARMv7 √© RISC ou CISC devido √†s complexidades que ele apresenta, n√©. Ent√£o, embora seja uma arquitetura Load-Store, n√©, somente os loads e stores acessam a mem√≥ria, n√©, ele foi projetado com essa filosofia Load-Store, devido √† complexidade que o ARM tem, tem gente que considera o ARM n√£o uma arquitetura com conjunto reduzido de instru√ß√µes, mas sim um conjunto complexo, n√£o t√£o complexo quanto o x86, mas mais complexo do que o RISC-V. Ent√£o, um exemplo de instru√ß√£o desse tipo √© essa aqui, STMFD, t√°. Ent√£o, o que que essa instru√ß√£o faz? Aqui eu tenho o endere√ßo da pilha, t√°. Ent√£o, o SP √© o endere√ßo da pilha. Ent√£o, essa instru√ß√£o vai pegar os registradores R0 at√© o R12 e o LR, que √© o meu registrador de retorno, e vai colocar todos esses registradores a partir dessa posi√ß√£o na pilha. Ent√£o, ele copia todos os registradores direto pra pilha. O processador n√£o vai fazer tudo isso de uma vez s√≥. Ele vai... R0 p√µe na pilha. R1 p√µe na pilha. R2 p√µe na pilha. LR p√µe na pilha. Certo? Ent√£o, isso aqui √© uma instru√ß√£o que faz tudo isso. E essa outra instru√ß√£o aqui, LDMIA, ele vai pegar da pilha, certo, e colocar de volta nos registradores. A pilha √© nessa posi√ß√£o aqui. Ele vai colocar de volta nesses registradores e no PC. Ent√£o, notem aqui que o registrador LR √© LR. Que √© o Link Register. Ele armazena o endere√ßo de retorno. Certo? Ele vai armazenar os 13 registradores e mais um endere√ßo de retorno na pilha. E quando ele recuperar os valores, ele vai recuperar os valores do R0 at√© R12 e vai colocar em PC o valor de retorno. Quer dizer, ele retorna automaticamente. A pr√≥xima instru√ß√£o que vier depois dessa j√° vai ser no endere√ßo de retorno. Sentiram? A jogada deles aqui. Salvou os registradores na pilha e o LR na pilha, que √© o endere√ßo de retorno. E essa instru√ß√£o, ent√£o, carrega tudo. Carrega o endere√ßo de retorno no PC. Logo, qual √© a pr√≥xima instru√ß√£o que vai ser executada? A instru√ß√£o que tiver no endere√ßo PC. Que era o endere√ßo de retorno. Isso aqui √© uma complexidade alta. De fazer isso aqui, tem uma instru√ß√£o. Que nem tu copia um bloco de mem√≥ria para outra posi√ß√£o. Mas, era considerado, ent√£o, ISA RISC. Mesmo com instru√ß√µes poderosas que nem essas. Ok, ent√£o n√£o houve uma ISA CISC mesmo. Um x86. Ent√£o, a grande evolu√ß√£o dos processadores da Intel seguiam sempre o dogma da retrocompatibilidade. Quer dizer, o processador mais atual tem que ser retrocompat√≠vel com os processadores anteriores. Certo? De modo que os programas feitos com os processadores anteriores, rodem no processador atual. Ent√£o, isso √© uma das diretrizes da Intel. Ent√£o, assim, ela consegue ir avan√ßando sem se preocupar em ter que trocar o software para rodar no novo processador. Ent√£o, as coisas continuam assim. Ent√£o, as coisas come√ßaram em 1974 com o 8080. Foi um processador de 8 bits. Ent√£o, ele era do tipo aritm√©tica por acumulador. Voc√™s se lembram quando eu falei l√°, aritm√©tica por acumulador, por pilha, registrador, registrador, registrador. O 8080 era baseado em acumulador. E tinha ainda mais 3 registradores. 3 pares de registradores. O 8086 j√° tinha 16 bits. Que foi pegando esse aqui. E estendendo. E a partir daqui come√ßa um conjunto complexo de instru√ß√µes. Ele pegou todas as instru√ß√µes que tinham aqui. Copiou para c√° e colocou mais instru√ß√µes. O 8087 √© o processador aritm√©tico. Que eu j√° comentei para voc√™s. Que era o processador em ponto flutuante. Que realizava as opera√ß√µes em ponto flutuante. E que utilizava uma pilha. De 8 posi√ß√µes. 8 registros de stack. E ele acrescentou ent√£o 60 instru√ß√µes de ponto flutuante. Ao 8086. O 80286, muito bem. Ele continuava sendo um processador de 16 bits. Ent√£o, os registradores eram de 16 bits. S√≥ que, eles estavam j√° nessa √©poca aqui. Sentindo que 16 bits n√£o era suficiente. 16 bits endere√ßa quanto de mem√≥ria? 16 bits. Quanto de mem√≥ria √© endere√ßado se o registrador tem 16 bits? 2 elevado a 16. Ent√£o, d√° quanto isso? N√£o sei l√°. Voc√™s n√£o sabem 2 elevado a 16? Isso, 65.536. T√°. Ent√£o. O m√°ximo que podia ser era 64 kilobytes. At√© aqui. T√°. Ent√£o, ele n√£o podia ter mem√≥ria maior que 64 kilobytes. Da√≠ veio o 286. Viu que 64 kilobytes n√£o era suficiente. Ent√£o, mesmo o processador sendo 16 bits. Ele aumentou o barramento de endere√ßamento para 24 bits. Quer dizer. Para eu endere√ßar. Para eu escolher um endere√ßo aqui. Eu tinha que ter um registrador. E mais metade do outro. Certo? Ent√£o, eu tinha que ter um registrador de 16 bits. E mais a metade de outro registrador. Porque 16 mais 8 √© 24. Ent√£o, o endere√ßo era colocado dessa forma. Em 24 bits eu consegui endere√ßar quanto de mem√≥ria? 24 bits endere√ßa quanto de mem√≥ria? Isso. 16 megabytes. 16 megabytes. Certo? Ent√£o, a partir daqui os processadores come√ßaram a poder acessar. 16 megabytes. 16 megabytes de mem√≥ria. Menos 1. N√£o, n√£o. 16 megabytes de mem√≥ria. O endere√ßo √© que vai de 0 at√© esse n√∫mero a√≠. Menos 1. Mas a quantidade de mem√≥ria √© essa. Entendeu, Eduardo? 16 megabytes sim. √â 16 megabytes sim. Porque 2 elevado a 24 √© 2 elevado a 4. Vezes 2 elevado a 20. 2 elevado a 4 √© 16. 2 elevado a 20 √© mega. Certo? Ah. Que eu estou vendo aqui no Google. Est√° 16 megabytes para mim. Megabytes. Que √© o certo de se chamar. Certo? Certo. Certo. Certo. Certo. Certo. Certo. Certo. Certo. Que √© o certo de se chamar. Megabytes. Certo? Eu que estou usando aqui uma linguagem coloquial. Certo? Ent√£o 16 megabytes de mem√≥ria. Viu que 16 megabytes de mem√≥ria n√£o era mais suficiente. E o que eles fizeram? Ok. Criaram o primeiro processador de 32 bits aqui. Certo? Ent√£o come√ßa a chamar essa arquitetura de IA-32. Intel Architecture de 32 bits. Que depois com o tempo vai virar a x86. Isso aqui. Porque aqui era Intel que tinha criado essa arquitetura. 80x86. O que √© 80x86? Ah, √©, professor, eu j√° vi x86 bits. O que quer dizer, professor, x86 bits? √â, acho que eu j√° vi um. Um outro. Desse jeito. N√£o, nunca vi, depois me manda um link a√≠. O que √© isso que tu achou a√≠? Ok, ent√£o. Agora com 32 bits. Eu consigo endere√ßar os famosos 4 gigabytes. Os 4 gigabytes de mem√≥ria. Que perdurou at√©. Surgirem os processadores. De 64 bits. Ent√£o, esse aqui. √â o processador b√°sico. Ent√£o, da Intel, a partir daqui. Todos os processadores foram compat√≠veis. Com esse aqui. Ent√£o, para fazer esse aqui, a Intel largou de novo. Quatro dessas coisas aqui. Ent√£o, um programa que roda no 286. N√£o vai rodar no 386. Ent√£o, aqui foi criado. Uma nova ISA. Mesmo para isso aqui. E a partir daqui, sim. Teve a retrocompatibilidade. Ok, botar mais modos de endere√ßamento. Mais opera√ß√µes. O uso de mem√≥ria paginada. Agora, posso ter um segmento de mem√≥ria. Para uma aplica√ß√£o. Outro segmento de mem√≥ria para outra aplica√ß√£o. Outro segmento de mem√≥ria para outra aplica√ß√£o. A√≠, evolui ent√£o. Em 1989, o 486. T√° aqui. Foi o primeiro. Esse aqui n√£o era pipelineado. Esse aqui foi o primeiro que utilizou o pipeline. Que √© a t√©cnica de acelera√ß√£o. Que n√≥s vamos ver no final do curso. Colocou as caches para dentro do chip do processador. Nesse aqui, a cache era um circuito integrado. Fora do processador. Mas na mesma motherboard. E aqui foi para dentro. E o FPU tamb√©m foi para dentro. Que antes era o 8087. Depois o 387. Que estava fora. Mas da√≠, a partir do 486. O FPU entrou para dentro do processador tamb√©m. A√≠, come√ßaram a aparecer os competidores. AMD, Cyrix, VIA. V√°rios √∫nicos aqui. Hoje em dia, voc√™s veem praticamente Intel, AMD. E VIA Technologies. Que fabricam os x86. E pro 486. Ele adicionou somente 4 novas instru√ß√µes. Em rela√ß√£o ao 386. Ent√£o, quem tinha isso no 386. No 486 s√≥ teve mais 4 instru√ß√µes. Em 1993. Vem o primeiro Pentium. Junto com o primeiro Pentium. A tecnologia superscalar. Que n√≥s vamos ver aqui tamb√©m. No final do curso. Que √©, por exemplo, eu ter ao inv√©s de uma ULA s√≥. Eu ter duas ULAs. E assim eu consigo fazer 2 c√°lculos ao mesmo tempo. Certo? Ent√£o isso significa essa tecnologia superscalar. A grosso modo, t√° pessoal? √â um tanto mais complexo. Do que simplesmente botar duas ULAs l√°. Duas ULAs l√°. Parece. M√∫sica de campanha pol√≠tica. Mas vamos l√°. E. O caminho de dados. Tem raz√£o. E aqui o caminho de dados. Passou a ser de 64 bits. Eu podia ent√£o. Ler 64 bits. Da mem√≥ria. Ao inv√©s de ler 32. Certo? Ent√£o isso fazia com que a transfer√™ncia. De dados fosse mais r√°pida. Antes eu tinha que ler 32 e 32. Agora eu posso ler de 64. A √∫ltima vers√£o. Que foi o Pentium MMX. A Multimedia eXtensions. Acrescentou 57 novas instru√ß√µes MMX. Isso aqui √© para. Instru√ß√µes que facilitam. Por exemplo, a decodifica√ß√£o de v√≠deo. Para a gente apresentar v√≠deo. Na tela em Pentium. Aqui foi. O famoso bug. Do FDIV. O que √© esse bug do FDIV? Eu s√≥ comentei. Mas n√£o expliquei o que era. Sobre isso aqui. N√£o, eu s√≥ disse. Olha o bug disso a√≠. √â o seguinte. Acho que foi em 94. Que aconteceu isso. A Intel lan√ßou. Esse processador. E todo mundo. D√° para saber. Para substituir seus computadores. Por computadores novos. S√≥ que tinha um matem√°tico. De uma universidade dos Estados Unidos. Que ele precisava. De c√°lculos com. Precis√£o muito grande. Eu expliquei em ISC, mas aqui em OC n√£o. Ele precisava de c√°lculos. De precis√£o muito grande. E o que ele descobriu? Que a instru√ß√£o FDIV. Que √© de divis√£o em ponto flutuante. Que utiliza tabelas. Isso aqui para implementar. Estava dando erro. Nas √∫ltimas casas decimais. L√°. E que n√£o deveria dar. Aquele erro, uma coisa que ele tinha. Precis√£o suficiente para. Representar o n√∫mero corretamente. Quer dizer, ele estava fazendo a divis√£o. Com erro. Certo, ent√£o a gente. Esse matem√°tico. Contactou a Intel. Avisou a Intel sobre isso. Mas a Intel. Disse, olha, isso a√≠ vai ser. L√° nas √∫ltimas casas decimais. Vai acontecer uma vez em 10 mil anos. De um usu√°rio normal. Tu que √© muito maluco que vai querer. Essa precis√£o. Mas da√≠ o que aconteceu? A Intel n√£o fez nada. Nessa √©poca j√° tinha internet. A√≠ ele entrou na internet. Ent√£o o que ele provou. Ele pegou na internet os experimentos dele. E disse, olha. Eu encontrei um bug. Ent√£o com isso. Todo mundo que antes estava comprando. O Pentium. Come√ßaram a parar de comprar. Por que eu vou comprar um chip que est√° bugado? T√° certo que o bug era ruim. Mas tinha. Da√≠ o que que. Com isso a Intel. Teve que reconhecer. Que estava bugado. E teve que trocar os chips de todo mundo. Que tinha comprado. Fazer o famoso recall. E a√≠ custou. Para tentar recuperar esse erro. Se ela tivesse j√° recuperado. L√° no in√≠cio que ele tinha falado. Provavelmente. Ele teria o chip dele. Atualizado. E n√£o iria mais perceber isso a√≠. A menos que tivesse outros cientistas. Que precisassem dessa precis√£o tamb√©m. Ent√£o o bug do Pentium. Isso aqui ficou conhecido. Depois em 95, Pentium Pro. Em 1997. Esses bugs. S√£o bem mais raros. Eu diria o seguinte. Eu tenho certeza que todos os chips. T√™m bugs. S√≥ que a Intel n√£o fala. Elas corrigem nas pr√≥ximas vers√µes. Certo. E quem encontra. Com bug vai falar com a Intel. Ent√£o isso n√£o √© mais aberto. Ao p√∫blico. N√£o espantar ao p√∫blico. Teoria da conspira√ß√£o. Acho muito dif√≠cil. Ter um chip da complexidade. Por exemplo. Desses i7 de 12¬™ gera√ß√£o. Que s√£o 20 bilh√µes de transistores. L√° dentro. Que n√£o tenha algum bug. S√≥ que √© um bug que. N√£o afeta o funcionamento dele. Em √°udio. Ok, ent√£o o que veio. Uma nova microarquitetura. O que √© uma microarquitetura para a Intel. Uma nova organiza√ß√£o. Certo. Ent√£o deixou de ser. A organiza√ß√£o. Certo. A gente viu aquelas organiza√ß√µes. Foi a P2, P3, P4, P5, Mobile. Certo. Ent√£o veio uma nova organiza√ß√£o. Sem novas instru√ß√µes. Ent√£o eles mexeram s√≥ no hardware. N√£o mexeram na ISA. Depois o Pentium 3. Adicionou 70 novas instru√ß√µes. Que foi chamado de SSE. Streaming SIMD Extensions. Significa o que isso aqui. Significa que eu tenho uma instru√ß√£o. E eu posso usar essa instru√ß√£o. Para trabalhar com v√°rios dados. Que √© uma instru√ß√£o SIMD. Posso porque o registrador tem 32 bits. Certo. 32 bits s√£o 4 bytes. Se eu pegar com essas instru√ß√µes aqui. Eu posso considerar que isso aqui. S√£o 4 dados de 4 bytes. E eu mandar ent√£o. Somar isso aqui com um outro dado. De 4 bytes. Assim. Que n√£o tenha divide 1 entre eles. Ent√£o como se eu estivesse operando. A soma de 4 inteiros ao mesmo tempo. Para ficar na ideia. Quer dizer instru√ß√£o Single Instruction Multiple Data. Ou ent√£o 2 n√∫meros de 16 bits. Posso operar os dois como se fossem 2 n√∫meros separados. Ent√£o vou estar fazendo 2 opera√ß√µes. Com 16 bits ao mesmo tempo. Seria ao mesmo tempo. E com eles foram associados. Registradores de 128 bits. Mas professor. Me disseram que n√£o tinha. Registradores com 128 bits. N√£o, n√£o tem ainda. Tem arquiteturas que trabalham. Com processadores de 128 bits. Esse aqui s√£o bits. Para essa aplica√ß√£o. Ent√£o 128 bits. D√° quantas words aqui dentro? Se eu tenho um registrador de 128 bits. Quantas words cabem a√≠ dentro? 4. Quantos bytes cabem a√≠ dentro? 128 bits por 4. 128 bits por 8. 128 bits por 8. 16. Ent√£o eu tenho um registrador de 128. Com outro registrador de 128. √â como se eu estivesse operando. A mesma opera√ß√£o soma. Os 16 bytes. Ao mesmo tempo. Certo? Registradores de uso geral. Que s√£o registradores de uso espec√≠fico. Para esse conjuntinho de instru√ß√µes. Entenderam? O porqu√™ disso? Porque a gente pode colocar. Compactar v√°rios dados. Em uma mesma word de 128. E mandar uma √∫nica instru√ß√£o fazer. Por exemplo opera√ß√µes de tra√ß√£o e multiplica√ß√£o. Entre eles. Certo? Como se estivesse trabalhando com um vetor. Por exemplo um vetor de 4 words. Outro vetor de 4 words. Hoje em dia os conjuntos mais novos. Isso aqui j√° est√° em 256 bits. Se eu n√£o me engano. J√° tem at√© de 512 bits. Registradores de uso espec√≠fico. Ok. 2001. Em 2001 a nova microarquitetura. Adicionou mais 144. Novas instru√ß√µes. Que foi o SSE2. Em 2003. Em 2003 a AMD. Lan√ßa a arquitetura. De 64 bits dela. Chamada AMD64. AMD64. Certo? E que a Intel. Adotou depois. Por isso que transformou nesse nome aqui. Que o nome original era AMD64. Da√≠ a Intel. Adotou. Fez alguns refinamentos. E chamou de Intel 64. E ainda. Adicionou 3 novas instru√ß√µes. Que est√£o formando o conjuntinho SSE3. Que s√£o opera√ß√µes complexas. Opera√ß√µes com n√∫meros complexos. Depois vem Intel Core. Em 2006. 54 novas instru√ß√µes. Do conjuntinho SSE4. Para facilitar. A cria√ß√£o de m√°quinas virtuais. Ent√£o se j√° usaram m√°quina virtual. Quer dizer Linux dentro do Windows. Ou Windows dentro do Linux. N√©. Esse tipo de coisa. Ent√£o em servidores. M√°quinas virtuais. √â o que eles trabalham. Tem que ter um bom suporte a isso. Em 2007. A AMD. Lan√ßou 170 novas instru√ß√µes. Que ele chamou de SSE5. Mas a Intel. N√£o quis adotar. E criou a sua pr√≥pria vers√£o. Ent√£o a AMD tem esse SSE5. Mas o processador da Intel n√£o tem. Da√≠ vem. Os Intel Core. Ent√£o aqui eu tinha meio que Intel. Intel i7 para mais. Para esse aqui. Esse aqui era o Core. Depois o Core i1, o Core Quad. E depois o Core i2. Que foram essas fam√≠lias Core. E aqui j√° √© o Intel Core. Que vem come√ßando 3, 5 e 7. Colocaram ent√£o mais um conjunto de instru√ß√µes. Para extens√£o vetorial. Para c√°lculo vetorial. Adicionaram. Registradores maiores. Para trabalhar com esses vetores. Ent√£o 256 bits. Ent√£o podia ter vetores grandes. Ali. Adicionaram 250. Foram redefinidas 250 instru√ß√µes. E adicionaram mais 128. E tamb√©m. Mais 47. Novas instru√ß√µes. De 3 operandos. Como assim professor. Quer dizer que at√© 2008. A Intel n√£o. Trabalhava com 3 operandos. Quer dizer. Somar dois registradores e colocar no terceiro. N√£o. A Intel n√£o usava. Essas instru√ß√µes s√≥ aconteceram aqui. Certo. Ent√£o vamos ver como a Intel fazia isso. Depois terceira gera√ß√£o. Adicionou mais coisas. Maior ainda o SSE. Que passou a ser de 512 bits. Esses registradores especiais. Para c√°lculo vetorial. E AVX. E aqui continuamos. S√≥ que eu n√£o continuei aqui. Acho que vou ter que fazer isso nas minhas f√©rias. Arrumar isso aqui para atualizar. Bem atrasado 2003. Vamos come√ßar para dar uma ideia para voc√™s. Vamos l√°. Como √© que era o banco de registradores dos processadores da Intel. Ent√£o como eu disse. A Intel come√ßou com 8 bits. Certo ent√£o 8085 era um processador de 8 bits. E tinha como. Registradores o registrador A. O C, o E, A, B, C, D, E mais alguns ponteiros. Certo. O 8086 foi de 16 bits. Ent√£o. O banco de registradores da Intel era 1, 2, 3, 4 registradores. De uso geral. E outros que eram ponteiros. Esse aqui SP, BP, SI, DI. Certo. 8086. Os registradores foram aumentados para 16. Ent√£o o registrador A. Que era de 8. Passou a ser 16. E passou a ser chamado de AX. Onde eu tenho aqui a parte baixa do A, AL. E a parte alta do A, AH. Certo ent√£o um registrador de 16 bits. Feito a partir da extens√£o do registrador de 8 bits. E assim para todos esses aqui. Esses aqui j√° eram de 16 bits. Para conseguir endere√ßar os 64 KB de mem√≥ria. Certo. A√≠ veio o 386. E estendeu isso para 32 bits. Certo ent√£o. Eles come√ßaram. Pegaram o registrador AX. E acrescentaram mais 16 bits aqui. Gerando ent√£o. EAX. Extended AX. Certo ent√£o agora o Extended AX. Tem 32 bits. O AX tem 16 bits. E o AH e o AL tem 8 bits. Certo mas tudo √© o mesmo registrador. Eu s√≥ posso. Apontar. Para esses quantos digamos assim do registrador. Ent√£o e tamb√©m. Esses registradores aqui passaram a ser de prop√≥sito geral. Ent√£o aumentou. O n√∫mero de registradores de prop√≥sito geral. At√©. Aqui ent√£o foram 8 registradores. De prop√≥sito geral. E aqui. A gente tem registradores que s√£o. Ponteiros. Esses aqui. Ok. Esse aqui √© o PC. O instruction pointer. √â esse aqui. Que eles chamam de IP. E aqui as flags condicionais. E. No de 8 registradores de ponto flutuante. A gente j√° viu. √â uma pilha de 8 registradores. Com 80 bits cada um. Ent√£o com 80 bits. Tu tens uma precis√£o. Muito melhor. Do que precis√£o dupla. Que √© uma precis√£o qu√°drupla. Ent√£o a Intel j√° tinha lan√ßado isso aqui. Antes. Das coisas de precis√£o dupla. Ficarem comuns. N√©. Ent√£o ela permaneceu com os 80 bits. Ent√£o notem que o banco. De registradores da Intel. Foi se modificando ao longo do tempo. At√© ficar nesse aqui. 8 registradores de prop√≥sito geral. O PC. Mas originalmente ela s√≥ tinha 4. Registradores. Ok. Ent√£o como em 2008 eles lan√ßaram. Aquelas instru√ß√µes com 3 operandos. Como √© que era? Ent√£o as instru√ß√µes at√© ent√£o. Eram instru√ß√µes de 2 operandos. Onde um dos operandos. Era a fonte de dados. O outro era outra fonte de dados. Mas esse aqui. Tamb√©m era o destino dos dados. Ent√£o √© como se a gente tivesse assim. Por exemplo ADD EAX, EBX. Certo? Ent√£o o que essa instru√ß√£o manda fazer? Soma o conte√∫do de 32 bits. Do EBX. Com o conte√∫do de 32 bits do EAX. E coloca o resultado. No EAX. Certo? Ent√£o sempre. O primeiro argumento aqui. Era para onde iam os resultados. Tamb√©m. Voc√™ n√£o podia colocar isso aqui em outro registrador. Que n√£o fosse ele mesmo. Certo? E a Intel viveu com isso. Durante muitos anos. Sem problema nenhum. Por isso. Opera√ß√µes de 2 argumentos. Agora eles t√™m opera√ß√µes de 3. Argumentos. ADD GPR0, GPR1, GPR2. Soma 1 com 2. E coloca o resultado em 0. A partir de 2008. Que come√ßaram a ter instru√ß√µes desse tipo. Ok, e uma outra caracter√≠stica. Que tamb√©m √© muito importante. √â que. O primeiro operando poderia ser um registrador. Teria que ser um registrador. Como esse aqui. O segundo operando poderia ser um registrador. Como a gente fez aqui. Poderia ser um n√∫mero imediato. Ah 127. Ent√£o soma EAX com 127. Coloca o resultado em EAX. Poderia ser. Um argumento vindo da mem√≥ria. Eu vou colocar aqui s√≥ um. Por exemplo. O [EDX]. O que isso aqui significa. Significa que eu vou ler. Do endere√ßo. Que tiver em EDX. L√° da mem√≥ria. Vou somar com EAX. E armazenar o resultado em EAX. Ent√£o o segundo argumento. Poderia vir da mem√≥ria. E tamb√©m o primeiro argumento. N√£o precisava ser s√≥ um registrador. Poderia ser a mem√≥ria tamb√©m. Quer dizer. Poderia ter isso aqui. N√£o poderia ter duas mem√≥rias. Ent√£o ADD [EAX], EBX. Ele vai ter que ler o valor desse registrador. L√° da mem√≥ria. Somar com esse registrador. E armazenar nessa posi√ß√£o de mem√≥ria. Poderia fazer isso. Assim como poderia ter mem√≥ria mais imediata. Ent√£o. Dessa posi√ß√£o de mem√≥ria. Soma com o n√∫mero imediato. E armazena nessa mesma posi√ß√£o de mem√≥ria. Isso que n√£o √© uma arquitetura Load-Store. Quer dizer. Essas opera√ß√µes simples. Acessam a mem√≥ria tamb√©m. O que complica muito. O projeto do processador. Que outras instru√ß√µes acessem a mem√≥ria. A gente vai ver quando come√ßarmos. Com o projeto total. Ent√£o a gente teria essas condi√ß√µes. E a partir de 2008 √© que come√ßaram a surgir. Essas instru√ß√µes. De tr√™s argumentos. Os endere√ßos na mem√≥ria. O endere√ßo pode estar no registrador. Pode. O endere√ßo pode ser um registrador de base. Mais um deslocamento. Mais um offset. Poderia ser. Registrador de base. Mais um registrador de √≠ndice. Ent√£o um registrador indexado. Multiplicado por uma escala. E essa escala ser uma pot√™ncia de 2. Ent√£o multiplicar por 1, por 2, por 4, por 8, por 16. N√£o. At√© por 8 s√≥. Ent√£o a escala vai de 0, 1, 2, 3. Ent√£o eu posso pegar o conte√∫do do registrador. E multiplicar ele por essa escala. Pode ser um registrador de base. Mais a escala. Vezes o registrador de √≠ndice. Mais um deslocamento. Ent√£o bastante flexibilidade. Em como definir um endere√ßo na mem√≥ria. X86. Grande problema do x86. √â que diferente do RISC-V. Do ARM. E do MIPS. Que todas as instru√ß√µes tem 32 bits. No x86 as instru√ß√µes tem tamanhos vari√°veis. Ent√£o por exemplo. Essa instru√ß√£o CALL. Aqui tem 40 bits. De tamanho. Quer dizer. O CALL pode acessar qualquer parte. Da mem√≥ria de 4GB. Diretamente. Porque essa instru√ß√£o tem 40 bits. De tamanho. Essa instru√ß√£o aqui. Faz um PUSH. Desse registrador. Ent√£o somente 8 bits. Ent√£o eu posso ter coisas. T√£o grandes quanto 48 bits. Tipo esse aqui. E coisas t√£o pequenas quanto 8 bits. Ent√£o as instru√ß√µes t√™m tamanhos vari√°veis. Se as instru√ß√µes t√™m tamanhos vari√°veis. Tamb√©m tu sabe. Qual √© a pr√≥xima instru√ß√£o? Eu sei que eu estou. No RISC-V. Eu sei que eu estou. Na instru√ß√£o PC. Qual √© o endere√ßo da pr√≥xima instru√ß√£o? Se eu estou na instru√ß√£o PC. Endere√ßo da pr√≥xima PC mais 4. E o x86. Que eu n√£o conhe√ßo. Como eu vou saber fazer isso? Se eu estou na instru√ß√£o PC. Eu vou ter que ler a instru√ß√£o. Decodificar a instru√ß√£o. Para ent√£o descobrir. Onde est√° a pr√≥xima instru√ß√£o. Eu n√£o posso simplesmente dizer. Ah v√° para a PC mais 4. Que n√£o √©. Eu tenho que executar. E qual √© a instru√ß√£o. E decodificar para ent√£o saber. Qual √© a pr√≥xima instru√ß√£o. E isso complica muito. O projeto do hardware. √â ralado isso aqui. Aqui est√° um exemplo. Vamos entrar em detalhes. Esse mesmo algoritmo de Euclides. Aqui est√° em RISC-V. E aqui est√° em Assembly x86. Ent√£o o percent e ax. √â justamente os registradores. Jump if equal. Jump if less or equal. Isso aqui √© simplesmente jump. Certo. E aqui √© a compara√ß√£o. Jump not equal. E a√≠ ele vai para L5. E se os dois n√£o forem iguais. Ele vai para L5. E fica aqui nesse loop. Ok. Como se implementa esse conjunto de instru√ß√µes. Do x86 ent√£o? Ent√£o. A forma de fazer isso. Como temos instru√ß√µes complexas. Instru√ß√µes que necessitam. V√°rios ciclos de clock. Para serem executados. Temos instru√ß√µes simples. As normalzinhas que necessitam. A gente tem instru√ß√µes complexas. Depende de v√°rios ciclos de clock. Ent√£o, instru√ß√µes simples e instru√ß√µes complexas. Como que isso √© projetado? Ent√£o, a gente vai verificar isso, a gente vai fazer esse tipo de implementa√ß√£o que vai ser a nossa implementa√ß√£o multi-ciclo. A gente vai implementar o RISC-V em multi-ciclo. Ent√£o, o RISC-V em multi-ciclo n√£o fica muito legal de seguir, porque ele j√° √© um processador RISC, s√≥ tem instru√ß√µes simples. E a√≠, a gente vai fazer isso em v√°rios passos a√≠, ent√£o a gente pode parecer, mas multi-ciclo n√£o serve para muita coisa. N√£o serve para muita coisa com RISC-V, j√° que ele j√° √© RISC. Mas em x86, voc√™ precisa implementar usando aquela metodologia que a gente vai ver, que √© dividir uma instru√ß√£o em diversas etapas. E para a instru√ß√£o ser completa, ele tem que passar por todas as etapas. E o Intel diz que o desempenho √© compar√°vel aos RISCs. A Intel disse isso. Ent√£o, tendencioso esse neg√≥cio? N√£o sei. Porque os processadores mais r√°pidos s√£o os x86. E cabe aos compiladores tirar proveito dessa complexidade toda. O usu√°rio normal n√£o vai escrever em s√£ consci√™ncia um programa em Assembly x86. Porque ele vai estar usando s√≥ um pequen√≠ssimo conjunto de instru√ß√µes. Vai ter muitos outros recursos que eles nem sabem que existe, que poderia simplificar ou tornar o programa mais eficiente. J√° os compiladores n√£o. Os compiladores foram feitos para usar todos os recursos dispon√≠veis no processador. Certo? Ent√£o, isso aqui √© a fun√ß√£o do compilador hoje em dia. Ent√£o, algumas fal√°cias. Instru√ß√µes poderosas significa melhor desempenho? Verdadeiro ou falso? S√≥ escreva a√≠. Verdadeiro ou falso? Instru√ß√µes poderosas? Tipo do x86. Significa melhor desempenho? Sim ou n√£o? T√° bom, Eduardo. Ent√£o pensem sobre isso. Uso de linguagem Assembly. Melhor desempenho? Eu acabei de explicar. Realmente, eu vou na letra na altura de mistura de verdadeiro com falso. Inverso. Verdadeiro com falso. Certo? Uso da linguagem Assembly. Melhor desempenho? Olha, antigamente melhorava. Tu escrevia diretamente em Assembly e o processador. Hoje, melhor se tu pegar pequenos trechos. Pequenos trechos que tu v√™ que a compila√ß√£o n√£o est√° dando muito boa, se tu escrever em Assembly, tu pode melhorar bastante o desempenho do teu programa. Mas, via de regra, os processadores, os compiladores hoje em dia j√° est√£o muito prontos para isso. Aqui est√° a evolu√ß√£o da quantidade de instru√ß√µes ao longo do tempo. Hoje em dia est√° com mais de 2.500 instru√ß√µes, isso aqui. Ent√£o, √© uma arquitetura CISC. Mais de 2.000 instru√ß√µes. E isso aqui vai completar a aula. Bem, e com essa filosofada a√≠ do MIPS, a gente finaliza essa aula de outras arquiteturas. x86 √© tudo, mas n√£o √© tudo isso de complexo. A gente s√≥ faz o que a gente sente, n√©? Ok, pessoal? Tudo isso devido √† retrocompatibilidade. D√∫vidas? Ah, assinem a... Fa√ßam o testinho, esqueci. √â, boa, Vitor. Fa√ßam o testinho l√°, porque eu j√° quase tinha esquecido. Para voc√™s sinalizarem a presen√ßa. D√° pra fazer at√© as quatro e dez, t√°? T√° certo, mas hoje o Vitor tava ali e ele lembrou. No momento que eu lembrei. Teve um transmiss√£o de pensamento entre eu e ele. Ok, pessoal? Ent√£o, ficamos por aqui. Na pr√≥xima aula √© o laborat√≥rio, t√°? Ent√£o, vai ser mais divertido. Bora. Ent√£o, j√° brinquem com o Assembly, para voc√™s chegarem l√° no laborat√≥rio, j√° com certa pr√°tica, se familiarizem com o Assembly, t√° bom? Diga, Sam. Mas aqui vai ser tudo divertido. Espera s√≥ para ver o que vai ser o projeto, voc√™s. Certo? Ent√£o, eu parei as grava√ß√µes.",
        "video_source": "OAC_2022-02-23.mp4"
    },
    {
        "id": 12,
        "timestamp_start": 7019.01,
        "timestamp_end": 7022.48,
        "slide_description": "Como Engenheiro de Computa√ß√£o S√™nior, analiso o slide e o contexto apresentados.\n\nO slide principal, intitulado \"Conclus√£o\", √© parcialmente vis√≠vel, com o seguinte texto leg√≠vel na parte inferior do t√≠tulo: \"In 1994, AMD's 80x86 architect, Mike Johnson,\". No cabe√ßalho do slide, acima do conte√∫do principal, identifica-se o contexto da aula: \"UnB - CIC0099 - Organiza√ß√£o e Arquitetura de Computadores\". Abaixo disso, h√° a identifica√ß√£o da institui√ß√£o e departamento: \"Universidade de Bras√≠lia\", \"Departamento de Ci√™ncia da Computa√ß√£o\", e o nome do professor, \"Prof. Marcus Vinicius Lam...\", parcialmente cortado.\n\nSobreposto ao conte√∫do do slide, h√° uma caixa de di√°logo modal com o t√≠tulo \"Pausar grava√ß√£o\". O texto desta caixa de di√°logo questiona: \"Tem certeza de que deseja pausar a grava√ß√£o? Voc√™ pode retomar a qualquer momento pressionando o bot√£o de grava√ß√£o novamente.\" Duas op√ß√µes de bot√£o s√£o apresentadas: \"Sim\" e \"N√£o\". O bot√£o \"Sim\" est√° visualmente selecionado e com o cursor do mouse sobre ele, indicando uma inten√ß√£o de pausa.\n\n√Ä esquerda da tela, um painel de interface de usu√°rio (UI) mostra funcionalidades de comunica√ß√£o e lista de participantes. Este painel inclui se√ß√µes como \"MENSAGENS\", \"Perguntas\" e \"Bate-papo p√∫blico\", indicando uma intera√ß√£o em tempo real. A lista de usu√°rios ativos, \"USU√ÅRIOS (21)\", sugere a presen√ßa de 21 participantes na aula. O chat exibe diversas mensagens de alunos, algumas com refer√™ncias diretas ao conte√∫do ou ao andamento da aula, como \"kkk teoria da conspira√ß√£o\", \"Victor Hugo Rodrig... 4\", \"Victor Hugo Rodrig... 16\", \"Victor Hugo Rodrig... PC + 4\", \"Eduardo Ferreira M... valso\", \"falso\", \"esse eu realmente errei, na letra\", \"Victor Hugo Franca... Voc√™ valsa?\", \"√â um bom p√© de valsa\", \"N√£o esque√ßam do testinho\", \"Gabriel Kenji ... ja ia mandar a carta;;\", \"Victor Hugo Franca ... Sim\", \"kkkkk\", \"Victor Hugo Franca ... eba\", e \"Eduardo Ferreira M... \"divers√£o\" (emoji)\". A timestamp \"117:07\" no canto superior direito indica a dura√ß√£o da sess√£o ou grava√ß√£o.\n\nN√£o h√° diagramas espec√≠ficos de Datapath, Pipeline, Hierarquia de Mem√≥ria ou trechos de c√≥digo (Assembly, C, Verilog) vis√≠veis neste slide. A √™nfase √© em um ponto de \"Conclus√£o\" na aula de Arquitetura de Computadores, com men√ß√£o a figuras hist√≥ricas da ind√∫stria de processadores (Mike Johnson, arquiteto da AMD para 80x86), enquanto uma intera√ß√£o da plataforma est√° em andamento (pausar a grava√ß√£o) e o chat reflete a comunica√ß√£o dos alunos.",
        "transcription": "aqui e aqui.",
        "video_source": "OAC_2022-02-23.mp4"
    }
]