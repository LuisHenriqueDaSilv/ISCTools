[
    {
        "id": 1,
        "timestamp_start": 1.04,
        "timestamp_end": 53.27,
        "slide_description": "Como Engenheiro de Computação Sênior, analisei o slide de uma aula de Arquitetura de Computadores para extrair seu conteúdo visível e textual para um sistema de busca semântica (RAG).\n\nO elemento central do slide é uma planilha, provavelmente um plano de ensino ou cronograma detalhado da disciplina \"Organização e Arquitetura de Computadores\" (OAC), conforme indicado no cabeçalho e na marca d'água da Universidade de Brasília. O título do arquivo é \"OAC_A_Plano_2021-2_v0.docx\".\n\nA planilha apresenta uma estrutura tabular com colunas indicando datas (ex: \"14/2\", \"16/2\", \"21/2\", \"23/2\") e listando os tópicos e atividades correspondentes por semana. As entradas notáveis da planilha são:\n\n**Tópicos/Atividades Principais (coluna da esquerda, com referências prováveis a Capítulos 'C' e Labs 'L'):**\n*   **Semana 14/2 - 16/2:** `8) Arit. Computacional: Inteiros (C.3)`\n*   **Semana 21/2 - 23/2:** `10) Arit. Computacional: Fracionários, IEEE 754 (C.3)`\n*   **Semana 28/2 - 2/3:** `FERIADO`\n*   **Semana 7/3 - 9/3:** `Lab 1B: Software – Compilador C`\n*   **Semana 14/3 - 16/3:** `1ª Prova (P1)`\n*   **Semana 21/3 - 23/3:** `13) Processador Uniciclo: Unidade de Controle (C.4) (L1)`\n*   **Semana 28/3 - 30/3:** `14) Processador Multiciclo: Unidade Operativa (C.4)`\n*   **Semana 4/4 - 6/4:** `Lab 4: Processador Multiciclo`\n*   **Semana 11/4 - 13/4:** `17) Pipeline: Unidade Operativa e Controle (C.4)`\n*   **Semana 18/4 - 20/4:** `18) Exceção e Interrupção (C.4) (L4)`\n*   **Semana 25/4 - 27/4:** `19.1) Memória: Cache (C.5)`\n*   **Semana 2/5 - 4/5:** `Prova Substitutiva`\n\n**Tópicos/Atividades Adicionais (coluna da direita, com referências prováveis a Instrumentos de Avaliação 'I', Tarefas 'T' e Labs 'L'):**\n*   `9) Arit. Computacional: ULA (C.3) (I4)` (Complementa os Inteiros)\n*   `11) Outras Arquiteturas (T5)`\n*   `Lab 1A: Software – Rars (T6)` (Paralelo ao Lab 1B)\n*   `Lab 2: Hardware – Verilog – ULA (T7)`\n*   `12) Processador Uniciclo: Unidade Operativa (C.4) (T8)` (Complementa Unidade de Controle)\n*   `Lab 3: Processador Uniciclo (T9) (L2)`\n*   `15) Processador Multiciclo: Unidade de Controle (C.4) (T10)` (Complementa Unidade Operativa)\n*   `16) Processador Pipeline: Conceitos (C.4) (T11) (L3)`\n*   `Lab 5: Processador Pipeline (T12)`\n*   `19) Memória: Hierarquia (C.5) (T13)`\n*   `2ª Prova (P2) (T14) (L5)`\n*   `Apresentação dos Projetos (P3) (T15)`\n\nA seção \"Avaliação\" especifica as datas das provas:\n*   `P1: 1ª Prova: 14/03/2022`\n*   `P2: 2ª Prova: 27/04/2022`\n*   `Prova Substitutiva: 02/05/2022`\nÉ explicitado que a `Prova Substitutiva` é `optativa e pode substituir qualquer uma das notas`.\n\nNão há diagramas (Datapath, Pipeline, Hierarquia de Memória) visíveis no slide, o conteúdo é inteiramente textual e esquemático em formato de planilha.\n\nNo canto superior direito, há uma marca d'água semi-transparente da \"Universidade de Brasília\", \"Departamento de Ciência da Computação\", com o código da disciplina \"CIC0040 - Organização e Arquitetura de Computadores\" e o nome do professor \"Prof. Marcus Vinicius Lamar\".\n\nAdicionalmente, na interface lateral da ferramenta de conferência, são visíveis mensagens do bate-papo público, incluindo um \"Bem vindos à sala de aula de OAC!\", a informação de que \"Esta sessão está sendo gravada\" e os resultados de uma enquete com a pergunta \"Viu a aula dos semestres passados?\", com 54% das respostas sendo \"Verdadeiro\" (7 votos) e 46% sendo \"Falso\" (6 votos).",
        "transcription": "Boa tarde, pessoal, desculpem o atraso. Hoje é segunda-feira, 21 de março, então nós estamos aqui. Na aula passada é o início da construção do processador, quando o processador é dividido em duas grandes partes: bloco de controle e o caminho de dados, ou unidade operativa. Na aula passada nós vimos a unidade operativa, pelo menos vocês deveriam ter visto, e na aula de hoje a gente vai ver então o caminho de dados. Mas como eu sei que se eu começar o caminho de dados sem ter falado um pouco, pelo menos um pouco aqui da unidade operativa, vai ficar muita gente boiando. Então vamos falar um pouquinho sobre o que é que vocês têm que ver no vídeo da aula passada.",
        "video_source": "OAC_2022-03-21.mp4"
    },
    {
        "id": 2,
        "timestamp_start": 53.27,
        "timestamp_end": 60.58,
        "slide_description": "Como um Engenheiro de Computação Sênior, analiso o slide e o contexto da aula de Arquitetura de Computadores para extrair informações relevantes para um sistema de busca semântica (RAG).\n\nO slide principal, com um fundo predominantemente laranja e detalhes em amarelo e branco, exibe o cabeçalho institucional e o título da aula. No canto superior esquerdo do slide, encontra-se o logo da **Universidade de Brasília**, seguido pelo texto \"Universidade de Brasília\" e \"Departamento de Ciência da Computação\". No canto superior direito do slide, um logo menor da **Universidade de Brasília** está associado ao código da disciplina e ao nome do professor: \"CIC0009 - Organização e Arquitetura de Computadores\" e \"Prof. Marcus Vinicius Lamar\". O título central e proeminente da aula é **\"Aula 12\"**, com o subtítulo **\"Implementação RISC-V\"** e a especificação **\"Uniciclo – Caminho de Dados\"**. Na parte inferior central do slide, uma URL **\"https://eater.net/\"** é visível, embora sua relevância para o conteúdo técnico da aula não seja aparente.\n\nAbaixo do título da aula, uma imagem detalhada de um circuito montado em uma protoboard (breadboard) ocupa grande parte do terço inferior do slide. Este diagrama visual é uma representação física de um caminho de dados de processador. É possível observar uma densa rede de componentes eletrônicos, incluindo múltiplos Circuitos Integrados (ICs), que provavelmente implementam funções lógicas e de memória (como registradores, multiplexadores, ALU, etc.). Inúmeros LEDs estão acoplados, muitos deles acesos, indicando estados de sinais, saídas de registradores ou fluxos de dados ativos em diferentes pontos do circuito. Fios jumper em diversas cores conectam os componentes, delineando as interconexões do caminho de dados. Uma tela de 4 dígitos de 7 segmentos exibe claramente o número **\"8828\"**, sugerindo uma saída de dados, o valor de um registrador ou o Program Counter (PC) em um determinado estágio de execução. Rótulos parciais ou inferíveis próximos aos componentes incluem \"CLK\" (Clock), \"RESET\", \"PC\" (Program Counter), \"IR\" (Instruction Register), \"REG\" (Register File), \"ALU\" (Arithmetic Logic Unit), \"MEM\" (Memory), \"CTRL\" (Control Unit) e \"OUT\" (Output), indicando a implementação modular das principais unidades funcionais de um processador. A disposição e a identificação dos componentes sugerem uma materialização de um processador RISC-V de ciclo único, onde os dados e as instruções fluem através de um caminho bem definido e controlado, conforme descrito no título da aula \"Uniciclo – Caminho de Dados\".\n\nAlém do conteúdo do slide, há elementos textuais da interface de uma plataforma de webconferência. No painel lateral esquerdo, sob \"Bate-papo público\", são visíveis as seguintes mensagens:\n*   \"Bem vindos à sala de aula de OAC!\"\n*   \"Esta sessão está sendo gravada.\"\n*   \"Para mais informações, clique aqui.\"\n*   \"Novo na plataforma? Experimente o tour!\"\n*   Resultados de uma enquete: \"Pergunta da enquete\", \"Viu a aula dos semestres passados?\", com as opções \"Verdadeiro: 7 ||||||| 54%\" e \"Falso: 6 |||||| 46%\".\n*   Comentários de usuários: \"até, boa aula (e bom trabalho hehe)\", \"Olá profº Lamar!\", \"boa tarde!\", e uma mensagem humorística \"Agora o Lamar é um ciborgue, tem que falar B-O-M-D-I-A\".\n\nO horário exibido no canto superior direito da janela da apresentação é \"01:03\", indicando o tempo decorrido da aula. O nome do professor \"Marcus Vinicius Lamar\" aparece na faixa superior da plataforma de webconferência, indicando ser o apresentador.\n\nEm síntese, o conteúdo técnico principal é o título da aula que aborda a \"Implementação RISC-V Uniciclo – Caminho de Dados\" na disciplina de Organização e Arquitetura de Computadores (CIC0009) da Universidade de Brasília, ministrada pelo Prof. Marcus Vinicius Lamar. A imagem da protoboard é uma representação física e prática do caminho de dados de um processador, detalhando a interconexão de unidades como PC, IR, Register File, ALU, Memória e Unidade de Controle, com LEDs indicando estados e um display de 7 segmentos mostrando dados, o que é altamente relevante para a compreensão prática da arquitetura de computadores.",
        "transcription": "Que está aqui. Então o caminho de dados.",
        "video_source": "OAC_2022-03-21.mp4"
    },
    {
        "id": 3,
        "timestamp_start": 60.58,
        "timestamp_end": 338.3,
        "slide_description": "O slide de uma aula de Arquitetura de Computadores, intitulado \"Unidade Operativa RISC-V\", descreve os objetivos de projeto para a implementação de um subconjunto específico de instruções RISC-V. O material didático é atribuído ao curso \"UnB – CIC0099 – Organização e Arquitetura de Computadores\" do Departamento de Ciência da Computação da Universidade de Brasília, ministrado pelo Prof. Marcus Vinicius Lamar.\n\nO conteúdo central do slide lista as categorias e instruções que serão projetadas:\n*   **Instruções de acesso à memória:** `lw` (load word) e `sw` (store word).\n*   **Instruções lógicas e aritméticas:** `add` (addition), `sub` (subtraction), `and` (bitwise AND), `or` (bitwise OR), e `slt` (set on less than).\n*   **Instruções de desvios:** `beq` (branch if equal) e `jal` (jump and link).\n\nO slide esclarece que este é um \"Conjunto incompleto, mas demonstra os princípios básicos de projeto\". Adicionalmente, uma observação indica que \"No laboratório, além destas, estão implementadas várias outras\", sugerindo um escopo mais amplo de implementação prática do que o detalhado no slide para fins didáticos. Não há diagramas visíveis de datapath, pipeline ou hierarquia de memória neste slide, apenas a descrição textual do conjunto de instruções a ser implementado.",
        "transcription": "A gente, OAC, é desempenho, certo? E o desempenho é o inverso do tempo de execução. E a gente viu que o tempo de execução pode ser calculado como I vezes CPI vezes T, certo? Então toda a parte da arquitetura dos processadores vai impactar em alguma dessas três variáveis aqui, certo? A implementação do processador vai impactar no clock que a gente vai poder obter e a CPI, quer dizer, quantos ciclos por instrução, vão ser necessários. Certo? Então é isso aqui que nós vamos ver. Nós vamos ver aqui três projetos: o processador uniciclo, o multiciclo e o pipeline, certo? Então isso aqui seria mais ou menos uma ordem histórica das coisas, certo? Desde o primeiro, quando a computação foi cheia, que foi utilizando tecnologia uniciclo, depois partiu para o multiciclo e depois para o pipeline, certo? E aqui a gente vai ver vários conceitos que tem por trás disso, certo? Então relembrando um pouco das duas arquiteturas que a gente tem historicamente, a arquitetura Von Neumann e a arquitetura Harvard. Von Neumann, eu tenho então o processador, unidade de controle e unidade operativa, e eu tenho uma única memória. E isso aqui se comunica então através de barramentos: o barramento de endereço, barramento de dados ou instruções, já que aqui em Von Neumann pode ter tanto dado quanto instrução, e barramento de controle, certo? E na arquitetura Harvard, a gente tem aqui o nosso processador, unidade de controle e unidade operativa, e temos duas memórias: a memória de dados e a memória de instruções ou memória de programa. E também vão ser então interligadas, se comunicar com o processador, através de barramentos: endereço, instruções e controle, endereço, dados e controle. Ok? Então relembrando isso aqui. A unidade operativa, ela é composta de circuitos eletrônicos básicos, que vocês já viram lá em circuitos lógicos e em sistemas digitais, que são elementos de armazenamento: registradores, flip-flops. Operadores lógico-aritméticos: somadores, ULA, que a gente já projetou. E recursos de interconexão: barramentos, MUXs. O nosso objetivo aqui vai ser não montar um processador completo, mas mostrar aqui em aula os princípios básicos que regem essa... como se deve começar a construção de um processador. Então tudo começa quando a gente define qual é a ISA que a gente quer implementar, certo? Então nós vamos ver aqui um exemplo de uma ISA super reduzida, da RV-32i, certo? Que vai ter somente essas instruções aqui: `load word`, `store word`, `add`, `sub`, `and`, `or`, `set on less than`, `branch if equal` e `jump and link`, certo? Então são nove instruções apenas da ISA RV-32. É um conjunto incompleto, obviamente, mas que já dá para escrever grande parte dos programas, já dá para escrever somente com essas instruções. No laboratório, a gente vai ver no laboratório 3, que vocês vão implementar esse processador aqui, exatamente desse aqui. Então quando eu falo que elas são implementadas várias outras, é que além dessas a gente vai pedir outras instruções para vocês implementarem no laboratório. Não sei se vocês entenderam todos os conceitos. Ok. Então uma implementação genérica. O que a gente vai precisar? Saber de que posição da memória de instruções, eu vou ter que ler a instrução. Então para isso eu tenho que ter o PC, para poder ler a memória de instruções. Então eu tenho que endereçar a memória de instruções, ler essa memória de instruções, ler uma instrução dessa memória de instruções. Muito provavelmente eu vou precisar ler os registradores, que estão no banco de registradores, e depois usar a instrução para decidir o que efetivamente a instrução precisa fazer. E praticamente, nesse caso aqui, todas as instruções que a gente vai utilizar, tá, usam a ULA. Então, por exemplo, `load` e `store`, vão usar a ULA para quê? Responda aí no chat. Dois segundos. Para quê que `load` e `store` vão usar a ULA? Estou vendo que ninguém assistiu a aula passada. Ok. Se eu ficar esperando aqui, então a gente não vai ir muito rápido. Então vamos lá. `load` e `store`. A gente precisa calcular o endereço. E o endereço é um registrador mais um imediato. Então quem vai fazer essa soma do registrador mais imediato? A ULA.",
        "video_source": "OAC_2022-03-21.mp4"
    },
    {
        "id": 4,
        "timestamp_start": 338.3,
        "timestamp_end": 373.35,
        "slide_description": "Como Engenheiro de Computação Sênior, analiso o slide apresentado no contexto de uma aula de Arquitetura de Computadores.\n\nO conteúdo visual é uma tela de plataforma de conferência online, identificada como \"ConferênciaWeb\" na barra superior do navegador e também como um logotipo no canto superior esquerdo da área de apresentação principal. A URL visível, `live-aws022.mconf.rnp.br/html5client/join?sessionToken=lxj3rblgxtmd5n5t`, sugere uma plataforma de comunicação e colaboração mantida pela RNP (Rede Nacional de Ensino e Pesquisa), confirmada pelo logotipo \"RNP\" presente na parte inferior direita da área de apresentação, juntamente com o logotipo \"mconf\".\n\nO título da sala ou aula é \"Sala de Aula de OAC\", indicando que se trata de uma disciplina de Organização e Arquitetura de Computadores. Há um cronômetro na barra superior da área de apresentação marcando \"06:05\", que pode representar tempo decorrido ou restante da sessão.\n\nO painel lateral esquerdo da interface da plataforma exibe funcionalidades de comunicação e gestão de participantes. Na seção \"MENSAGENS\", há opções para \"Perguntas\" e \"Bate-papo público\", com uma notificação indicando \"2\" novas mensagens no bate-papo. A seção \"NOTAS\" lista \"Notas compartilhadas\". A seção \"USUÁRIOS (18)\" indica o número total de participantes presentes, listando alguns nomes como \"Marcus Vinicius Lamar (Você)\", \"Luiz Carlos Da Silva Neto Vertuli\", \"Ana Luisa Padilha Alves\", \"Bruno Vargas de Souza\", \"Eduardo Ferreira Marques Caval...\", \"Felipe Dantas Borges\", \"Gabriel Kenji Andrade Mizuno\", \"Gustavo Lopes Dezan\", \"Gustavo Pierre Starling\" e \"Gustavo Rodrigues Da Costa\".\n\nA área central de apresentação exibe um plano de fundo abstrato, com padrões que lembram circuitos eletrônicos ou redes de comunicação, e figuras humanas desfocadas em segundo plano, sugerindo um ambiente de colaboração ou educação. No canto inferior direito desta área, há um resultado de enquete ou votação com as seguintes opções e resultados:\n*   \"Verdadeiro\": 7 votos, correspondendo a 54%.\n*   \"Falso\": 6 votos, correspondendo a 46%.\n\nNão há diagramas técnicos específicos, como datapath, pipeline, ou hierarquia de memória, nem trechos de código (Assembly, C, Verilog) visíveis neste slide. O conteúdo principal é a interface da plataforma de aula online e o resultado de uma enquete simples. O foco técnico inferido é a disciplina de Arquitetura de Computadores (\"OAC\"), mas o slide em si não contém material didático técnico direto, sendo mais um slide de transição, introdução ou interação com o público.",
        "transcription": "Essas operações... É, professor, caiu... Parou de compartilhar a tela. É, mas foi só a tela que parou de compartilhar. Vocês estão me ouvindo? Sim. Sim, estamos te ouvindo. Que saco. Quando a coisa... É, para dar ruim, ela dá ruim. E o pior é que eu não tenho nem um [computador] pequenininho. Consegui fazer você apresentador. Não sei por que veio para mim. É porque tu abriu a sessão, não foi? Não, já estava aberto. Já estava aberto.",
        "video_source": "OAC_2022-03-21.mp4"
    },
    {
        "id": 5,
        "timestamp_start": 373.35,
        "timestamp_end": 380.63,
        "slide_description": "Como Engenheiro de Computação Sênior, analiso o conteúdo visual do slide apresentado para um sistema de busca semântica (RAG).\n\n**Descrição do Conteúdo do Slide:**\n\nO slide principal, intitulado \"Unidade Operativa RISC-V\", detalha o escopo de um projeto para a implementação de um subconjunto específico de instruções da arquitetura RISC-V. O objetivo declarado é demonstrar os princípios básicos de projeto de uma unidade operativa, mesmo que o conjunto de instruções seja incompleto.\n\nO subconjunto de instruções a ser implementado inclui as seguintes categorias:\n\n1.  **Instruções de acesso à memória:**\n    *   `lw` (load word)\n    *   `sw` (store word)\n\n2.  **Instruções lógicas e aritméticas:**\n    *   `add` (addition)\n    *   `sub` (subtraction)\n    *   `and` (bitwise AND)\n    *   `or` (bitwise OR)\n    *   `slt` (set less than)\n\n3.  **Instruções de desvio (branch):**\n    *   `beq` (branch if equal)\n    *   `jal` (jump and link)\n\nUma observação no slide indica que, embora este conjunto inicial seja incompleto, ele serve para ilustrar os fundamentos do projeto. Adicionalmente, é mencionado que \"Na próxima aula, além destas, serão implementadas outras...\", sugerindo uma expansão gradual do conjunto de instruções ao longo do curso.\n\nNão há diagramas complexos como datapath, pipeline ou hierarquia de memória visíveis no slide. O conteúdo é predominantemente textual, focando na especificação das instruções RISC-V a serem abordadas.\n\n**Contexto Adicional (para RAG, mas não parte do slide):**\n\nA apresentação ocorre em uma \"Sala de Aula de OAC\" (provavelmente Organização e Arquitetura de Computadores), com o tempo de gravação em 06:24. O apresentador, visível em um feed de webcam no canto inferior direito da tela compartilhada, parece estar explicando o material. O sistema de conferência informa que \"O compartilhamento de tela foi iniciado\" e \"Você está compartilhando sua tela\".",
        "transcription": "Então eu tinha aberto a sessão e depois caí.",
        "video_source": "OAC_2022-03-21.mp4"
    },
    {
        "id": 6,
        "timestamp_start": 380.63,
        "timestamp_end": 399.29,
        "slide_description": "Como Engenheiro de Computação Sênior, analisei o slide apresentado de uma aula de Arquitetura de Computadores. A seguir, extraio e descrevo o conteúdo visual para um sistema de busca semântica, focando na informação técnica.\n\n---\n\n**Título do Slide:** Unidade Operativa RISC-V\n\n**Contexto da Aula/Curso (visível no cabeçalho do slide):**\n*   **Curso:** UnB – CIC0099 – Organização e Arquitetura de Computadores\n*   **Instituição:** Universidade de Brasília\n*   **Departamento:** Departamento de Ciência da Computação\n*   **Professor:** Prof. Marcus Vinicius Lamar\n\n**Conteúdo Principal do Slide:**\n\nO slide aborda a implementação de uma Unidade Operativa (provavelmente referindo-se a um *datapath* simplificado) para o conjunto de instruções RISC-V. O texto principal descreve que essa unidade será projetada para implementar um subconjunto específico de instruções RISC-V.\n\n**Subconjunto de Instruções RISC-V a serem Implementadas:**\n\n1.  **Instruções de acesso à memória:**\n    *   `lw` (load word): Carrega uma palavra da memória para um registrador.\n    *   `sw` (store word): Armazena uma palavra de um registrador na memória.\n\n2.  **Instruções lógicas e aritméticas:**\n    *   `add`: Adição de inteiros.\n    *   `sub`: Subtração de inteiros.\n    *   `and`: Operação lógica AND.\n    *   `or`: Operação lógica OR.\n    *   `slt` (set less than): Define um registrador como 1 se o primeiro operando for menor que o segundo, caso contrário, 0.\n\n3.  **Instruções de desvios (branch e jump):**\n    *   `beq` (branch if equal): Desvio condicional se dois registradores forem iguais.\n    *   `jal` (jump and link): Salto incondicional que armazena o endereço da próxima instrução (PC+4) em um registrador (usado para chamadas de função).\n\n**Observações Adicionais no Slide:**\n\n*   \"Conjunto incompleto, mas demonstra os princípios básicos de projeto.\" – Isso indica que o subconjunto escolhido serve para ilustrar os conceitos fundamentais de projeto de uma CPU, sem cobrir a totalidade do ISA RISC-V.\n*   \"Obs. No laboratório, além destas, estão implementadas várias outras\" – Implica que a prática laboratorial complementa o conteúdo teórico, exigindo a implementação de um conjunto maior de instruções RISC-V na prática.\n\n**Diagramas:**\nNão há diagramas de datapath, pipeline ou hierarquia de memória visíveis neste slide. O slide é predominantemente textual, focando na listagem das instruções que serão objeto de estudo ou implementação.",
        "transcription": "Beleza. Então, estamos aqui. Assim, as instruções `ADD`, `SUB`, `AND`, `OR`, `SLT` (set less than), etc. Quem vai fazer? A ULA. `BEQ` vai usar a ULA para quê? Para fazer então a comparação de igualdade.",
        "video_source": "OAC_2022-03-21.mp4"
    },
    {
        "id": 7,
        "timestamp_start": 399.29,
        "timestamp_end": 2677.6,
        "slide_description": "O slide, intitulado \"Banco de Registradores (Register File)\", apresenta a estrutura e o funcionamento de um banco de registradores, um componente fundamental na Arquitetura de Computadores, sob a disciplina UnB – CIC0099 – Organização e Arquitetura de Computadores, ministrada pelo Prof. Marcus Vinicius Lamar.\n\n**Conteúdo Textual Transcrito:**\n*   **Título Principal:** Banco de Registradores (Register File)\n*   **Informações da Disciplina:** UnB – CIC0099 – Organização e Arquitetura de Computadores | Universidade de Brasília | CIC0099 – Organização da Arquitetura de Computadores | Prof. Marcus Vinicius Lamar\n*   **Rótulos em Diagramas:**\n    *   **Diagrama Superior (Visão Geral):** Números dos registradores, Registrador de leitura 1 (5), Registrador de leitura 2 (5), Registrador para escrita (5), Registradores, Dados da leitura 1, Dados da leitura 2, Dados para escrita, EscreveReg, Dados.\n    *   **Diagrama Superior (Visão Geral - Alternativo):** Read register 1 (5), Read register 2 (5), Write register (5), Registers, Read data 1, Read data 2, Write Data, RegWrite, Data.\n    *   **Seção \"Escrita\":** Escrita, Número do registrador, Decodificador n-para-2^n, Registrador 0, Registrador 1, Registrador n-2, Registrador n-1, D (entrada de dados do registrador), E (entrada de enable do registrador), Clock, Dados para o registrador.\n    *   **Seção \"Leitura\":** Leitura, Registrador de leitura número 1, Registrador de leitura número 2, Registrador 0, Registrador 1, Registrador n-2, Registrador n-1, Mux, Dados da leitura 1, Dados da leitura 2.\n\n**Descrição dos Diagramas e Fluxo de Dados:**\n\n1.  **Diagrama de Bloco de Alto Nível (Topo):**\n    *   Apresenta uma visão conceitual de um \"Banco de Registradores\" (Register File) como uma unidade funcional com múltiplas portas de leitura e uma porta de escrita.\n    *   **Entradas:**\n        *   Três entradas de endereço de 5 bits cada, indicando a capacidade para 32 registradores (2^5): \"Registrador de leitura 1\", \"Registrador de leitura 2\" (para endereçamento das portas de leitura), e \"Registrador para escrita\" (para endereçamento da porta de escrita).\n        *   Uma entrada de dados, \"Dados para escrita\", que fornece o valor a ser gravado.\n        *   Um sinal de controle \"EscreveReg\" (equivalente a \"RegWrite\"), que habilita a operação de escrita.\n    *   **Saídas:**\n        *   Duas saídas de dados: \"Dados da leitura 1\" e \"Dados da leitura 2\", correspondentes aos valores lidos dos registradores especificados.\n    *   Este diagrama ilustra a capacidade de leitura simultânea de dois registradores e escrita em um registrador diferente (ou o mesmo) em um único ciclo de clock.\n\n2.  **Diagrama Detalhado da Operação de Escrita (Inferior Esquerdo - \"Escrita\"):**\n    *   Detelha o mecanismo de escrita em um dos 'n' registradores do banco.\n    *   **Estrutura:** Consiste em um \"Decodificador n-para-2^n\" que recebe o \"Número do registrador\" (endereço de escrita). As 2^n saídas do decodificador são conectadas às entradas 'E' (Enable) de 'n' registradores individuais (Registrador 0, Registrador 1, ..., Registrador n-1) através de portas AND. A outra entrada de cada porta AND seria o sinal \"EscreveReg\" (não explicitamente desenhado aqui mas implicitamente presente no caminho de enable).\n    *   **Fluxo de Dados:** O \"Dados para o registrador\" é conectado à entrada 'D' de todos os registradores. O sinal de \"Clock\" é distribuído para todos os registradores, sincronizando a operação. Quando o \"Número do registrador\" ativa uma saída específica do decodificador e o sinal \"EscreveReg\" está ativo, a porta AND correspondente habilita o registrador selecionado. No próximo flanco de clock, os \"Dados para o registrador\" são gravados no registrador habilitado.\n\n3.  **Diagrama Detalhado da Operação de Leitura (Inferior Direito - \"Leitura\"):**\n    *   Detelha o mecanismo de leitura, que permite acesso simultâneo a dois registradores.\n    *   **Estrutura:** As saídas de todos os registradores (Registrador 0, Registrador 1, ..., Registrador n-1) são conectadas às entradas de dados de dois Multiplexers (Mux) distintos.\n    *   **Fluxo de Dados:**\n        *   O \"Registrador de leitura número 1\" atua como a entrada de seleção do Mux superior. Este Mux seleciona o valor de saída do registrador cujo endereço corresponde ao \"Registrador de leitura número 1\", fornecendo-o como \"Dados da leitura 1\".\n        *   De forma análoga, o \"Registrador de leitura número 2\" atua como a entrada de seleção do Mux inferior. Este Mux seleciona o valor de saída do registrador cujo endereço corresponde ao \"Registrador de leitura número 2\", fornecendo-o como \"Dados da leitura 2\".\n    *   A operação de leitura é combinacional (assíncrona ao clock para os dados de saída, mas os dados internos do registrador são síncronos) e permite que os dados de dois registradores distintos sejam lidos simultaneamente.\n\nEm resumo, o slide descreve o projeto lógico de um banco de registradores com duas portas de leitura e uma porta de escrita, detalhando o uso de decodificadores para seleção de escrita e multiplexadores para seleção de leitura, demonstrando como endereços de registradores são mapeados para operações de acesso a dados.",
        "transcription": "Certo, professor? Então, nós projetamos a ULA para dar suporte ao BEQ. E JAL? A gente precisa da ULA para quê? Para calcular o endereço para onde ele vai. Ou melhor, para calcular o endereço para onde o JAL vai pular. Então, todas as instruções usam a ULA. Vamos passar por isso aqui. Isso aqui também não precisa. Vamos pegar a partir daqui. Então, se nós observarmos a nossa... Tá bom, eu vou repetir. A nossa... Em um nível mais alto, nós temos aqui a memória de instruções e a memória de dados. Certo? Então, o PC endereça a memória de instruções, a memória de instrução vai ler uma instrução e vai decidir que registradores ele tem que ir, o que a ULA vai ter que fazer. Talvez tenha que ler um dado da memória ou talvez escrever um dado na memória. E calcular PC, que é o que tem no PC, mais 4 para ser o próximo PC. Então, isso aqui do ponto de vista bem alto. Então, olhando para isso aqui, isso aqui é Harvard ou Von Neumann? Harvard, porque a gente tem a diferença da memória de instruções. Exatamente. Temos duas memórias aqui em separado. Então, é Harvard. Indo um pouquinho mais... Abrindo um pouquinho mais em detalhes, a gente vê que... Aqui a gente vai precisar de multiplexador. Aqui a gente vai precisar de multiplexador. Aqui a gente vai precisar de... Cadê? Esse multiplexador, esse multiplexador... E esse multiplexador aqui. Por quê? Eu vou precisar gerar um sinal aqui que pode vir tanto desse dado, quanto desse dado aqui. Logo, isso aqui então... Vou precisar de um multiplexador para selecionar qual dessas duas entradas vai ter que ir para cá. A mesma coisa aqui. Os meus dados vão ter que vir ou daqui da ULA ou daqui da memória de dados. Como é que eu vou escolher isso? Através de um multiplexador. E aqui também. Certo? A entrada da ULA ou vem do banco de registradores ou vem da própria instrução. Então, também vou precisar de um multiplexador aqui. São esses multiplexadores que estão aqui. Certo? E... Nós vamos precisar também de um sisteminha de controle que vai dizer que vai ter que controlar esses multiplexadores e vai ter que controlar tudo que necessita ser controlado. Por exemplo, eu vou querer ler ou escrever da memória. Aqui a gente tem unidades combinacionais que são formadas puramente por portas lógicas. São essas aqui. E unidades sequenciais que armazenam dados. Então, elementos de armazenadores de memória. Ou elementos armazenadores de estado. Que o PC tem flip-flops, os registradores têm registradores e a memória de dados também armazena dados. E ficam duas situações apenas, esses dois carinhas aqui, que a gente não sabe se esse negócio é combinacional ou sequencial. Ah, mas é memória de instruções, professor. Então esse negócio é sequencial para criar e armazenar dados. Não necessariamente. Se vocês lembrarem dos semestres passados e dos semestres anteriores, uma memória ROM não é uma memória RAM. Porque o usuário não pode gravar nessa memória. Então ela é um circuito combinacional. O usuário só pode ler dessa memória. Então isso aqui vai depender de qual é o tipo de implementação que a gente vai estar utilizando. Se vai ser hardware ou ROM. Nesse caso aqui é ROM. Então isso aqui não é uma memória RAM. Ele é um circuito combinacional. E o outro é o bloco de controle, que eu não sei se aqui vai ter que ser um circuito combinacional ou um circuito sequencial. Então essa vai ser a diferença entre o uniciclo e o multiciclo. No uniciclo, esse aqui vai ser combinacional. E no multiciclo, isso aqui vai ser uma máquina de estados. Certo? Então a gente tem esses elementos aí. Passando rapidamente sobre os elementos sequenciais. Ou os elementos armazenadores de estado. Esse aqui vai ser o nosso registrador, que é um conjunto de flip-flops D. Simplesmente. Que vai ser regido por um clock. Que é um write enable. Quer dizer. No caso aqui, eu estou com um registrador de N bits. Certo? Então a entrada tem N bits. A saída tem N bits. Que é a leitura dos flip-flops que tem aqui. E para eu armazenar um dado nesse registrador, eu tenho que estar com um write enable habilitado. E esperar vir a borda de subida do clock. Então, quando vem a borda de subida do clock, se esse write enable estiver habilitado, então esse dado que está aqui na entrada vai ser gravado no registrador. E, passado um tempinho, vai aparecer aqui na saída. Ok? Para ler isso aqui, para eu ler esse registrador, basta eu ler o valor que tiver aqui. Eu não preciso esperar sinal de clock nenhum para ler. Então é o que a gente chama de: a escrita é síncrona pelo sinal de clock. O elemento só vai poder ser escrito na transição do clock. Certo? No caso de alto para baixo. Isso vai ser de borda de subida. Mas a leitura é assíncrona. Eu posso ler o valor que tiver aqui no instante que eu quiser. Só não posso ler no instante que eu estou escrevendo. Certo? Então é isso que a gente tem que evitar: ler e escrever no mesmo instante de tempo. Mas como a borda de clock possui um tempo muito pequeno, que é durante esse tempo aqui que o elemento está sendo escrito, eu vou ter todo esse período de tempo aqui para poder ler ele. Então eu só não posso ler nesse período de tempo aqui, durante a escrita. Mas depois, durante todo o restante do ciclo do relógio, eu vou poder ler. Entendido isso, pessoal? Ok. Memória. Mesma coisa. A nossa memória, a gente diz que ela vai ser uma memória de dois barramentos. Porque eu tenho um barramento de entrada, que é o dado que vai ser escrito na memória. E um barramento de saída, que é o dado que eu vou ler da memória. Então, nesse caso aqui, como a gente está trabalhando com a RISC-V 32, isso aqui é de 32 bits. Como é que funciona para eu escrever um elemento na memória? Para escrever esse dado aqui na memória, eu vou ter que primeiro colocar aqui qual o endereço da memória que eu quero escrever. Depois, colocar qual é o dado que eu quero escrever nesse endereço de memória. Habilitar o writeEnable. E quando vier a borda de subida de clock, é que esse dado vai ser escrito nesse endereço. Ok? Se o writeEnable estiver desabilitado, pode vir borda de subida à vontade aqui, que esse dado não é gravado. É necessário que o writeEnable esteja habilitado. E para fazer a leitura? Então, a escrita é síncrona com o relógio. E a leitura? Bom, para fazer a leitura, basta eu colocar aqui o endereço que eu quero ler. Colocando aqui o endereço que eu quero ler, passado um tempinho de leitura da memória, eu vou ter aqui qual é o dado que tem nesse endereço. E isso eu posso fazer em qualquer instante de tempo. Não preciso esperar a borda de nenhuma de relógio. Então é tal como se fosse um registrador. Ok. A escrita é síncrona. Ele não depende do relógio. A escrita é síncrona. Ok. Entendido isso, pessoal? Depois nos outros... Na aula passada eu explico isso bem direitinho. No nosso caso, o que a gente tem que evitar ao máximo é escrever e ler ao mesmo tempo. Então é isso que a gente não vai poder fazer. Certo? Então toda a nossa temporização tem que ser feita na borda de subida do clock. Os elementos de estado só podem ser atualizados na borda de subida do clock. E como a gente viu no laboratório, para que... Essa partezinha. Para que eu tenha os dados escritos no elemento de estado 1, esse dado ser processado por uma lógica combinacional, e o resultado desse processamento poder ser escrito num elemento de estado 2, eu tenho que respeitar a soma de clock para a saída desse elemento de estado. Quer dizer, quando vem o sinal de clock, esse aqui azulzinho, vem o sinal de clock. O dado já está aqui, de modo a... Esqueci a palavra... Garantir o setup time dele. Então, quando vem o sinal de clock, é o tempo até que esse dado que eu tenha colocado aqui na entrada apareça aqui na saída. Esse aqui está subindo de clock. Seria esse tempo até aqui. Então, esse aqui é o dado antigo que tinha. Daí mandei gravar. Ele passa um tempo lá gravando. E depois que o dado na saída fica estável. Esse aqui é o nosso Tco, tempo do clock até a saída ficar estável. Uma vez que a saída aqui ficou estável, eu vou ter um tempo de propagação por essa lógica combinacional. Certo? Que é o Tpd. E para que o resultado aqui do processamento da lógica combinacional possa ser escrito no elemento de estado 2, eu tenho que respeitar o setup time desse elemento de estado 2. Então esse dado tem que estar disponível um tempinho antes de vir a borda de subida do clock, que é o setup time dele. Então para que isso aqui funcione corretamente, o tempo entre uma borda de subida e a outra borda de subida tem que ser no mínimo o Tco desse elemento, mais o Tpd desse, mais o setup time desse. Então essa vai ter que ser a distância, quer dizer a distância temporal, o tempo entre duas bordas de subida para que esse esqueminha assim funcione. Tco desse, tempo de clock para a saída, mais o Tpd desse, mais o setup time desse aqui. Ok. Então está escrito aqui. Então a partir disso aqui é que nós vamos definir qual é a frequência máxima que o nosso processador vai poder ser utilizado. Porque se eu não respeitar esses tempos, ou a lógica combinacional vai estar processando algo que ainda não está estável aqui, e esse aqui vai gravar algo que não estava estável ainda. Se essa borda que acionou a escrita no elemento de estado 1 estiver muito próxima da borda que vai acionar a escrita no elemento de estado 2, não der tempo para esse processamento todo ocorrer. Ok. E esse aqui é importante para vocês entenderem esse conceito. Ok. Bom esse aqui a gente pode passar. Ok, esse aqui então vamos começar a montar o nosso caminho de dados. Para montar um caminho de dados, eu preciso ter uma memória de instruções onde aqui vai estar o meu programa. Eu preciso de um registrador onde vai estar armazenado qual é o endereço dessa memória de instruções que eu vou ler a instrução. E, nesse caso aqui, eu vou usar já também, uma vez que eu tenho o endereço atual, um somador para calcular quanto é que vale PC mais 4 para eu já calcular como vai ser o endereço da próxima instrução. Então são esses 3 elementos que eu preciso para o que a gente chama de etapa de busca de instruções. Quer dizer, o meu PC tem armazenado o endereço da instrução atual. Então esse endereço é colocado aqui na memória de instruções. Lembre que essa memória de instruções é uma memória só de leitura. Então ela não tem clock aqui, certo? A gente só vai ler dessa memória. Mas se a gente só vai ler, como é que vai botar o programa aí dentro? Ora. O fabricante desse chip aí é que vai colocar o programa aí dentro. Ok. Então, uma vez que ele endereça aqui, vai aparecer aqui qual é a instrução. Uma vez que o endereço esteja definido, então leitura assíncrona. Coloquei o endereço aqui. Passado um tempinho, eu tenho a instrução disponível aqui. E eu já posso calcular qual é o endereço da próxima instrução, né? Porque, diferente do x86, que não se sabe qual é o endereço da próxima instrução, no RISC-V se sabe. É sempre PC mais 4. Então, eu vou usar esse somador para somar o PC com 4. E vou disponibilizar esse endereço aqui. Esse novo endereço aqui. Quando que esse endereço vai ser gravado no PC? Somente quando vier a borda de subida de clock. Ele vai ficar aqui disponibilizado. Ok. E só na borda de subida é que esse endereço vai ser gravado no PC. Beleza. Então isso aqui é a etapa de busca da instrução e já cálculo do endereço da próxima instrução. Ok. Para uma instrução tipo R, o que a gente precisa fazer? A gente vai precisar ler o valor de dois registradores, o RS1 e RS2. Operar com esses dois registradores. A operação, quem vai definir é o opcode, o funct3 e o funct7. E eu vou ter que escrever o resultado em um terceiro registrador, registrador RD. Então a gente tem que ter uma estrutura que suporte isso aqui. Então o nosso banco de registradores, ele tem que permitir que eu leia dois registradores simultaneamente e escreva num terceiro. Ok. Se isso está aqui, o nosso register file, o banco de registradores, onde a estrutura externa dele, as interfaces, vai ser: eu recebo cinco bits para dizer quem é o registrador RS1. Recebo cinco bits para dizer quem é o registrador RS2. Então, uma vez definido esse registrador RS1 e RS2, passado o tempo de leitura desses registradores, e que vão ser disponibilizados para frente, e eu vou poder escrever em um terceiro registrador. Bom, se eu vou escrever em um elemento de estado, que é um registrador, então a escrita tem que ser síncrona. Quer dizer, eu vou precisar do sinal de clock e vou precisar de um write enable. Certo? Então aqui nós vamos colocar. Chamar esse write enable de RegWrite. Certo? Então, quando o RegWrite estiver acionado e vier a borda de subida de clock, o dado que tiver aqui, 32 bits, vai ser escrito nesse registrador de destino. Certo? Então a leitura é feita a qualquer tempo. Coloquei aqui os dois registradores, eu estou lendo os dados deles aqui. Mas a escrita não, eu preciso ter a borda de subida do clock. Ok. Então esse aqui é o nosso banco de registradores. E é isso aqui. Tem 32 registradores de 32 bits cada um. Tem um enable em cada um desses registradores. Está escrito write aqui. Quando estiver em 1, é porque eu estou habilitando a escrita nesse registrador. E se estiver em 0, eu não estou habilitando. Aqui eu vou então entrar com o número do registrador. Isso aqui é para a escrita. Eu quero escrever. Vou entrar isso em um decodificador de 5 para 32. Então, 5 bits entra aqui. E aqui sai um decodificador de 32 bits. Significa o quê? Que somente um desses pinos aqui vai estar em 1. O resto vai estar em 0. O pino que vai estar em 1 é aquele cujo número estiver colocado aqui. Certo? Então somente um desses, dessas portas ANDs aqui, vai ter uma das entradas 1 para eu fazer uma habilitação geral de escrita. Então eu tenho aqui um RegWrite, certo? Que é esse aqui. Ele vai entrar então a segunda entrada dessa porta AND. Então como é que funciona? Aqui está o meu dado de entrada, certo? O meu dado de entrada. Eu vou disponibilizar ele para todos os registradores. Então todos eles têm dado esse dado de entrada, certo? Se aqui a escrita está em 1, somente aquele registrador que eu tiver selecionado aqui vai estar com o pino 1 também. Então somente essa porta AND aqui vai estar em 1. Então ao vir a borda de subida de clock, esse dado vai ser armazenado nesse registrador. E os outros não vão ser armazenados, porque os outros bits aqui, os outros 31, vão estar em 0. Certo? A leitura. Bom, a leitura é mais simples. Então esse banco de registradores que está aqui é o mesmo que está aqui. Só que aqui eu coloquei ele pequenininho, ao invés de ser grandão assim. Porque se eu tenho 32 registradores e eu quero selecionar um deles para ler, eu vou ter que usar um multiplexador aqui. Certo? Então 5 bits vão selecionar um desses 32 registradores. E aquele que tiver sido selecionado vai mostrar o resultado aqui. Eu preciso ler de 2 registradores. Não tem problema. Coloca outro multiplexador aqui. A entrada desse outro multiplexador vem também desse banco de registradores. Certo? Então esse aqui vai ser a seleção do registrador 2. Então o RS2 e o RS1 aqui, certo? Vai selecionar então qual é o conteúdo do registrador RS2. E aqui o conteúdo do registrador RS1. A ULA nós já fizemos. Então está aqui só relembrando. Quais são os códigos de operação da ULA? 0000 AND, 0001 OR, 0010 ADD, 0110 SUB, 0111 SET_ON_LESS_THAN. A ULA tem 2 resultados aqui. Um é o result, que é 32 bits, que é o resultado dessa operação. Esses 2 números de 32 bits, que são... São esses 4 bits. E o zero, que indica quando o resultado é 0. Então se o resultado é 0, o pino de 0 recebe 1, que vai servir para um branch. Ok. Como é que eu interligo as coisas? Então numa operação tipo R, eu preciso, dado o RS1, que são esses 5 bits aqui da instrução. Esses 5 bits da instrução. O RS2, que são esses 5 bits da instrução. Então, colocando esses 5 bits aqui, passado um tempinho, eu tenho a leitura dos registradores aqui disponíveis. Certo? O que ele vai definir é o opcode, funct3 e funct7. Ok. Que vai definir quem é esse ALUOp. Aqui então ele vai operar. E o que eu tenho que fazer com esse resultado que a ULA vai me dar? O resultado da operação, por exemplo esse ADD aqui, S2 mais S3, eu tenho que escrever em S1. Então esse resultado eu vou colocar aqui no dado de escrita do banco de registradores. E escrever. Eu habilito o RegWrite, ou write enable. E quando vier o sinal de clock, esse dado aqui, que vem lá da saída da ULA, vai ser escrito no registrador RD. Ok. Que não dá nem tempo, né, pessoal? Vamos lá. Operação tipo I. A operação tipo I que nós temos é só uma, que é o LOAD. Certo? É só o LOAD que a gente tem, que é tipo I. Porque o BEQ é tipo B. JAL é tipo J. E STORE é tipo S. Então, tipo I é só o LOAD que tem esses campos aqui. Então, o que o LOAD deve fazer? O LOAD eu tenho que calcular esse endereço dado por esse registrador, que é o RS1, mais esse imediato aqui, que é de 12 bits. Para poder somar com esse aqui, eu tenho que estender o sinal. E isso aqui vai me dar um endereço que eu tenho que endereçar a memória de dados. Eu vou ter que ler da memória de dados. E escrever nesse registrador RD aqui, o que eu ler da memória de dados. Então, ah, já vamos fazer logo o STORE também. O STORE, que é tipo S, que possui esses campos aqui. Então, novamente aqui, eu tenho que ler o registrador RS1. Somar com o imediato de 12 bits. Certo. Estendido para 32 bits. Isso vai me dar um endereço. Vou ter que endereçar a memória. E nesse endereço da memória eu tenho que gravar o conteúdo do registrador RS2, que no nosso caso aqui é o T0. Beleza. Então é isso que eu tenho que fazer. Então para a gente fazer isso, a gente precisa da memória. Porque sem memória a gente não faz nada. Então está aqui a nossa memória. A nossa memória então vai ter o endereço, 32 bits. Dados de leitura 32 bits. Dados de escrita 32 bits. Ao invés de a gente ter um único write enable, o Patterson ele tornou as coisas mais didáticas, separando o write enable, que seria um pino só, em dois: o MemRead e o MemWrite. MemRead e MemWrite. Quer dizer, através da seleção. Se eu colocar MemWrite igual a 1 e MemRead igual a 0, é porque eu quero escrever na memória. Se eu coloco MemRead igual a 1 e MemWrite igual a 0, é porque eu quero ler da memória. Se eu coloco MemWrite igual a 0 e MemRead igual a 0, eu não quero nem ler nem escrever na memória. E um bom projetista nunca vai fazer o MemRead igual a 1 e MemWrite igual a 1. Porque ele vai estar querendo ler e escrever na memória ao mesmo tempo. Isso a gente não pode. Ok. Então essa aqui é a estrutura que a gente precisa utilizar. Então, aqui o gerador de imediato. O gerador de imediato, que é esse circuitinho aqui que vem aqui dentro. Nem falei do imediato. Mas tudo bem. Então. Aqui eu tenho 12 bits. Para eu somar com esse aqui, eu vou ter que estender o sinal desses 12 bits. Então o nosso gerador de imediato vai receber esses 12 bits e estender para 32. O nosso gerador de imediato vai receber esses 5 bits e esses 7 bits e vai estender para 32. Então está aqui. O LOAD. O imediato vai ser os últimos 12 bits, sendo bit 31 replicado 20 vezes. Está estendido o sinal. O imediato do STORE. 27 a 11 concatenados com bit 25 a 31 e o bit 31 replicado 20 vezes. E aqui já tem logo os 2 imediatos que vão ser formados para o BEQ e para o JAL. Certo. Então usando aquelas trocas. Bit azul para cá, bit vermelho para cá, bit verde para lá. Então te dá esses 2 imediatos aqui. Então notem que isso aqui. Concatenação de fios. Pegar o fio 11 até o 8 da instrução. Concatenar com 23. Do 25 a 30. Concatenar com 7. E estender o sinal do bit 31. A mesma coisa para o JAL. Só que uma outra configuração aqui. E notem que aquele bit default que sempre aparecia, que a gente não codificava, ele pode colocar aqui dentro. Então se colocar aqui dentro, nós vamos ver que pode ter uma pequena modificação no nosso caminho de dados. Esse bit default aqui. Esse zero. Então como é que esse nosso gerador de imediato? Ele recebe a instrução. A partir da instrução, ele sabe qual é desses imediatos que ele tem que gerar. Então aqui vai ter um multiplexador que vai selecionar. Se a instrução for um LOAD, então o imediato tem que ser feito dessa maneira. Se for um STORE, se for um JAL dessa. E sai um número de 32 bits só com o imediato. Então entra a instrução inteira. E sai só o imediato aqui de 32 bits. Dependendo da instrução, ele vai fazer uma dessas 4 concatenações aí. Então esse aqui é um circuitinho bem simples que tem aqui dentro. Um multiplexador. O que a gente precisa fazer então? Então como que a gente vai usar o LOAD? Então para o LOAD, para executar um LOAD, eu preciso primeiro ler o valor de RS1. O que é o valor de RS1? É aquele que eu preciso ler para somar com o imediato. Então eu preciso ler o valor de RS1. Pegar o imediato do LOAD. E somar. Certo? O resultado dessa soma do RS1 com o imediato vai te dar o endereço que eu tenho que endereçar a memória. O que mais? Eu quero ler dessa memória. Então. O MemWrite tem que ser 0. O MemRead tem que ser 1. Indicando que eu vou ler dessa memória. Então, uma vez que o endereço esteja disponível. A leitura é assíncrona. Então. Passado o tempinho de leitura. Eu tenho aqui o dado que eu preciso. Que eu li da memória. O que eu tenho que fazer com esse dado? Escrever no registrador RD. Certo? Quando vier a borda de subida do clock. O dado que eu li da memória vai ser escrito nesse RD. E acabou o LOAD. Certo? Então eu preciso ler o RS1. Somar com o imediato. E endereçar a memória. Leio da memória. O resultado que eu li da memória eu vou gravar no banco de registradores. No registrador RD. Ok. Se for um STORE. Então eu continuo precisando ler o RS1. Preciso também somar com o imediato. Para obter o endereço de onde eu vou querer gravar o valor do registrador RS2. Certo? Então o registrador RS2 entra direto aqui nos dados para a escrita. Certo? Então agora como eu quero escrever na memória. Então eu vou fazer MemWrite igual a 1. MemRead igual a 0. Quando vier a borda de subida. Esse dado vai ser escrito. Nesse endereço na memória. A escrita é síncrona. Sempre é escrita síncrona com sinal de borda. Certo? Então esse é o caminho de dados para LOAD e para STORE. Ok. O desvio condicional. Para o desvio condicional eu tenho tipo B. Que é esse. Esses campos aqui. Então opcode, 5 bits de imediato mais 7 bits de imediato. RS1 e RS2. Então o que eu preciso fazer? Se o RS1 for igual ao RS2. Quer dizer, nesse caso aqui é um BEQ. Se o T0 for igual ao T1. É porque eu preciso pular para o endereço. Quer dizer, para o endereço dado por PC. Mais esse deslocamento em bits aqui. Para o deslocamento em bits que eu tiver aqui. Certo? O endereço destino vai ser PC mais o deslocamento em bits que eu tenho aqui. Com aquele 0 default. Então se for falso. É PC mais 4, próximo. Então. O que eu preciso para fazer isso? Aqui. Entra o caso do 0 default. Esse shift left. Shift left. É um deslocamento de um bit para a esquerda. Certo? Então o Patterson ele coloca nos livros dele esse shift left. Esse 0 default. Não tiver sido colocado dentro do imediato. Quer dizer. Esse imediato não tiver esse 0 aqui. Certo? Aí tu precisa usar esse shift left aqui. Esse deslocamentozinho de um bit. Se o imediato já tiver o 0 default. Então tu não precisa desse aqui. Pode vir direto para cá. Ok? Então só cuidem. Para gerar o 0 default. Certo? Aquele 0 tem sempre o início do endereço. Então tu vai ler os dois registradores. RS1 e RS2. Quem vai fazer a comparação? É a ULA. Então a ULA vai ter que fazer uma subtração. Então aqui precisa fazer uma subtração. E aqui o pino de 0 vai dizer. Se a subtração deu 0 ou não. Quer dizer se os dois registradores são iguais ou não. Para eu poder decidir. Se eu vou pular para esse endereço aqui. Que é o PC mais o imediato. Ou se eu vou pular para PC mais 4. Certo? Quem vai decidir isso é essa saidinha de 0 aqui da ULA. Então com isso. A gente tem essa montagem aqui. Quer dizer, vamos pegar só a parte de. Do BEQ. Então eu vou ler os dois registradores. Tá? Vou fazer uma subtração. E o pino de 0 vai ter que me selecionar aqui. Se o próximo endereço que eu vou botar no PC vai ser PC mais 4. Ou se vai ser PC mais o imediato. Tá? Que é o endereço do BEQ. Ok? Então dessa maneira a gente tem que colocar esse multiplexador aqui. Para dizer o que vai ser gravado em PC. Tem que ser controlado. O que mais que a gente precisou colocar aqui? Esse multiplexador. Por que? Esse multiplexador é necessário. Por que? Vamos pegar aqui. Aqui. Essa entrada da ULA vem do gerador de imediato. Aqui. Essa entrada da ULA vem do banco de registradores. Escolher. Da onde que vem essa entrada da ULA? Do banco de registradores. Ou do gerador de imediato. Certo? Então aqui vai precisar de multiplexador. Onde mais nós vamos precisar de multiplexador? Aqui. O que é isso aqui? É o que diz o que vai ser escrito. No banco de registradores. Qual dado vai ser escrito no banco de registradores? Aquilo que se leu da memória. Ou aquilo que a ULA calculou. Certo? Então a gente tem esses dois casos. Aqui eu vou escrever no banco de registradores o que foi lido da memória. E aqui eu vou escrever no banco de registradores o resultado da ULA. Então novamente dois casos. Eu vou precisar de um multiplexador ali para controlar isso. Quem vai controlar isso? Então nós vamos chamar de. Os pinos de controle. Então esse aqui nós vamos chamar de. Esse aqui. Esse aqui. Esse aqui. ALU Control. ALU Source. Que vai dizer de onde que vem o segundo argumento da ULA. E o PC Source. No caso aqui. Como a gente não precisa um PC Source muito complicado. Poderia fazer o PC Source dessa maneira. Então agora vamos dar uma... Então, agora vamos dar uma entendida aqui o que isso aqui está fazendo. Antes era só selecionar aqui o PC Source, 0 ou 1, e ele selecionava o que ia ser gravado no próximo PC. Só que, quando que eu tenho que pular para cá, para esse endereço dado pelo BEQ? Eu só vou pular para esse endereço dado pelo BEQ se a instrução for um BEQ e se o BEQ for verdadeiro. Quer dizer, se o pino 0 da ULA for 1. Então, se for um BEQ e o BEQ for verdadeiro, é o único caso que eu vou selecionar esse endereço aqui para colocar para cá. Então, é isso que essa portinha AND aqui está fazendo. Aqui está a minha unidade de controle, que vai gerar todos os sinais de controle dos azuis. Então, o primeiro sinal de controle que a gente vai ter que colocar é se a instrução é um branch ou não. Então, aqui, dada a instrução, o controle vai decodificar essa instrução e vai me dizer se é um branch ou não. Se for um branch, ele coloca 1 aqui. E aqui, então, eu vou saber se o 0 for 1 e a instrução for um BEQ. Então, um BEQ e o BEQ deu verdadeiro. É o único caso que aqui eu vou ter 1. Certo? Que eu vou botar, selecionar, então, essa entrada aqui do endereço do BEQ para ser o próximo PC. Se a instrução não for um BEQ ou se o BEQ for falso, aqui vai dar 0. Quer dizer, a próxima instrução vem de PC mais 4. Note que aqui não está implementado o JAL. Ok? O JAL nós vamos fazer... No final dessa aula de hoje. Meu Deus, 5 e 20. 3 e 20. O que mais que o controle vai ter que controlar? Vai ter que controlar esse multiplexador aqui, que é o MemToReg. Certo? Então, seleciona o que é que vai ser escrito no banco de registradores, se é o que vem da memória ou se vem da saída da ULA. Os dois pinos de MemRead e MemWrite. Certo? Esses dois aqui. Esse multiplexador. Esse aqui, que é o ALU Source, que é a origem da ULA. Então, se for 0, vem do banco de registradores. E se for 1, vem do imediato. E o Patterson vai fazer um exemplo de controle hierárquico. Quer dizer, eu tenho aqui um controle principal. E esse controle principal vai controlar um outro controle secundário, que é o controle da ULA. Então, ao invés de eu colocar aqui diretos, os 4 bits, poderia pegar aqui o controle geral, os 4 bits que vêm para cá, para esse controle da ULA? Poderia. Mas ele vai mostrar uma forma um pouco mais eficiente, nesse caso, de como fazer isso. Vai entrar através desse controle secundário aqui. Então, aqui de novo, só que tudo em português agora. Então, mesma coisa. Isso aqui significa deslocamento de 1. Quer dizer, se não tem o 0 default aqui dentro, eu vou precisar desse deslocamento de 1. Que é esse shift left aqui. Tá, esse aqui é do laboratório, mas esse aqui é do laboratório de Verilog. Então, vocês não vão mexer com isso. Então, com isso a gente termina a aula passada. E esse é o caminho de dados.",
        "video_source": "OAC_2022-03-21.mp4"
    },
    {
        "id": 8,
        "timestamp_start": 2679.6,
        "timestamp_end": 2691.89,
        "slide_description": "Como um Engenheiro de Computação Sênior, procedo com a análise do slide e do contexto fornecido para extração de conteúdo para um sistema de busca semântica (RAG).\n\nA imagem apresentada corresponde à interface de uma plataforma de webconferência, identificada como \"ConferênciaWeb\", durante uma aula de \"Arquitetura de Computadores\" (inferido pelo título \"Sala de Aula de OAC\", onde OAC é comumente a sigla para Organização e Arquitetura de Computadores).\n\n**1. Transcrição de Texto e Títulos:**\n\n*   **URL da Sessão:** `live-aws022.mconf.rnp.br/html5client/join?sessionToken=lxj3rblgxtmd5n5t`\n*   **Título da Sala/Sessão:** \"Sala de Aula de OAC\"\n*   **Status da Gravação:** Indica que a sessão está sendo gravada, com duração atual de \"44:49\".\n*   **Navegação Lateral Esquerda:**\n    *   **MENSAGENS:**\n        *   \"Perguntas\"\n        *   \"Bate-papo público\"\n    *   **NOTAS:**\n        *   \"Notas compartilhadas\"\n    *   **USUÁRIOS (16):** (Lista parcial de usuários visíveis, indicando 16 participantes na sala)\n        *   Marcus Vinicius Lamar (Você)\n        *   Luiz Carlos Da Silva Neto Vartuli\n        *   Bruno Vargas de Souza\n        *   Eduardo Ferreira Marques Caval... (com ícone de microfone vermelho, sugerindo problema de áudio ou mute)\n        *   Felipe Dantas Borges\n        *   Gabriel Kenji Andrade Mizuno (com ícone de fone de ouvido)\n        *   Gustavo Rodrigues Da Costa (com ícone de fone de ouvido)\n        *   Harrison Freitas Magalhaes (com ícone de fone de ouvido)\n        *   Henrique De Miranda Carer (com ícone de fone de ouvido)\n        *   João Alberto Travassos Evangeli...\n*   **Conteúdo do Bate-papo público:**\n    *   **João Alberto Travassos Evan... 14:36**\n        boa tarde!\n    *   **Marcello Brandao Scartezini ... 14:37**\n        Agora o Lamar é um ciborgue, tem que falar B-O-M D-I-A\n    *   **Marcello Brandao Scartezini ... 14:42**\n        caiu a tela\n    *   **Mensagem do Sistema (sem nome/horário explícito):**\n        Bem vindos à sala de aula de OAC!\n        Esta sessão está sendo gravada.\n        Para mais informações, clique aqui.\n        Novo na plataforma? Experimente o tour!\n    *   **Eduardo Ferreira Marques C... 14:42**\n        a apresentação tbm caiu pra vcs?\n    *   **João Alberto Travassos Evan... 14:42**\n        sim\n    *   **João Alberto Travassos Evan... 14:49**\n        ok\n    *   **Victor Hugo Rodrigues Fern... 14:55**\n        Sim.\n    *   **Campo de Entrada de Mensagem:** \"Enviar mensagem para Bate-papo\"\n\n**2. Descrição de Diagramas e Fluxo de Dados:**\n\nA área principal de exibição do slide, destinada ao conteúdo da aula (diagramas, código, texto da apresentação), está completamente escura e vazia. Não há diagramas visíveis (como Datapath, Pipeline, Hierarquia de Memória), código (Assembly, C, Verilog), ou qualquer outro conteúdo técnico que normalmente seria exibido em uma aula de Arquitetura de Computadores.\n\nAs mensagens no bate-papo público, particularmente \"caiu a tela\" (Marcello Brandao Scartezini, 14:42) e \"a apresentação tbm caiu pra vcs?\" (Eduardo Ferreira Marques C..., 14:42), seguidas por \"sim\" e \"Sim.\" de outros participantes, indicam claramente que houve uma falha na exibição do conteúdo da apresentação para os alunos. Portanto, a ausência de diagramas ou código não é intencional, mas sim resultado de um problema técnico durante a sessão.\n\n**Resumo para RAG:**\n\nEste artefato visual representa a interface de uma aula online de Arquitetura de Computadores (\"Sala de Aula de OAC\") em andamento e sendo gravada (44:49). A plataforma de conferência exibe um painel lateral com opções de mensagens (perguntas, bate-papo público) e notas compartilhadas, além de uma lista de 16 usuários participantes. O bate-papo público contém interações entre os alunos, incluindo uma notificação de boas-vindas e gravação de sessão. Crucialmente, as mensagens dos participantes (\"caiu a tela\", \"a apresentação tbm caiu pra vcs?\") indicam que o conteúdo principal da aula (slides, diagramas de arquitetura, código Assembly/C/Verilog, etc.) não está sendo exibido, sugerindo uma interrupção ou problema técnico na apresentação. Consequentemente, não há diagramas estruturais, de fluxo de dados ou código técnico visíveis para extração neste momento.",
        "transcription": "A aula de hoje. Então, na aula de hoje a gente vai ver",
        "video_source": "OAC_2022-03-21.mp4"
    },
    {
        "id": 9,
        "timestamp_start": 2691.89,
        "timestamp_end": 2695.89,
        "slide_description": "Como Engenheiro de Computação Sênior, procedo com a análise do slide e do contexto anotado para um sistema de busca semântica (RAG).\n\n**Análise do Slide e Conteúdo Visual:**\n\nO slide em questão é uma tela de introdução ou título de uma aula de Arquitetura de Computadores.\n1.  **Transcrição Fiel de Texto e Títulos:**\n    *   **Identidade Institucional:** No topo, lê-se \"Universidade de Brasília\" e \"Departamento de Ciência da Computação\". No canto superior direito, em menor escala, há uma repetição da logomarca e nome da \"Universidade de Brasília\", \"Departamento de Ciência da Computação\", acompanhada da identificação da disciplina: \"CIC 0009 – Organização e Arquitetura de Computadores\" e o nome do professor: \"Prof. Marcus Vinícius Lamar\".\n    *   **Título da Aula:** O corpo principal do slide, sobre um fundo em tons de laranja e amarelo, apresenta os seguintes títulos:\n        *   \"Aula 13\"\n        *   \"Implementação RISC-V\"\n        *   \"Uniciclo – Unidade de Controle\"\n    *   **Conteúdo Adicional (não no slide, mas no contexto visual da aula):**\n        *   O ambiente de conferência exibe o título da sala como \"Sala de Aula de OAC\", confirmando a disciplina \"Organização e Arquitetura de Computadores\".\n        *   Uma mensagem de boas-vindas na janela de chat informa: \"Bem vindos à sala de aula de OAC! Esta sessão está sendo gravada. Para mais informações, clique aqui. Novo na plataforma? Experimente o tour!\".\n        *   O timer da sessão indica \"45:01\" minutos de aula transcorridos.\n        *   O nome do professor, \"Marcus Vinicius Lamar\", é visível na lista de usuários e também associado à disciplina no cabeçalho do slide.\n\n2.  **Descrição de Diagramas e Elementos Visuais:**\n    *   Não há diagramas técnicos como Datapaths, Pipelines ou Hierarquias de Memória visíveis neste slide específico. Trata-se de um slide de título.\n    *   **Elemento Gráfico Principal:** Na parte inferior central do slide, há um ícone visualmente proeminente: um losango amarelo com borda preta, contendo a silhueta preta de um controle de videogame (gamepad). Este elemento parece ser um marcador visual ou uma \"easter egg\", não possuindo uma função técnica direta no contexto da arquitetura de computadores, mas pode indicar uma abordagem mais lúdica ou uma referência a algum conceito abstrato que será explorado na aula, ou simplesmente uma escolha de design do professor.\n    *   **Logomarcas:** As logomarcas da Universidade de Brasília e do Departamento de Ciência da Computação são representadas por um ícone estilizado que lembra uma folha ou uma formação abstrata em tons de verde e azul.\n    *   **Professor:** A imagem do professor, Marcus Vinícius Lamar, é visível no canto inferior direito, gesticulando com a mão direita e usando óculos.\n\n**Fluxo de Dados e Estrutura (Implicações do Conteúdo):**\n\nEmbora não haja diagramas de hardware para descrever o fluxo de dados diretamente neste slide, o título \"Implementação RISC-V Uniciclo – Unidade de Controle\" estabelece claramente o tópico técnico principal da aula. Isso indica que a aula abordará a arquitetura de conjunto de instruções (ISA) RISC-V, focando especificamente em sua implementação em um design de processador de ciclo único (Uniciclo) e, de forma crucial, na \"Unidade de Controle\". A Unidade de Controle é o cérebro do processador, responsável por decodificar instruções e gerar os sinais de controle necessários para orquestrar o fluxo de dados através do datapath, selecionando multiplexadores, habilitando registradores e unidades funcionais (ALU, memória). A discussão provavelmente envolverá a lógica combinacional ou sequencial que define o comportamento da Unidade de Controle para cada tipo de instrução RISC-V. A ausência de diagramas neste slide de abertura sugere que os detalhes técnicos da estrutura e do fluxo de dados para a implementação uniciclo, incluindo o datapath e os sinais da unidade de controle, serão introduzidos e explicados nos slides subsequentes da Aula 13.\n\nEm resumo, este slide serve como um ponto de entrada para uma discussão aprofundada sobre a implementação de processadores RISC-V, com foco na arquitetura uniciclo e, em particular, no projeto e funcionamento da Unidade de Controle.",
        "transcription": "a Unidade de Controle. Quer dizer,",
        "video_source": "OAC_2022-03-21.mp4"
    },
    {
        "id": 10,
        "timestamp_start": 2695.89,
        "timestamp_end": 4913.96,
        "slide_description": "Como um Engenheiro de Computação Sênior, analiso o slide de uma aula de Arquitetura de Computadores da UnB (Universidade de Brasília), curso CIC0099 – Organização e Arquitetura de Computadores, lecionado pelo Prof. Marcus Vinicius Lamar, com foco nos \"Sinais de Controle\" de um datapath simplificado.\n\nO slide apresenta um diagrama de um datapath de ciclo único, que ilustra o fluxo de dados e os sinais de controle essenciais para a execução de diferentes tipos de instruções (tipo-R, lw, sw, beq).\n\n**Estrutura do Datapath e Fluxo de Dados:**\n\n1.  **Estágio de Busca de Instrução (Instruction Fetch):**\n    *   O **Program Counter (PC)** armazena o endereço da instrução atual.\n    *   Este endereço é enviado para a **Instruction memory**.\n    *   A **Instruction memory** retorna a instrução completa (Instruction [31-0]).\n    *   O PC é incrementado por 4 (bloco 'Add' com entrada '4') para apontar para a próxima instrução sequencial. A seleção do próximo valor do PC é feita por um multiplexador (Mux), que escolhe entre o PC+4 ou o endereço de desvio (calculado a partir do PC, um \"Shift left 1\" do imediato gerado e uma soma). A condição de desvio é determinada pela saída de um portão AND que combina o sinal \"Branch\" do Control Unit e o sinal \"Zero\" da ALU.\n\n2.  **Estágio de Decodificação e Busca de Registradores (Instruction Decode / Register Fetch):**\n    *   A instrução é decodificada, e seus campos são utilizados:\n        *   Instruction [19-15] (RS) e Instruction [24-20] (RT) são usados como endereços de leitura para os **Registers** (Read register 1 e Read register 2, respectivamente).\n        *   Instruction [15-11] (RD para tipo-R ou RT para lw) é usado como endereço de escrita para o registrador (Write register).\n    *   O bloco **Registers** fornece os dados lidos (Read data 1 e Read data 2).\n    *   Um módulo **Imm Gen (Immediate Generator)** recebe os bits da instrução [30,14-12] e gera um valor imediato de 32 bits estendido por sinal. Este valor é crucial para o cálculo de endereços (lw/sw) e offsets de desvio (beq).\n\n3.  **Estágio de Execução (Execute):**\n    *   A **ALU (Arithmetic Logic Unit)** realiza as operações.\n    *   O primeiro operando da ALU vem do Read data 1 dos Registers.\n    *   O segundo operando da ALU é selecionado por um multiplexador, controlado pelo sinal **ALUSrc** do Control Unit. As opções são Read data 2 (dos Registers) ou o valor imediato do Imm Gen.\n    *   O módulo **ALU control** recebe o sinal **ALUOp** do Control Unit e o campo de função (Instruction [6-0]) para instruções tipo-R, gerando o sinal específico para a operação da ALU.\n    *   A ALU produz um **ALU result** e um sinal **Zero** (indicando se o resultado é zero, essencial para desvios condicionais).\n\n4.  **Estágio de Acesso à Memória (Memory Access):**\n    *   O **ALU result** pode ser usado como **Address** para a **Data memory**.\n    *   Para operações de escrita (sw), o **Read data 2** dos Registers é utilizado como **Write data** para a Data memory.\n    *   A **Data memory** pode fornecer um **Read data**.\n    *   As operações de leitura e escrita na memória de dados são controladas pelos sinais **MemRead** e **MemWrite** do Control Unit.\n\n5.  **Estágio de Write Back (Write Back):**\n    *   Um multiplexador, controlado pelo sinal **MemtoReg** do Control Unit, seleciona qual valor será escrito de volta nos **Registers**: o **ALU result** (para operações tipo-R) ou o **Read data** da Data memory (para lw).\n    *   O sinal **RegWrite** do Control Unit habilita a escrita no banco de registradores.\n\n**Unidade de Controle (Control Unit):**\nA unidade de controle é central e recebe o opcode da instrução (Instruction [31-26]). Ela gera todos os sinais de controle que governam o comportamento do datapath:\n*   **Branch**: Habilita o cálculo do endereço de desvio.\n*   **MemRead**: Habilita a leitura da memória de dados.\n*   **MemtoReg**: Seleciona a fonte de dados para escrita no registrador (ALU result ou memória).\n*   **ALUOp**: Indica o tipo de operação da ALU para o ALU control.\n*   **MemWrite**: Habilita a escrita na memória de dados.\n*   **ALUSrc**: Seleciona o segundo operando da ALU (registrador ou imediato).\n*   **RegWrite**: Habilita a escrita no banco de registradores.\n\n**Tabela de Sinais de Controle:**\nAbaixo do diagrama, há uma tabela que detalha os valores dos sinais de controle para instruções específicas:\n\n| Instrução | ALUSrc | Mem2Reg | RegWrite | MemRead | MemWrite | Branch | ALUOp |\n| :-------- | :----- | :------ | :------- | :------ | :------- | :----- | :---- |\n| Tipo-R    | 0      | 0       | 1        | 0       | 0        | 0      | 10    |\n| lw        | 1      | 1       | 1        | 1       | 0        | 0      | 00    |\n| sw        | 1      | X       | 0        | 0       | 1        | 0      | 00    |\n| beq       | 0      | X       | 0        | 0       | 0        | 1      | 01    |\n\n*   **Tipo-R**: A ALU usa o segundo registrador (ALUSrc=0), o resultado da ALU é escrito no registrador (Mem2Reg=0, RegWrite=1), não há acesso à memória (MemRead=0, MemWrite=0), nem desvio (Branch=0). ALUOp=10 indica que a operação específica é determinada pelo campo funct.\n*   **lw (Load Word)**: A ALU usa o imediato para cálculo de endereço (ALUSrc=1), o dado lido da memória é escrito no registrador (Mem2Reg=1, RegWrite=1), lê da memória (MemRead=1), não escreve na memória (MemWrite=0), nem desvia (Branch=0). ALUOp=00 indica uma adição para cálculo de endereço.\n*   **sw (Store Word)**: A ALU usa o imediato para cálculo de endereço (ALUSrc=1), não há escrita no registrador a partir da memória (Mem2Reg=X, RegWrite=0), não lê da memória (MemRead=0), mas escreve na memória (MemWrite=1), nem desvia (Branch=0). ALUOp=00 indica uma adição para cálculo de endereço.\n*   **beq (Branch if Equal)**: A ALU usa o segundo registrador (ALUSrc=0), não há escrita no registrador (Mem2Reg=X, RegWrite=0), não há acesso à memória (MemRead=0, MemWrite=0), mas há desvio (Branch=1) se o sinal Zero da ALU for alto. ALUOp=01 indica uma subtração para verificar igualdade e definir o flag Zero.\n\nEste slide fornece uma visão detalhada de como os sinais de controle orquestram a operação de um processador para executar instruções de forma sequencial ou com desvios, sendo um conceito fundamental em arquitetura de computadores.",
        "transcription": "aqueles circuitos lá que são da unidade de controle. Porque o processador é dividido em caminhos de dados e unidades de controle. Então, isso aqui é só relembrando o que a gente fez. A gente vai fazer um processador que é capaz de executar essas instruções aqui. Notem que o **pipeline** não está aqui ainda. Uma observação em relação ao uniciclo. Como em um uniciclo toda a instrução vai ter que ser executada em um único ciclo de **clock**. Então, eu não vou poder reutilizar unidades funcionais. Quer dizer, eu não posso usar a **ALU** duas vezes. Eu não posso fazer uma leitura e escrita na memória no mesmo ciclo. Eu vou poder utilizar as unidades funcionais apenas uma vez durante o ciclo de **clock**. Então, quer dizer que nenhum dos recursos pode ser utilizado mais de uma vez por instrução. Isso aqui vai ser interessante, porque depois nós vamos ver o uniciclo **pipeline** e a gente vai ter que retomar esse conceito aqui. Então, está aqui o nosso caminho de dados que a gente acabou de ver. Nesse caminho de dados a gente sabe que os códigos da **ALU** são esses aqui. E aqui ele vai apresentar esse projeto hierárquico. Esse projeto hierárquico, primeiro nós vamos projetar esse controladorzinho aqui. Depois nós vamos projetar esse controlador aqui. Então, para esse controladorzinho, o que eu preciso gerar aqui? Então, esse aqui vai ser um circuitinho combinacional que vai gerar quatro bits de saída. E vai ter como entrada, então vamos ver como é que nós vamos fazer. Os quatro bits de saída que ele tem que gerar são esses aqui. Para as operações **AND, OR, ADD, SUB, SLT (SET ON LESS THAN)**. Vamos observar o seguinte. **LOAD** e **STORE** usam a **ALU** para calcular o endereço. Logo, eles sempre vão usar a **ALU** para fazer uma soma. **ADD, SUB, AND, OR, SLT** usam as cinco operações que tem aqui. Então, essas instruções que são as instruções tipo-R, vão utilizar qualquer uma dessas instruções. Já essas duas aqui vão usar a soma. E o **BEQ**? O **BEQ** vai precisar usar a subtração. Eu preciso que a **ALU** faça a subtração dos dois **registradores** para ver se deu zero o resultado. Para eu poder selecionar o multiplexador de próximo endereço. Observando isso aqui, eu tenho três situações aqui. Uma situação onde a **ALU** faz uma soma. Uma situação onde a **ALU** faz uma subtração. E uma situação onde a **ALU** vai ter que selecionar uma dessas cinco operações. Para eu selecionar uma de, no caso, três possíveis situações, eu preciso de dois bits. Certo? Lembrando que os **opcodes** do **LOAD** é 03, do **STORE** é 23, para o **BEQ** é 63 e o tipo-R é 33. Certo? E no tipo-R, os campos **FUNCT7** e **FUNCT3** é que definem efetivamente qual é a instrução que vai ser executada. Certo? Todas elas têm o mesmo **opcode**. Então tem um **opcode** para o **LOAD**, um **opcode** para o **STORE**, um **opcode** para todo esse conjunto e um **opcode** para o **BEQ**. Ah é, boa! Marque a presença. Então vamos criar aqui um sinalzinho que nós vamos chamar de **ALUOp** de dois bits. Para identificar cada uma dessas três categorias. Então vamos considerar que **ALUOp 00** corresponde aos acessos à memória, **LOAD** e **STORE**. Onde a **ALU** vai fazer uma soma. Então 00 a **ALU** faz uma soma. 01 vai ser utilizado no **BEQ**. Onde a **ALU** vai fazer uma subtração. E o 10 eu vou ter que escolher uma dessas operações lógicas e aritméticas. Logo, pelo **opcode**, se eu souber o **opcode** delas, eu consigo selecionar qual é o **ALUOp**. Certo? Porque o **ALUOp** do **LOAD** vai ser 00, o **ALUOp** do **STORE** vai ser 00. O **ALUOp** do **BEQ** vai ser 01. E o **ALUOp** do tipo-R vai ser 10. Só que para eu poder especificar exatamente qual é a instrução do tipo-R, eu vou precisar do **FUNCT3** e do **FUNCT7**. Então gerando assim, que nós vamos concatenar **FUNCT3** com **FUNCT7**, nós vamos ter 10 bits aqui. Então para o nosso controlador da **ALU** ele tem que gerar os 4 bits de controle da **ALU**. São esses aqui. Ele vai receber os 2 bits do **ALUOp** que é esse aqui, e mais os 10 bits do **FUNCT3** e **FUNCT7**. Então com essas entradas eu preciso definir esses 4 bits. Bom, circuitinho combinacional. Então circuitinho combinacional, a gente tem que montar a tabela verdade. Isso aqui, vamos lá. Tabela verdade. Então para o **LOAD**, o **ALUOp** tem que ser 00. **FUNCT7** e **FUNCT3** não têm em um **LOAD**. E a operação da **ALU** vai ser um **ADD**. Quer dizer, a saída da **ALU** tem que ser 0010 que é a operação de **ADD**. Para o **STORE**, o **ALUOp** também tem que ser 00. Campos **FUNCT3** e **FUNCT7** não me interessam. E o código que a **ALU** deve receber é o mesmo 0010 que é o que ele faz soma. Para o **BEQ** o **ALUOp** vai ser 01. Não interessa os campos **FUNCT3** e **FUNCT7**. A operação que a **ALU** tem que fazer é um **SUB**, uma subtração. Que é dado pelo código 0110. E o tipo-R, pelo **opcode**, eu sei que é tipo-R. Então todos eles vão ser 10. E o 10 vai ser o campo **FUNCT** que vai definir o que deve ser utilizado. Então o campo **FUNCT7** e **FUNCT3** do **ADD** é esse. Então qual é a operação da **ALU** que tem que fazer se ela receber 10 e esse aqui tudo 0? Tem que fazer o **ADD** que é 0010, que é o mesmo desse aqui. Se for um **SUB** **FUNCT7** e **FUNCT3** são esses. Então ela tem que fazer 0110. Certo? Que é esse aqui. Se for um **AND** **FUNCT3** e **FUNCT7** são esses. Então ela tem que gerar como saída a operação de controle para o **AND** 0000. Se for um **OR** **FUNCT3** e **FUNCT7** são esses. Tem que gerar esse aqui. E se for o **SLT (SET ON LESS THAN)** **FUNCT3** e **FUNCT7** são esses. Que tem que gerar esse código de saída: 0111. Que é o **SLT**. Ok. Então vamos agora abrir essa nossa tabela verdade aqui. Tá? Abrir que eu digo para a gente verificar exatamente quais são as entradas. As entradas são esses 2 bits e esses 10 bits aqui. De novo, são esses 2 bits e esses 10 bits. Para saída de 4 bits. Que são essas aqui. Então tá aqui ó. Então o **ALUOp0** é o... O **ALUOp** são 2 bits. Então esse aqui é o bit menos significativo do **ALUOp** e esse aqui é o bit mais significativo do **ALUOp**. Então são os **FUNCT3** e **FUNCT7**. Que são os bits da instrução. Os bits 12, 13, 14 da instrução. 25, 26, 27, 28, 29, 30, 31 da instrução. Então. Para o primeiro caso. 00. A **ALU** tem que fazer uma soma. Está aqui. Independente do que tenha no **FUNCT3** e **FUNCT7**. 01. A **ALU** tem que fazer uma subtração. Independente do que tenha no **FUNCT3** e **FUNCT7**. Deve sair isso aqui. 10. Bom, 10. Seria todos esses casos aqui. Vai depender do valor de **FUNCT3** e **FUNCT7**. Para gerar isso aqui. Então a pergunta. Vocês saberiam montar esse circuito? Conseguiriam montar esse circuito combinacional que faz isso aí? Notem que a gente pode... Se a gente fosse montar esse circuito aqui. Vamos lá. Quantas entradas teria esse circuito? Quantas entradas teria? 20. Boa Marcelo. É exatamente isso. Com tempo e dinheiro tudo é possível. 12. Se a gente fosse fazer a tabela verdade. Daria quantas linhas? Se tem 12 entradas. Isso que dá. 2 na 2. Vezes 2 na 10. 2 na 10 é quilo. 2 na 2 é 4. Então 4 e 96 linhas. Certo? Mas a gente pode observar o seguinte. Se a entrada aqui. Serve para alguma coisa. Ela me separa alguma coisa. Eu não posso botar a X aqui como 0 e 0. Então ela sempre 0. Interessa? Não interessa. Essa aqui. Interessa? Posso botar aqui 0 e 0 também. Não interessa. Essa aqui interessa? Também não. Essa aqui interessa? Também não. Essa aqui interessa? Também não. Mas essa aqui. Cadê eu aqui? Essa aqui interessa. Porque aqui eu tenho. Ele separa 2. E essas 3 aqui também interessam. Certo? Então na realidade ao invés de ser 12 entradas. É 1, 2, 3. 4, 5, 6. Entradas. Certo? 4 mapinhas de Carnot. De 6 entradas. Tranquilo né? Certo? 4 mapinhas de Carnot. 1 para cada um desses aqui. De 6 entradas. A gente pode simplificar mais ainda. Esse bit aqui. Qual é a operação lógica desse bit? Do **ALU Control** 3. Qual é a operação lógica desse bit? A equação lógica desse bit? Qual é a equação lógica que define esse bit aqui? 0. 0. Então não preciso de 4 mapas de Carnot. Bastam 3 mapinhas de Carnot. Certo? 3 mapinhas de Carnot com 6 cada um. Beleza. Vocês definem aqui o que for melhor. Para otimizar. E projetam o circuito. É muito simples isso aqui. Muito simples mesmo. Então fica de exercício para vocês fazerem isso aqui. Projetar o circuito com portas lógicas. Tá? Ou então. Usando o **Verilog**. Tá? Então tá aqui o módulo de controle da **ALU**. Que eu tenho como entrada um **FUNCT10**. Que é o **FUNCT7** concatenado com **FUNCT3**. Como entrada o **ALUOp**. São 2 bits. E tem como saída os 4 bits do **ALUControl**. E eu posso usar. Então dentro do **always @***. Já que eu quero um circuito combinacional. **case**. Se **ALUOp** for 00. O **ALUControl** recebe o **op-ADD**. Que é isso aqui. **case**. Se o **ALUOp** for 01. O **ALUControl** recebe o **op-SUB**. Que é esse aqui. **case** for 10. Aí sim. Se for 10 eu vou ter que analisar o **FUNCT10**. Tá? Se o **ALUOp** for 10. Tem que verificar o **FUNCT10**. Se o **FUNCT10** for o **FUNCT** do **ADD**. Que é esse aqui. Então sai o **op-ADD**. Se for o **FUNCT** do **SUB**. Que é esse aqui. Sai o **op-SUB**. Se for o **FUNCT** do **AND**. Que é esse aqui. Então sai o **op-AND**. Se for o **FUNCT** do **OR**. Que é esse aqui. Então sai o **op-OR**. Se for o **FUNCT** do **SLT**. Então sai o **op-SLT**. E acabou. E não esqueçam dos **defaults**. Default 0 e default 0. Assim fica trivial de fazer. Concordam comigo que é trivial. Fazer isso aqui agora. Exato. Beleza. Então. Fizemos o controladorzinho da **ALU**. Tá? E agora o que a gente precisa fazer? O controlador **MAIN**. Certo? Deus que controla todo o processador. Então o que vai ser o nosso controlador principal? É esse aqui. Então o que ele vai receber? Ele precisa receber a instrução toda aqui? Não. Porque o campo **FUNCT**. Está entrando aqui. E o campo **FUNCT** só vai servir. Para a gente separar. Dessa tipo-R. Quais são elas? Então não preciso colocar aqui. Os campos **FUNCTs**. Eu só preciso colocar aqui o **opcode**. Então os bits 0 a 6. Da instrução. Então a entrada do meu controle agora. Vai ser só o **opcode**. Por isso que essa hierarquização. Aqui do controle facilitou. Tá? Porque se eu não tivesse feito. O controle hierárquico. Eu teria que colocar aqui. Os 6 bits. Os 7 bits do **opcode**. Mais os 10 bits. Do **FUNCT3** e **FUNCT7**. Certo? Ia gerar um circuitinho maior aqui. Ok. Então vamos lá para o nosso controle **MAIN**. Tudo bem. A gente já sabe isso. Então agora que eu quero que vocês. Relaxem na cadeira. Porque é aqui. Que a mágica acontece. Quando a gente fala de interface. **Software**. **Hardware**. A gente está falando disso aqui. Do controle. Quer dizer. Como que eu escrevo uma instrução. E o meu controle. Decodifica essa instrução. E faz com que essa instrução. Seja executada. Quer dizer configura o caminho de dados. Para que aquela instrução. Que eu li da memória. Seja executada. Então a interface **software-hardware**. Está aqui. Aqui é **software**. E depois do controle. Ele controla o **hardware**. Entendido pessoal? Aqui você não vai mais. Entender o processador. Como uma caixinha preta. Por que? Então vamos lá. Se aqui eu tenho na entrada. Somente **opcodes**. É **opcode** do tipo-R. **Opcode** do **LOAD**. Do **STORE** e do **BEQ**. Eu só tenho esses quatro. Certo? Beleza. Então se eu tenho somente esses quatro **opcodes**. Todos esses sinais aqui. Vão ter que ser definidos. Baseado nesse **opcode**. Então vamos lá. Para a gente poder entender. Se for **opcode** do tipo-R. Se eu tenho uma instrução tipo-R. Eu vou ter que gerar todos esses sinais aqui. Que são esses sinais que estão aqui. Então. Se a instrução é tipo-R. Esse multiplexador. Da onde que tem que vir. O segundo operando da **ALU**. Tem que vir do banco de registradores. Ou do imediato. Se a instrução é tipo-R. A instrução é tipo-R. O primeiro operando da **ALU**. Vem do banco de registradores. Mas o segundo. Vem do banco de registradores. Ou do imediato. E configurando. O caminho de dados. Para a execução daquela instrução. Então a operação tipo-R. O segundo operando da **ALU**. Vem do banco de registradores. Ou do imediato. Eu quero que vocês respondam pessoal. É uma operação tipo-R. João. Eu ia dizer. Eduardo. Certo. Se a operação é tipo-R. Ela não tem imediato. Isso. Então tem que vir do banco de registradores. É esse tipo de erro. Que torna a **OAC** difícil. Vocês têm que entender exatamente. O que a instrução pede para fazer. E configurar o **hardware**. Daquele jeito. Então esse primeiro aqui. Tem que ser zero. Está aqui. **MemtoReg** para R. Esse multiplexador aqui. Numa instrução tipo-R. O que deve ser gravado no banco de registradores. O que vem da memória. Ou o que vem da saída da **ALU**. Então. **MemtoReg** para R. O que tem que ser gravado no banco de registradores. O que vem da memória. De dados. Ou o que vem da saída da **ALU**. Tenham sempre em mente. Qual é a instrução que a gente está fazendo. Uma instrução tipo-R. Vamos lá. **MemtoReg** para R. Porque está escrito aqui em baixo. Não é Marcelo? Não. Porque aquilo que a gente calculou com a **ALU**. É que eu quero gravar no registrador **RD**. Certo? Então zero. Instrução tipo-R. Grava no banco de registradores. Uma instrução tipo-R. Grava no banco de registradores. Sim ou não? Sim. Então eu preciso acionar o **RegWrite**. **RegWrite** igual a 1. Quando vier o sinal de **clock**. Eu vou gravar esse dado. No registrador **RD**. Então eu tenho que habilitar a escrita. **RegWrite** igual a 1. Instrução tipo-R. Lê da memória de dados. Tipo-R. Lê da memória de dados. Está bom. Vou colocar aqui uma tipo-R. Só para vocês ficarem olhando para ela. Para não ficar tão abstrato assim. Tipo-R. Lê da memória de dados. Não. Então. Tipo-R. Escreve na memória de dados? Tipo-R. Escreve na memória de dados? Também não. Então **MemWrite**. Zero. Tipo-R. É um **branch**? Operação tipo-R. É um **branch**? É um desvio condicional? Não. Então **Branch** vale zero. Na operação tipo-R. Qual é o **ALUOp**? Esses dois bits aqui que vêm para cá. Na operação tipo-R. Então de novo. Zero. Zero. Faz uma soma. Zero. Um. Faz uma subtração. Um. Zero. É o campo **FUNCT** que define. Esse aqui é o nosso **ALUOp**. Tudo bem. **ALUOp**. Tá. Dá no mesmo. Então. Uma operação tipo-R. Qual é o **ALUOp**? Zero. Zero. Zero. Um. Um. Zero. Quer dizer. Uma operação tipo-R. Ele tem que fazer uma soma. Ele tem que fazer uma subtração. É o campo **FUNCT** que define qual é a operação que ele tem que fazer. O campo **FUNCT** define. Então. Um. Zero. Ok. Agora a instrução é um **LOAD**. **LOAD**. T0. 10. S1. Por exemplo. Então um **LOAD**. **ALUSrc**. Esse aqui. O segundo operando da **ALU**. Se a instrução é um **LOAD**. Tem que vir do banco de registradores. Ou do imediato. Se a instrução é um **LOAD**. O que a **ALU** vai fazer? A **ALU** vai calcular. Esse aqui mais esse aqui. Tem que calcular o endereço. Então. O **ALUSrc**. Tem que vir do banco de registradores. Ou do imediato. Banco de registradores do **RS2**. De novo pessoal. No **LOAD**. Esse aqui é o **RD**. Registrador de destino. Esse aqui é o **RS1**. Registrador de origem. Esse aqui é o imediato. O que eu tenho que fazer na instrução tipo **LOAD**? Eu tenho que somar o valor de **RS1**. Com o imediato. Então esse multiplexador aqui. Vai ter que ser setado como? O **RS1** está vindo aqui. Então. Eu tenho que colocar o imediato aqui. Então **ALUSrc**. Para que o imediato venha para cá. Possa somar com **RS1**. E aí obter o endereço. Certo? Que está aqui o endereço. Vindo para a memória. Entendido pessoal? **MemtoReg**. Esse multiplexador aqui. O que vai ser gravado no banco de registradores? Tem que vir da memória. Ou tem que vir. Tem que vir da memória. Ou tem que vir da **ALU**. Se a instrução é um **LOAD**. O que vai ser gravado no banco de registradores. É aquilo que veio da memória. Ou aquilo que a **ALU** calculou. Esse multiplexador aqui. 01. Que veio da memória. Então 1. Como assim que a **ALU** calculou? A **ALU** calculou e está vindo para cá. É o endereço. Não é um **LOAD**? Eu não tenho que ler da memória desse endereço aqui. E gravar no T0. Então. É 1 aqui. O que eu li da memória. É que eu tenho que gravar no banco de registradores. Então 1. A instrução **LOAD**. Grava no banco de registradores. A instrução **LOAD**. Grava no banco de registradores. Por isso que vocês têm que ter. A instrução na mente. O que a instrução **LOAD** faz? Carrega desse endereço da memória. E grava nesse registrador. Então ela grava no banco de registradores. Certo? Então **RegWrite** 1 também. Instrução **LOAD**. Ele lê da memória? Instrução **LOAD**. Lê da memória? Ah esse sim. Então **MemRead** igual a 1. Instrução **LOAD**. Escreve na memória? Não. Então **MemWrite** igual a 0. Instrução **LOAD**. É um **branch**? É um desvio condicional? Isso aqui? Isso aqui vale 0. E qual é a operação que a **ALU** tem que fazer? A **ALU** tem que fazer a soma desses dois. Então quanto que tem que valer o **ALUOp**? 0, 0. Para que a **ALU** faça uma soma. 0, 0. Certo? Já que a **ALU** vai ter que somar. Esse imediato com esse **RS1** aqui. Para dar o endereço. Próximo. **STORE**. Instrução **STORE**. Então para primeiro. **ALUSrc**. O segundo operando da **ALU**. Vem do banco de registradores ou do imediato? Se for um **STORE** agora. Agora esse aqui é um **STORE**. O segundo operando da **ALU**. Vem do banco de registradores? Do **RS2**? Ou do imediato? O que a **ALU** vai fazer aqui pessoal? Não vai pegar esse registrador. Somar com o imediato. Para dar o endereço da onde esse. T0 vai ser gravado? Então. Vamos lá. **RS1**. Imediato. **RS1**. Imediato. O que a **ALU** tem que fazer? Somar o **RS1** com o imediato. O **RS1** está vindo aqui. Logo. O que tem que vir aqui? O **RS2**? Ou o imediato? Então. **ALUSrc**. 01. Ok. O que vai ser escrito no banco de registradores? Vem da memória? Ou vem da saída da **ALU**? O que vai ser escrito no banco de registradores? Vem da memória? Ou vem da saída da **ALU**? Por que X Eduardo? Ah. Porque está escrito ali. Então vamos começar a pergunta de novo. O que vai ser escrito no banco de registradores? Vem da memória? Ou da saída da **ALU**? Vocês têm em mente qual é a instrução. A instrução é um **STORE**. **STORE**. Grava no banco de registradores? **STORE** grava no banco de registradores? Não. T0 é o mesmo ali. Qual é o problema? O que a instrução **STORE** faz? Eu quero gravar na memória. Nesse endereço. O conteúdo desse registrador. O conteúdo desse registrador. Respondam a pergunta. Instrução **STORE**. Grava no banco de registradores? Grava o que no banco de registradores? Vamos lá. O que ela grava no banco de registradores? A soma do que? Dessa soma aqui? Não. Você tem que entender o que a instrução **STORE** faz. **STORE WORD**. **STORE WORD**. Vai gravar na memória. O conteúdo. Desse registrador. Nesse endereço. Eu calculo o endereço. Mando para a memória. E nesse endereço da memória. É que eu vou gravar o conteúdo desse registrador. Então. Instrução **STORE**. Não grava no banco de registradores. Certo? Se ela não grava no banco de registradores. Tanto faz. O que vai ser colocado. Aqui na entrada. Certo? Então por isso que esse **MemtoReg** está com o X. Porque tanto faz eu escolher um ou zero aqui. Para botar aqui. Já que. Já que. **RegWrite** vai estar em zero. Certo? Instrução **STORE**. Não grava no banco de registradores. Então não interessa o que tenha na entrada aqui. Ela não vai gravar. Certo? Entendido isso? Entendido isso pessoal? Ok. Instrução **STORE**. **MemWrite** 1. Agora sim. Agora sim. Grava na memória. A instrução **STORE**. É um desvio condicional? É um **branch**? Não. Qual é a operação que a **ALU** tem que fazer? A **ALU** tem que fazer essa soma aqui. Logo. **ALUOp**. Temos que fazer essa soma. Próxima instrução, **BEQ**. Para a gente terminar. **BEQ**. Deixa eu escrever ela aqui. **BEQ**. P0, P1, imediato. Estou botando aqui imediato, porque o nosso gerador de imediato vai gerar aquilo que tem que ser somado com **PC**. Por isso que eu estou colocando aqui imediato. Porque ele vai ter que ir para esse endereço aqui, se for verdadeiro. **PC** mais o imediato. Então vamos lá. **BEQ**. O segundo operando da **ALU** tem que vir do banco de registradores ou do imediato? **BEQ**. O segundo operando tem que vir do banco de registradores ou do imediato? O que a **ALU** tem que... Quando pensar alguma coisa, o João pensa o oposto. O que a **ALU** tem que... A **ALU** tem que comparar esses dois registradores, que é o **RS1** e o **RS2**. Ela vai ter que fazer a subtração desses dois registradores. Logo, aqui vem o **RS1**. O que tem que ter aqui? O **RS2** ou o imediato? **RS2**. Logo, **ALUSrc**, zero. Eu tenho que colocar o valor de **RS2** para cá. Beleza. **MemtoReg**. O que vai ser gravado no banco de registradores pelo **BEQ**? O que vem da memória ou o que sai da **ALU**? O que vai ser gravado no banco de registradores pelo **BEQ**? Então vocês já pensam. **BEQ** grava no banco de registradores? **BEQ** grava no banco de registradores? Não. Então, tanto faz o que eu vou colocar aqui. Porque eu não vou escrever no banco de registradores. É esse zero aqui que permite eu colocar um X aqui. Eu não vou escrever no banco de registradores. Então, o que tem aqui na entrada, tanto faz. Eu não vou escrever. Ok. **BEQ**, lê da memória? Não. **BEQ**, escreve na memória? Não. **BEQ**, é um desvio condicional? É. Então, aqui vem um. E qual é a operação que a **ALU** tem que fazer no caso do **BEQ**? Ela tem que subtrair esses dois registradores. Logo, **ALUOp** 01. Eu quero que a **ALU** subtraia esses dois registradores. Certo? Estão aqui os dois registradores, eu quero que a **ALU** subtraia. Logo, **ALUOp** 01. Ok? Entenderam que a gente tem que entender o que o **software** está mandando fazer e configurar o caminho de dados. Para que ele faça essa tarefa. É assim que os processadores funcionam. Todos eles funcionam dessa maneira. Leem a instrução, decodificam a instrução e executam. Ok? Bom, vamos ficar por aqui hoje. Deixa eu ver o que mais que tem. Tem mais umas coisinhas aqui, mas que a gente vai ver na próxima aula. A próxima aula é laboratório, né? Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Mais importante dessa aula é vocês saberem montar essa tabela aqui. Então, o que que eu aconselho vocês a fazerem? Escondam esses números e preencham a tabela. E depois verifiquem se vocês acertaram. Se vocês erraram, entendam o que que vocês erraram. Certo? Entendido, pessoal? Revezem isso aqui. Vai poder visualizar o que eu tenho que fazer com o meu caminho de dados para executar essa instrução, para executar essa, para executar essa. Lembrem-se de responder a chamada no **SIGAA**, lá também, com a foto e no **Aprender3** ok? Então a gente se vê na quarta-feira, só deixa eu ver se é mesmo, é com o nosso laboratório, tá? Que eu vou terminar essa primeira parte, essa partezinha aqui, e a gente vê tudo no laboratório, beleza? Então ficamos por aqui hoje, desculpa aí pelos atrasos, pelas faltas, tá? Vou parar as gravações.",
        "video_source": "OAC_2022-03-21.mp4"
    },
    {
        "id": 11,
        "timestamp_start": 4913.96,
        "timestamp_end": 4916.79,
        "slide_description": "Como Engenheiro de Computação Sênior, analisei o slide apresentado, que corresponde a um plano de curso ou cronograma de uma disciplina de Arquitetura de Computadores, provavelmente ministrada pela Universidade de Brasília (inferido pelo rodapé parcialmente visível \"Universidade de Brasília\"). O documento é um arquivo Excel (`DACA_Plano_2021-2_v0.xlsx`), indicando ser um plano para o semestre 2021-2 da disciplina DACA (possivelmente \"Arquitetura e Computadores Digitais\" ou similar).\n\n**Conteúdo Transcrito e Descrito:**\n\nO slide apresenta uma tabela que detalha o cronograma e os tópicos de uma disciplina, juntamente com o esquema de avaliação. As colunas visíveis indicam datas ou semanas e os tópicos correspondentes.\n\n**Cronograma e Tópicos (Parcialmente Visíveis):**\n\n*   **Linha 4:** `14/2` `10/2` `8) Arit. Computacional: Inteiros (C.3)`\n    *   Este item aborda a Aritmética Computacional focada em números inteiros, provavelmente correspondendo ao Capítulo 3 de um material didático (C.3).\n*   **Linha 5:** `21/2` `23/2` `10) Arit. Computacional: Fracionários, IEEE 754 (C.3)`\n    *   Continuação da aritmética computacional, especificamente sobre números fracionários, com ênfase no padrão IEEE 754 para ponto flutuante, também relacionado ao Capítulo 3.\n*   **Linha 6:** `28/2` `2/3` `FERIADO`\n    *   Indica um período de recesso ou feriado.\n*   **Linha 7:** `7/3` `9/3` `Lab 1B: Software - Compilador C`\n    *   Primeiro laboratório visível, focado em aspectos de software, possivelmente na interação ou compreensão de como um compilador C opera ou interage com a arquitetura subjacente.\n\n**Tópicos Adicionais (Datas Não Visíveis, com Anotações de Teoria 'T_x', Capítulo 'C.x' e Laboratório 'L_x'):**\n\n*   `11) Outras Arquiteturas (T_x)`\n    *   Aborda diferentes tipos de arquiteturas de computadores, sendo uma aula teórica.\n*   `Lab 1A: Software - Rars (T_x)`\n    *   Um laboratório prático com o simulador Rars (MIPS RARS - SPIM), sugerindo programação em Assembly MIPS. A anotação `(T_x)` aqui pode ser um erro ou indicar que o laboratório tem um componente teórico forte.\n*   `Lab 2: Hardware – Verilog – ULA (T_x)`\n    *   Laboratório focado em hardware, utilizando a linguagem Verilog para projetar ou simular uma ULA (Unidade Lógica Aritmética), fundamental em processadores.\n*   `12) Processador Uniciclo: Unidade Operativa (C.4) (T_x)`\n    *   Tópico sobre processadores de ciclo único, cobrindo a unidade operativa, provavelmente do Capítulo 4, com uma aula teórica.\n*   `Lab 3: Processador Uniciclo (T_x) (L_x)`\n    *   Laboratório prático sobre o processador uniciclo, reforçando os conceitos teóricos com implementação ou simulação.\n*   `15) Processador Multiciclo: Unidade de Controle (C.4) (T_10)`\n    *   Discussão sobre processadores multiciclo, focando na unidade de controle, também do Capítulo 4, com aula teórica T_10.\n*   `16) Processador Pipeline: Conceitos (C.4) (T_11) (L_x)`\n    *   Aborda os conceitos de processadores com pipeline, uma técnica crucial para otimização de desempenho, relacionada ao Capítulo 4, com aulas teóricas (T_11) e atividades de laboratório.\n*   `Lab 5: Processador Pipeline (T_12)`\n    *   Laboratório específico sobre a implementação ou simulação de um processador pipeline.\n*   `19) Memória: Hierarquia (C.5) (T_13)`\n    *   Tópico essencial de Arquitetura de Computadores sobre a hierarquia de memória, abrangendo diferentes níveis de cache, memória principal, etc., do Capítulo 5, com aula teórica T_13.\n*   `2ª Prova (P2) (T_14) (L_x)`\n    *   Indica a segunda avaliação escrita (`P2`), possivelmente marcando o final de um bloco de conteúdo teórico (T_14) ou prático.\n*   `Apresentação dos Projetos (P_x) (T_15)`\n    *   Período destinado à apresentação dos projetos da disciplina, com a aula teórica T_15.\n\n**Seção de Avaliação (Avaliação):**\n\n*   `P_1: 1ª Prova: 14/03/2022`\n    *   Primeira prova agendada para 14 de março de 2022.\n*   `P_2: 2ª Prova: 27/04/2022`\n    *   Segunda prova agendada para 27 de abril de 2022.\n*   `Prova Substitutiva: 02/05/2022`\n    *   Prova de recuperação/substituição agendada para 02 de maio de 2022.\n*   `É optativa e pode substituir qualquer uma das notas P_x`\n    *   A prova substitutiva é opcional e pode ser usada para substituir a nota de P1 ou P2, conforme a necessidade do aluno.\n\nEste slide fornece um panorama completo do conteúdo programático da disciplina, cobrindo desde aritmética computacional e descrição de hardware (Verilog para ULA), passando por diferentes modelos de processadores (uniciclo, multiciclo, pipeline) até a hierarquia de memória. Há um balanço claro entre teoria (indicado por `T_x` e `C.x`) e prática (indicado por `Lab` e `L_x`, com menção a Rars e Verilog), além de um cronograma de avaliações bem definido.",
        "transcription": "Ah, mas tem",
        "video_source": "OAC_2022-03-21.mp4"
    },
    {
        "id": 12,
        "timestamp_start": 4916.79,
        "timestamp_end": 4943.59,
        "slide_description": "Como um Engenheiro de Computação Sênior, analisei o slide apresentado, que corresponde a um plano de curso ou ementa detalhada para uma disciplina de Arquitetura de Computadores. A imagem central exibe um documento de texto, presumivelmente um arquivo Microsoft Word, intitulado \"OAC_A_Plano_2021-2_V0.docx\", exibido na \"Sala de Aula de OAC\" (Organização e Arquitetura de Computadores). O documento inclui referências à \"Universidade de Brasília\", \"Departamento de Ciência da Computação\", \"CIC0009 - Organização e Arquitetura de Computadores\" e ao \"Prof. Marcus Vinícius Lamar\".\n\nO conteúdo principal é uma tabela que descreve a progressão do curso em termos de semanas/aulas, datas e tópicos. As colunas, embora sem cabeçalhos explícitos visíveis, podem ser inferidas como: (1) Número da Aula/Semana, (2) Data (formato DD/MM), (3) Segunda Data (formato DD/MM), (4) Tópico Principal/Atividade, e (5) Tópico Relacionado/Laboratório/Teoria.\n\n**Conteúdo da Tabela:**\n\n*   **Semana 4 (14/2 - 10/2):** Tópicos sobre Aritmética Computacional de Inteiros (C.3), complementado por Outras Arquiteturas (T5).\n*   **Semana 5 (21/2 - 23/2):** Continuação da Aritmética Computacional com foco em Fracionários, especificamente o padrão IEEE 754 (C.3), acompanhado pelo Lab 1A: Software - Rars (T6).\n*   **Semana 6 (28/2 - 2/3):** Registrado como FERIADO, sem tópicos específicos.\n*   **Semana 7 (7/3 - 9/3):** Lab 1B: Software - Compilador C, com Lab 2: Hardware - Verilog - ULA (T7). Este último indica a introdução à descrição de hardware usando Verilog para a Unidade Lógica Aritmética.\n*   **Semana 8 (14/3 - 16/3):** Realização da 1ª Prova (P1).\n*   **Semana 9 (21/3 - 23/3):** Introdução ao Processador Uniciclo, abordando a Unidade de Controle (C.4) (L1), e a Unidade Operativa (C.4) (T8). O Lab 3: Processador Uniciclo (T9) (L2) é listado em paralelo.\n*   **Semana 10 (28/3 - 30/3):** Foco no Processador Multiciclo, especificamente a Unidade Operativa (C.4), complementado pela Unidade de Controle (C.4) (T10).\n*   **Semana 11 (4/4 - 6/4):** Lab 4: Processador Multiciclo.\n*   **Semana 12 (11/4 - 13/4):** Exploração de Pipeline, cobrindo a Unidade Operativa e Controle (C.4), e os Conceitos de Pipeline (C.4) (T11) (L3).\n*   **Semana 13 (18/4 - 20/4):** Detalhamento de Exceção e Interrupção (C.4) (L4), com Lab 5: Processador Pipeline (T12).\n*   **Semana 14 (25/4 - 27/4):** Tópico 19.1: Memória Cache (C.5), e Hierarquia de Memória (C.5) (T13).\n*   **Semana 15 (2/5 - 4/5):** Realização da Prova Substitutiva, e a 2ª Prova (P2) (T14) (L5).\n*   **Semana 16 (invisível - 4/5):** Apresentação dos Projetos (P_L) (T15).\n\n**Seção de Avaliação:**\nA avaliação do curso consiste em:\n*   P1: 1ª Prova: 14/03/2022\n*   P2: 2ª Prova: 27/04/2022\n*   Prova Substitutiva: 02/05/2022\nÉ explicitamente mencionado que a Prova Substitutiva \"É optativa e pode substituir qualquer uma das notas P\".\n\n**Conteúdo do Chat (Bate-papo público):**\nParalelamente ao slide, há um chat de aula com mensagens de alunos e possivelmente o professor. As mensagens visíveis incluem: \"isso\", \"n\", \"imm\", \"não\", \"rs2\", \"Não.\", \"n\", \"s\", \"sí\", \"s\", \"obg!\". Esses termos parecem ser respostas curtas a perguntas feitas durante a aula, com \"imm\" e \"rs2\" possivelmente referindo-se a instruções MIPS ou registradores.\n\n**Lista de Usuários:**\nA lista de 14 usuários online inclui \"Marcus Vinicius Lamar (Você)\" (provavelmente o professor), \"Luiz Carlos Da Silva Neto Vartuli\", \"Bruno Vargas de Souza\", \"Eduardo Ferreira Marques Caval...\", \"Felipe Dantas Borges\", \"Gustavo Rodrigues Da Costa\", \"Harisson Freitas Magalhaes\", \"Henrique De Miranda Camarg\", \"João Alberto Travassos Evangeli...\", e \"Matheus Virgílio Da Silva Ferreira\".\n\n**Análise Estrutural e Fluxo de Dados (Diagramas):**\nÉ importante notar que o slide **não apresenta diagramas** de datapath, pipeline, ou hierarquia de memória. O conteúdo é predominantemente textual, descrevendo o cronograma e os tópicos programáticos do curso. Os conceitos de \"Processador Uniciclo\", \"Processador Multiciclo\", \"Pipeline\" e \"Hierarquia de Memória\" são listados como tópicos de estudo, indicando que diagramas relacionados a esses conceitos seriam discutidos nas respectivas aulas.\n\nEm suma, o slide fornece uma visão clara do plano pedagógico da disciplina de Arquitetura de Computadores, detalhando os conceitos fundamentais desde a aritmética computacional até processadores (uniciclo, multiciclo, pipeline), exceções/interrupções e hierarquia de memória, com o uso de Verilog e o simulador Rars como ferramentas práticas.",
        "transcription": "Para dar aquela checada na Prova 1? Não, ainda nem olhei. Foi segunda-feira, não, foi segunda-feira passada, semana passada toda eu fiquei em recuperação, hoje que eu estou um pouco melhor. Que achei que o senhor já tinha, né? Ainda não, tá? Mas eu vou dar uma olhada, não se preocupe. Ah, e eu tenho uma prova aqui, na quarta-feira, que você estava no pagode. Deixa eu pegar aqui.",
        "video_source": "OAC_2022-03-21.mp4"
    }
]