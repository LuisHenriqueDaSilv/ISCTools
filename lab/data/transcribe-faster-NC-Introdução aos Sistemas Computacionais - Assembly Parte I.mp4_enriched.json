[
    {
        "id": 1,
        "timestamp_start": 2.58,
        "timestamp_end": 84.58,
        "slide_description": "O slide apresenta o título \"Linguagem Assembly RISC-V\" e faz parte de uma aula identificada na barra superior como \"UnB/CIC 113468 - Introdução aos Sistemas Computacionais\". O conteúdo principal é textual, descrevendo as características fundamentais da linguagem Assembly, especificamente no contexto da arquitetura de conjunto de instruções (ISA) RISC-V.\n\nO primeiro ponto principal afirma que a **Linguagem Assembly é a linguagem de programação mais básica de um processador**, detalhando suas propriedades essenciais através de uma lista de sub-itens:\n*   É **baseada na execução sequencial de instruções**, o que implica um fluxo de controle linear, a menos que seja explicitamente alterado.\n*   Utiliza **desvios explícitos a endereços na memória**, o que significa que saltos e chamadas de sub-rotinas são controlados diretamente por endereços físicos ou relativos, não por rótulos abstratos como em linguagens de alto nível.\n*   Possui **sintaxe rígida**, indicando que a estrutura das instruções e operandos é estritamente definida e menos flexível que linguagens de programação modernas.\n*   Não possui o conceito de **variáveis ou tipos** como em linguagens de alto nível; a manipulação de dados é feita diretamente em registradores e posições de memória, sem verificação de tipo em tempo de compilação ou execução.\n*   Carece de **estruturas de controle elaboradas**, como `if/else`, `for`, `while` ou `switch` nativas; estas devem ser implementadas manualmente usando instruções de desvio condicional e incondicional.\n*   Não oferece **chamadas automáticas a funções ou procedimentos**; a gerência da pilha para passagem de argumentos e retorno de valores, bem como o salvamento de contexto (registradores), é responsabilidade do programador ou do compilador que gera o assembly.\n*   Não dispõe de **bibliotecas** pré-definidas ou linkáveis automaticamente, como em C/C++ ou Java; qualquer funcionalidade complexa deve ser implementada do zero ou ser parte de um conjunto de rotinas pré-compiladas (firmware, sistema operacional).\n\nO segundo ponto principal instrui os alunos a **\"Vide manual do RISC-V para o conjunto completo de instruções e detalhes de implementação\"**, sugerindo que o manual oficial da arquitetura é a fonte primária para a especificação detalhada do ISA e sua microarquitetura.\n\nNão há diagramas de datapath, pipeline ou hierarquia de memória visíveis neste slide; o conteúdo é inteiramente conceitual e textual. O número \"3\" no canto inferior direito indica o número da página do slide.",
        "transcription": "Bom pessoal, então, continuando as nossas aulas sobre Assembly e RISC-V, vamos entrar um pouquinho mais nas instruções específicas do Assembly RISC-V. Então, só lembrando, a linguagem Assembly é a mais básica, cada processador tem o seu próprio Assembly e a sua própria linguagem de máquina. E aí é uma linguagem extremamente básica, quer dizer, é baseada na execução sequencial de instruções. Então, dada uma instrução, ele vai executar em seguida a que vem seguinte, depois seguinte, depois seguinte, sequencial. Os desvios para outras partes do programa são feitos explicitamente para endereços, para onde eu preciso saltar, para onde o processador vai executar. A sintaxe é rígida, o montador exige que seja escrito o programa de certa maneira. Não tem variáveis, não tem tipos, não tem estruturas de comando elaboradas como `for`, `while`, nada disso, nem `if`, `then`, `else`. Sem chamadas automáticas a funções, procedimentos, sem bibliotecas, a menos que aquelas que o sistema operacional forneça. Então, o uso de bibliotecas é mínimo. E nós vamos passar, então, pelas principais instruções.",
        "video_source": "Introdução aos Sistemas Computacionais - Assembly Parte I.mp4"
    },
    {
        "id": 2,
        "timestamp_start": 84.58,
        "timestamp_end": 104.58,
        "slide_description": "O slide apresenta conceitos fundamentais da linguagem Assembly para a arquitetura RISC-V na sua variante RV32I (32-bit Integer). O título principal \"Assembly RV32I\" estabelece o escopo.\n\nNo cabeçalho superior direito, há a identificação da disciplina: \"UnB/CIC 113468 - Introdução aos Sistemas Computacionais\", indicando o contexto acadêmico da Universidade de Brasília.\n\nO conteúdo central do slide foca em \"Instruções Aritméticas: + -\", especificando as operações de adição e subtração. Uma observação crucial é fornecida: \"Obs.: Imm é um número de 12 bits em complemento de 2 com extensão de sinal\". Esta nota técnica detalha o tratamento de valores imediatos (constantes) no conjunto de instruções RISC-V, indicando que, embora codificados em 12 bits, eles são interpretados como valores sign-extended, permitindo representar tanto números positivos quanto negativos.\n\nAs instruções de Assembly são apresentadas com seus respectivos pseudocódigos em notação de alto nível para clareza:\n1.  `add t0, t1, t2`: Esta instrução realiza a adição do conteúdo dos registradores `t1` e `t2`, armazenando o resultado no registrador `t0`. O equivalente em pseudocódigo é `# t0 = t1 + t2`.\n2.  `sub t0, t1, t2`: Esta instrução executa a subtração do conteúdo do registrador `t2` do conteúdo do registrador `t1`, com o resultado sendo armazenado em `t0`. O equivalente é `# t0 = t1 - t2`.\n3.  `addi t0, t1, Imm`: Esta instrução é uma adição imediata, onde o conteúdo do registrador `t1` é somado a um valor imediato (`Imm`). Conforme a observação anterior, o valor `Imm` passa por um processo de extensão de sinal (`ExtensãoSinal{Imm}`) antes da adição. O resultado é então armazenado no registrador `t0`. O equivalente é `# t0 = t1 + ExtensãoSinal{Imm}`.\n\nOs registradores `t0`, `t1`, `t2` são tipicamente registradores temporários (`t` para temporary) na convenção de chamada de funções RISC-V.\n\nNão há diagramas de datapath, pipeline ou hierarquia de memória visíveis neste slide; o conteúdo é puramente textual, definindo a sintaxe e a semântica de instruções aritméticas básicas do RISC-V RV32I, com ênfase no manuseio de operandos imediatos. O número da página \"6\" é visível no canto inferior direito.",
        "transcription": "Então, começamos com as instruções aritméticas de soma e subtração. Tem também multiplicação e divisão, que a gente vai ver no final desse vídeo. Então, considerando que o imediato é um número de 12 bits em complemento de 2, a gente tem, então, as seguintes três instruções: add t0, t1, t2.",
        "video_source": "Introdução aos Sistemas Computacionais - Assembly Parte I.mp4"
    },
    {
        "id": 3,
        "timestamp_start": 104.58,
        "timestamp_end": 1307.65,
        "slide_description": "Como um Engenheiro de Computação Sênior, analiso o slide apresentado como parte de uma aula de Arquitetura de Computadores, especificamente sobre Assembly RISC-V RV32I. O conteúdo visual é predominantemente textual, não havendo diagramas de datapath, pipeline ou hierarquia de memória.\n\n**Título e Contexto Geral:**\nO slide é intitulado \"Assembly RV32I\", indicando seu foco em instruções assembly para a arquitetura RISC-V na sua variante de 32 bits com conjunto de instruções inteiras padrão (RV32I). No canto superior direito, há uma anotação de cabeçalho: \"UnB/CIC 113468 - Introdução aos Sistemas Computacionais\", contextualizando a aula como parte da disciplina de Introdução aos Sistemas Computacionais da Universidade de Brasília, Código CIC 113468. O número \"9\" no canto inferior direito sugere que este é o nono slide da apresentação.\n\n**Conteúdo Textual - Instruções Diversas:**\nA primeira seção do slide é intitulada \"Instruções diversas\" e detalha duas instruções para manipulação de imediatos (valores constantes) e o Program Counter (PC):\n1.  **Load Upper Immediate (lui):**\n    *   Sintaxe: `lui t0,Imm`\n    *   Operação: `# t0 = Imm<<12`\n    *   Esta instrução carrega o valor imediato (`Imm`) nos 20 bits mais significativos do registrador `t0`, preenchendo os 12 bits menos significativos com zeros. É comumente usada para construir constantes de 32 bits em conjunto com instruções de tipo I, ou para acessar endereços arbitrários na memória.\n2.  **Add upper Immediate to PC (auipc):**\n    *   Sintaxe: `auipc t0,Imm`\n    *   Operação: `# t0 = PC + Imm<<12`\n    *   Esta instrução adiciona o valor imediato (`Imm`), deslocado 12 bits para a esquerda, ao valor atual do Program Counter (PC), armazenando o resultado no registrador `t0`. É fundamental para a geração de endereços relativos ao PC, permitindo código independente de posição.\n\n**Conteúdo Textual - Instruções de Comparação:**\nA segunda seção do slide, intitulada \"Instruções de Comparação\", lista quatro instruções que realizam comparações e definem um registrador com base no resultado:\n1.  **Set on Less Than (slt):**\n    *   Sintaxe: `slt t0,t1,t2`\n    *   Operação: `# t1<t2 ? t0=1 : t0=0`\n    *   Esta instrução compara os valores nos registradores `t1` e `t2` como números inteiros com sinal. Se `t1` for menor que `t2`, o registrador de destino `t0` é definido como 1; caso contrário, `t0` é definido como 0.\n2.  **Set on Less Than Unsigned (sltu):**\n    *   Sintaxe: `sltu t0,t1,t2`\n    *   Operação: `# t1<t2 ? t0=1 : t0=0 argumentos sem sinal`\n    *   Similar ao `slt`, mas a comparação entre `t1` e `t2` é realizada considerando-os como números inteiros sem sinal.\n3.  **Set on Less Than Immediate (slti):**\n    *   Sintaxe: `slti t0,t1,Imm`\n    *   Operação: `# t1<Imm ? t0=1 : t0=0`\n    *   Esta instrução compara o valor no registrador `t1` com o valor imediato `Imm` como números inteiros com sinal. Se `t1` for menor que `Imm`, `t0` é definido como 1; caso contrário, `t0` é definido como 0.\n4.  **Set on Less Than Immediate Unsigned (sltiu):**\n    *   Sintaxe: `sltiu t0,t1,Imm`\n    *   Operação: `# t1<Imm ? t0=1 : t0=0 argumentos sem sinal`\n    *   Similar ao `slti`, mas a comparação entre `t1` e `Imm` é realizada considerando-os como números inteiros sem sinal.\n\n**Resumo da Informação para RAG:**\nO slide descreve instruções fundamentais do conjunto RISC-V RV32I para operações de carregamento de imediatos em registradores (`lui`), operações de endereço relativo ao PC (`auipc`) e uma família de instruções de comparação (`slt`, `sltu`, `slti`, `sltiu`) que definem um registrador com base no resultado da comparação (menor que), suportando tanto operandos com e sem sinal, e imediatos. Este material é crucial para entender a manipulação de constantes, endereçamento de memória e controle de fluxo condicional em Assembly RISC-V.",
        "transcription": "Então, `ADD t0, t1, t2`. Ele vai fazer a soma do conteúdo do registrador `t1` com o conteúdo do registrador `t2`, e colocar, então, esse resultado no registrador `t0`. Da mesma maneira, `SUB t0, t1, t2` vai fazer `t1` menos `t2`, colocando o resultado em `t0`. Aqui está essa explicação, só que com um hashtag na frente, que significa que é comentário em Assembly. `ADDI t0, t1, imediato`. Então, ele vai somar ao conteúdo do registrador `t1` esse número imediato de 12 bits, em complemento de 2. Como `t1` é um registrador que armazena 32 bits, e aqui, no imediato, são 12 bits, eu preciso fazer a extensão do sinal do imediato para que ele tenha também 32 bits, para poder efetuar essa soma, e o resultado, então, armazenar em `t0`. Então, `ADDI` significa \"ADD IMMEDIATE\". Outras instruções importantes para nós são as instruções lógicas. No RISC-V, as instruções lógicas sempre são _bitwise_, quer dizer, são feitas bit a bit. Então, nós temos somente essas três instruções lógicas que são as funções `AND`, `OR` e `XOR`. Então, `AND s3, s1, s2` significa que eu vou pegar, dado esse valor de `s1` e esse valor de `s2`, eu vou fazer o `AND` bit a bit para gerar, então, o resultado que vai ser gravado no registrador `s3`. Da mesma maneira, `OR s4, s1, s2` ele vai fazer o `OR` bit a bit desses dois para armazenar, então, no registrador `s4`. E `XOR s5, s1, s2` vai fazer o _exclusive OR_ bit a bit para gerar, então, o resultado que vai ser gravado em `s5`. Da mesma maneira que a gente tem essas instruções que funcionam com dois registradores, a gente tem as instruções similares que funcionam com números imediatos, quer dizer, o `ANDI`, o `ORI` e o `XORI`. Então, nesse caso, eu vou pegar o conteúdo de `s1`, fazer um `AND` com esse número `0xA34`, estendido para 32 bits, quer dizer, esse número imediato. Então, o que eu vou fazer é esse que está mostrado aqui. Então, significa `0xA34`. E como o último bit aqui é 1, eu vou ter a extensão do sinal até completar 32 bits. E vai ser feita uma operação lógica entre esses dois argumentos: o conteúdo do registrador `s1` e esse número imediato estendido para 32 bits. Dessa maneira, além das instruções lógicas, a gente tem as instruções de deslocamento de bits. Quer dizer, dado que `s1` é esse número aqui de 32 bits, e no registrador `s2` eu tenho esse número, que em binário é simplesmente 8. Então a instrução `SLL`, _Shift Left Logical_, então deslocamento lógico à esquerda. Eu vou pegar o conteúdo de `s1`, deslocar 8 bits para a esquerda. Acrescentando então 8 zeros aqui no início. E aí esse resultado eu vou colocar então no registrador `s3`. Eu posso ter o deslocamento para a direita, _Shift Right Logical_, então deslocamento lógico para a direita. Nesse caso, o valor de `s1` vai ser deslocado 8 bits para a direita. Então, vão ser inseridos, aqui, zeros. E o registrador `s1` então é deslocado e o resultado é armazenado no registrador `s0`. E eu posso ter o _Shift Aritmético_, então _Shift Right Aritmético_. Significa deslocamento aritmético à direita. Nesse caso, ao invés de acrescentar zeros, eu vou fazer a réplica do bit de sinal. Quer dizer, extensão, como se fosse uma extensão de sinal. Então, se o bit mais significativo aqui é 1, eu vou acrescentar 1 à esquerda e fazendo o deslocamento da mesma maneira. Com isso, então, o _Shift Left_ corresponde à multiplicação por 2, e o _Shift Right Aritmético_ à divisão por 2. OK. Eu posso ter o equivalente dessas instruções utilizando números imediatos. Então, `SLLI` (_Shift Left Logical Immediate_), `SRLI` (_Shift Right Logical Immediate_) e `SRAI` (_Shift Right Aritmético Immediate_), onde aqui agora eu explicito numericamente quantos bits devem ser deslocados para a esquerda, para a direita, ou à direita de modo aritmético, quer dizer, através da replicação do bit de sinal. Outras instruções que também são muito importantes são as instruções de acesso à memória. As instruções de acesso à memória para leitura, como nós já vimos, são o `LW` (_Load Word_) e o `SW` (_Store Word_). Se eu quiser ter um `LW t0, imediato(t1)`, eu vou ler da memória esse número de 32 bits e armazenar no registrador `t0`. Se eu quero armazenar um número de 32 bits na memória, então eu vou fazer o `SW` (_Store Word_), que seria armazenar na memória, dado por esse endereço `t1 + imediato`, o conteúdo do registrador `t0`. Da mesma maneira, se eu quiser trabalhar com _Half Word_ e com _Byte_, vou usar o `LH` (_Load Half Word_) `t0, imediato(t1)`. Então eu vou ler desse endereço 16 bits e colocar em `t0`. O `LH` ele considera que o número que eu li da memória é um número com sinal. Então, já que eu li 16 bits da memória e para o registrador `t0`, nosso registrador tem 32 bits, se eu estou lendo um número com sinal, eu preciso fazer a extensão do sinal, quer dizer, transformar esse número de 16 bits que eu li da memória em 32 para colocar no registrador `t0`. No entanto, eu posso considerar que o número que eu li da memória seja sem sinal. Então, nesse caso não faz sentido ter extensão de sinal. Então eu vou usar a instrução `LHU` (_Load Half Word Unsigned_), que ele vai ler desse endereço um número de 16 bits e vai colocar nesse registrador `t0` com os bits mais significativos, quer dizer, o valor sem sinal do número de 16 bits continua o mesmo com o valor sem sinal do registrador `t0` de 32 bits. Para escrever na memória, eu só tenho uma instrução de `SH` (_Store Half Word_). Então, vou armazenar nesse endereço `imediato + t1` o valor do registrador `t0`. Da mesma maneira, eu posso ter `LB` (_Load Byte_), que eu vou ler um byte da memória desse endereço. Porque o byte é lido como um número com sinal, então para eu colocar no registrador `t0` eu preciso estender o sinal desses 8 bits que eu li da memória para que eu tenha o mesmo número em 32 bits. Ou então, eu vou considerar que o byte que eu li da memória seja um número sem sinal, então eu vou usar `LBU` (_Load Byte Unsigned_), que ele vai ler os 8 bits da memória desse endereço e colocar os 24 bits mais significativos como sendo 0, de modo que o número em 32 bits correspondente seja aquele número de 8 bits que eu li da memória como sendo sem sinal. E para armazenar um byte na memória, o byte menos significativo do registrador `t0`, então eu vou usar o `SB` (_Store Byte_), que vai armazenar nesse endereço os 8 bits menos significativos do registrador `t0`. Então o `t0` de 0 a 7 que vai ser gravado nesse endereço. E depois, algumas instruções que são bastante úteis, mas que não é nem aritmético, nem lógico, nem de deslocamento e nem de _load store_, são as instruções _Load Upper_. Então, _Load Upper Immediate_, então a instrução `LUI`, que recebe como argumento o registrador `t0` e o número imediato. Então essa instrução, o imediato aqui é de 20 bits. Nesse caso, o registrador `t0`, no caso da instrução `LUI`, ele vai colocar esses 20 bits nos 20 bits mais significativos, colocando zeros nos 12 bits menos significativos. Então, coloca esse número imediato na parte mais significativa do registrador `t0`. Uma outra maneira de se fazer a colocação de números no registrador pode ser o `AUIPC` (_Add Upper Immediate to PC_), que significa, com os argumentos `t0` e imediato, o número de 20 bits. Então, nesse caso, o registrador `t0` vai ser atribuído o valor do imediato deslocado para os 20 bits mais significativos, uma palavra de 32 bits. E a esse número, eu vou somar o registrador `PC`, que é o _Program Counter_, que mantém o endereço da instrução que está sendo lida da memória, que está sendo executada, e que vai ser gravado no registrador `t0`. Nós temos uma única instrução de comparação na ISA RISC-V, que é a instrução `SLT` (_Set on Less Than_). Essa instrução, ela compara os valores do registrador `t1` e `t2`. Se `t1` for menor que `t2`, `t0` recebe o valor 1. Caso contrário, `t0` recebe o valor 0. Então, a gente tem somente essa comparação. E como o resultado da comparação depende se os números são tomados com sinal ou sem sinal, e quem sabe se o número é com sinal ou sem sinal é só o programador, a ISA tem que permitir, então, que eu faça essa comparação considerando os números sem sinal. Então, eu tenho a instrução `SLTU` (de _Unsigned_). Então, ele vai fazer a comparação dos números armazenados em `t1` e `t2`, esses dois números como sem sinal. Então, se `t1` for menor que `t2` sem sinal, `t0` recebe 1. Caso contrário, `t0` recebe 0. Da mesma maneira que eu posso comparar dois registradores, eu posso comparar um registrador a um número imediato. Então, eu tenho as instruções `SLTI`. Então, se `t1` for menor que esse número imediato, `t0` recebe 1. Caso contrário, `t0` recebe 0. E eu posso ter o `SLTIU` (_SLTI Unsigned_), considerando que `t1` é um número sem sinal. Então, nesse caso, se `t1` for menor que esse número imediato, `t0` recebe 1. Caso contrário, `t0` recebe 0. Então, essa é a única instrução de comparação que a ISA RISC-V disponibiliza. Todas as outras comparações que forem necessárias têm que ser feitas utilizando essa instrução `SLT`. Mas, geralmente, o nosso programa ele é sequencial, quer dizer, é executado uma instrução, depois a instrução seguinte, e assim por diante. Mas, às vezes, a gente precisa que o programa pare a sua execução e comece a executar uma rotina, uma função, uma sub-rotina, um procedimento que está em outra posição de memória. Então, para isso, nós vamos precisar de instruções de saltos incondicionais e saltos condicionais. Então, a instrução de salto faz com que o processador passe a executar um salto dado por _label_. Então, o _label_ para nós é um endereço de 32 bits. Então, as duas instruções de salto incondicionais são o `JAL` (_Jump and Link_) `t0, label`. Então, o que essa instrução `JAL` faz? _Jump_ ele salta. Significa que a próxima instrução deve vir desse endereço _label_. Então, para fazer isso, é feito que: carregado esse endereço _label_ no registrador `PC`. A próxima instrução a ser buscada vai ser obtida desse endereço _label_. E a função _and Link_ significa que eu vou armazenar nesse registrador `t0` o endereço da próxima instrução seguinte ao `JAL`. Então, se o `JAL` está no endereço dado por `PC`, a próxima instrução vai estar no endereço `PC + 4`. Então, esse endereço `PC + 4` vai estar no registrador `t0`, de modo que eu tenha armazenado o endereço para onde eu devo retornar depois que eu acabei o procedimento. Então, o programa principal chama o procedimento, esse procedimento é executado e depois ele retorna ao programa principal. Ele retorna para esse endereço `PC + 4` que está armazenado nesse registrador `t0`, que foi armazenado previamente nesse registrador `t0`. OK. No mesmo modo que a gente pode definir um _label_, agora eu preciso ser capaz de pular para o endereço que está em um registrador. Para isso, nós vamos utilizar então a instrução `JALR` (_Jump and Link Register_). Então, essa instrução vai _and Link_, vai salvar no registrador `t0` o valor de `PC + 4`. E vai saltar. A próxima instrução a ser buscada vai ser dada no endereço dado pelo conteúdo de `t1` mais o imediato, tendo o último bit zerado. Então, isso é por definição da ISA RISC-V. Então, eu vou pular para o endereço dado por `t1` mais o imediato. Se esse imediato for 0, então o endereço que eu vou voltar é o endereço que estiver em `t1`, que geralmente vai ser esse endereço de retorno aqui que foi salvo previamente. Então, essas duas são as duas únicas instruções com saltos incondicionais. Porém, uma das coisas mais úteis em termos de linguagem Assembly é fazermos saltos condicionais, que vai nos possibilitar fazer as instruções _if then else_. Então, para saltos condicionais, a ISA RISC-V tem essas 6 instruções. Então, a instrução `BEQ` (_Branch if Equal_). _Branch_ significa um salto condicional. _Jump_ aqui significa salto incondicional. _Branch if Equal_. Então, a gente vai verificar se o conteúdo de `t0` é igual a `t1`. Se o conteúdo de `t0` for igual ao conteúdo de `t1`, ele vai saltar para esse _label_, para esse endereço definido por esse _label_. Então, se `t0` for igual a `t1`, ele faz `PC = label`. Caso contrário, se essa condição for _false_, ele continua executando a próxima instrução, `PC + 4`, para que passe a executar a próxima instrução. Então, da mesma maneira que a gente tem `BEQ`, a gente tem `BNE` (_Branch if Not Equal_), que ele faz justamente o contrário. Se `t0` for diferente de `t1`, ele salta. Caso contrário, ele continua. Eu posso fazer comparações aqui também: `BGE` (_Branch if Greater or Equal_). Então, vai saltar se for maior ou igual. Quer dizer, se `t0` é maior ou igual a `t1`, se for, ele pula para o _label_. Se não, ele continua a execução. E como aqui a gente tem uma comparação, eu preciso saber se essa comparação vai ser feita com números com sinal ou sem sinal. E quem decide isso é o programador. Então, a gente tem as comparações considerando _unsigned_. Então, `BGEU` (_Branch if Greater or Equal Unsigned_). Então, vai considerar que os dois números armazenados em `t0` e `t1` são sem sinal. E se `t0` for maior ou igual a `t1`, ele pula para o _label_. Caso contrário, ele continua. Nós temos, da mesma maneira que a gente tem o maior ou igual, a gente tem o menor que. Então, `BLT` (_Branch if Less Than_). Então, se `t0` for menor que `t1`, ele pula para o _label_. E, considerando os dois números sem sinal, `BLTU` (_Branch if Less Than Unsigned_). Então, ele verifica se `t0` é menor que `t1`, considerando sem sinal. Se for, ele pula para o _label_. Caso contrário, ele executa a próxima instrução. Com isso, a gente finaliza os saltos condicionais e incondicionais. Para completar as operações aritméticas, faltam as instruções de multiplicação e divisão. Essas instruções de multiplicação e divisão são opcionais. É um módulo à parte que não faz parte da ISA básica do RISC-V, que seria RV32I. Então, quando eu tenho um módulo de multiplicação e divisão, a gente diz que a gente está usando a ISA RV32IM. Então, as instruções básicas de inteiro, mais ainda as instruções de multiplicação e divisão em módulo. Então, como a multiplicação de dois números de 32 bits o resultado é um número de 64 bits, nós vamos precisar armazenar isso em dois registradores. Então, nós temos as seguintes instruções. Que faz a multiplicação de `t1` com `t2`, dá um resultado de 64 bits. Os 32 bits menos significativos são, então, armazenados em `t0` através dessa instrução `MUL`. Se eu quero os 32 bits mais significativos, aí faz diferença se os números são considerados com sinal ou sem sinal, que a parte mais significativa depende se o número é com sinal ou sem sinal. Então, se eu considerar os números `t1` e `t2` com sinal, eu vou usar a instrução `MULH`. Então, eu vou multiplicar `t1` por `t2` e vou pegar os 32 bits mais significativos e armazenar em `t0`. Se eu considerar que `t1` e `t2` são números sem sinal, eu vou usar, então, `MULHU` (_MULH Unsigned_), que vai fazer a multiplicação dos dois e também vai armazenar no `t0` os 32 bits mais significativos. Mas, considerando que `t1` e `t2` são números sem sinal. Da mesma maneira, para fazer a divisão, eu tenho o quociente. A divisão inteira, ela resulta em quociente e resto. Então, eu tenho a instrução para que calcula o quociente. Então, a instrução `DIV` faz `t1` dividido por `t2`, divisão inteira, e o quociente é armazenado em `t0`. Isso eu, para achar o resto, a gente usa a instrução `REM`, que é `t1`, o resto da divisão de `t1` por `t2`. E esse resto é armazenado em `t0`. Como a divisão também depende se os números são com sinal ou sem sinal, eu tenho os equivalentes considerando os números `t1` e `t2` sem sinal. Então, `DIVU` (_DIV Unsigned_) faz a divisão inteira de `t1` com `t2`, considerando os dois números sem sinal, colocando o quociente em `t0`. E `REMU` (_REM Unsigned_), que significa fazer o módulo da divisão de `t1` por `t2`, o resto da divisão, colocando esse resto, então, em `t0` também. Com isso, a gente finaliza a ISA básica da RV32IM.",
        "video_source": "Introdução aos Sistemas Computacionais - Assembly Parte I.mp4"
    }
]