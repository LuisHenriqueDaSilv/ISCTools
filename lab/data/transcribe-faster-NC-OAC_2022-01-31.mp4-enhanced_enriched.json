[
    {
        "id": 1,
        "timestamp_start": 0.0,
        "timestamp_end": 33.74,
        "slide_description": "Como Engenheiro de Computação Sênior, analiso o slide e o conteúdo anotado, identificando informações cruciais para um sistema de busca semântica (RAG).\n\nO contexto visual é uma sala de aula online, provavelmente de um curso universitário, com um painel de chat à esquerda e o conteúdo principal de um documento de aula à direita.\n\n**No painel de comunicação (lado esquerdo):**\nA seção \"MENSAGENS\" mostra duas categorias: \"Perguntas\" e \"Bate-papo público\", com esta última selecionada. No bate-papo, há uma mensagem de boas-vindas: \"Bem vindos à sala de aula de OAC! Esta sessão está sendo gravada. Para mais informações, clique aqui. Novo na plataforma? Experimente o tour!\". Abaixo, mensagens de usuários: \"Ualiton Ventura ... 13:55 boa tarde professor\" e \"Arthur Souza Cor... 13:57 boa tarde\".\nA seção \"NOTAS\" indica \"Notas compartilha...\".\nA seção \"USUÁRIOS (13)\" lista os participantes da aula: \"Marcus Vi... (Você)\", \"Andre Carvalho...\", \"Arthur Souza Co...\", \"Bruno Berto de...\", \"Bruno Vargas de...\", \"Eduarda Emiliano...\", \"Filipe de Sousa F...\", \"Harisson Freitas...\", \"Jhonatan Borges...\", \"Matheus Virgílio...\", e \"Ualiton Ventura...\".\n\n**No conteúdo principal (lado direito), que é um documento de aula (provavelmente o plano de ensino):**\nO cabeçalho indica \"Universidade de Brasília\", \"Departamento de Ciência da Computação\". Abaixo, o título do curso é parcialmente visível como \"CIC0003 - Introdução aos Sistemas Computacionais\", e o nome do instrutor é \"Prof. Marcus Vinicius Lamar\".\n\nO documento apresenta o \"Cronograma das Aulas:\", estruturado em uma tabela com as colunas \"Sem\" (Semana), \"Dias\", \"Segunda\" e \"Quarta\". Os tópicos e datas são detalhados como segue:\n\n*   **Sem 0 (17/1, 19/1):**\n    *   Segunda: \"Apresentação e 0) Introdução (C.1)\"\n    *   Quarta: \"1) Introdução, abstrações e histórico (C.1)(T0)\"\n*   **Sem 1 (24/1, 26/1):**\n    *   Segunda: \"2) Desempenho: Fatores (C.1)\"\n    *   Quarta: \"3) Desempenho: Medidas (C.1)(T1)\"\n*   **Sem 2 (31/1, 2/2):**\n    *   Segunda: \"4) Ling. de Máquina: ISA (C.2)\"\n    *   Quarta: \"5) Ling. de Máquina: Assembly (C.2)(T2)\"\n*   **Sem 3 (7/2, 9/2):**\n    *   Segunda: \"6) Ling. de Máquina: Procedimentos (C.2)\"\n    *   Quarta: \"7) Ling. de Máquina: Recursividade e I/O (C.2)(T3)\"\n*   **Sem 4 (14/2, 16/2):**\n    *   Segunda: \"8) Arit. Computacional: Inteiros (C.3)\"\n    *   Quarta: \"9) Arit. Computacional: ULA (C.3) (T4)\"\n*   **Sem 5 (21/2, 23/2):**\n    *   Segunda: \"10) Arit. Computacional: Fracionários, IEEE 754 (C.3)\"\n    *   Quarta: \"11) Outras Arquiteturas (T5)\"\n*   **Sem 6 (28/2, 2/3):**\n    *   Segunda: \"FERIADO\"\n    *   Quarta: \"Lab 1A: Software – Rars (T6)\" (Rars é um simulador de MIPS)\n*   **Sem 7 (7/3, 9/3):**\n    *   Segunda: \"Lab 1B: Software – Compilador C\"\n    *   Quarta: \"Lab 2: Hardware – Verilog – ULA (T7)\" (Verilog para Unidade Lógica Aritmética)\n*   **Sem 8 (14/3, 16/3):**\n    *   Segunda: \"1ª Prova (P1)\"\n    *   Quarta: \"12) Processador Uniciclo: Unidade Operativa (C.4) (T8)\" (Unidade de dados/Datapath)\n*   **Sem 9 (21/3, 23/3):**\n    *   Segunda: \"13) Processador Uniciclo: Unidade de Controle (C.4) (L1)\"\n    *   Quarta: \"Lab 3: Processador Uniciclo (T9)\"\n*   **Sem 10 (28/3, 30/3):**\n    *   Segunda: \"14) Processador Multiciclo: Unidade Operativa (C.4)\"\n    *   Quarta: \"15) Processador Multiciclo: Unidade de Controle (C.4) (T10)\"\n*   **Sem 11 (4/4, 6/4):**\n    *   Segunda: \"Lab 4: Processador Multiciclo\"\n    *   Quarta: \"16) Processador Pipeline: Conceitos (C.4) (T11)(L1)\"\n*   **Sem 12 (11/4, 13/4):**\n    *   Segunda: \"17) Pipeline: Unidade Operativa e Controle (C.4)\"\n    *   Quarta: \"Lab 5: Processador Pipeline (T12)\"\n*   **Sem 13 (18/4, 20/4):**\n    *   Segunda: \"18) Exceção e Interrupção (C.4) (L1)\"\n    *   Quarta: \"19) Memória: Hierarquia (C.5) (T13)\"\n*   **Sem 14 (25/4, 27/4):**\n    *   Segunda: \"19.1) Memória: Cache (C.5)\"\n    *   Quarta: \"2ª Prova (P2) (T14) (L1)\"\n*   **Sem 15 (2/5, 4/5):**\n    *   Segunda: \"Prova Substitutiva\"\n    *   Quarta: \"Apresentação dos Projetos (P3) (T15)\"\n\nA seção \"Avaliação:\" lista as datas das provas:\n*   \"P1: 1ª Prova: 14/03/2022\"\n*   \"P2: 2ª Prova: 27/04/2022\" (parcialmente visível)\n\nNão há diagramas explícitos de Datapath, Pipeline ou Hierarquia de Memória na imagem; os nomes aparecem como tópicos do curso, indicando que esses conceitos serão abordados em aulas específicas. O conteúdo é predominantemente textual, descrevendo o plano de ensino e a agenda da disciplina de Arquitetura de Computadores (OAC - Organização e Arquitetura de Computadores, ou Introdução aos Sistemas Computacionais). As tecnologias e linguagens mencionadas incluem Assembly, C, Verilog e o simulador Rars (para MIPS). Os conceitos centrais incluem ISA (Instruction Set Architecture), ULA (Unidade Lógica Aritmética), processadores uniciclo, multiciclo e pipeline, além de hierarquia de memória e cache.",
        "transcription": "Boa tarde a todos, vamos para mais uma aulinha de OAC. Hoje é dia 31 de janeiro, então nós vamos começar com linguagem de máquina, a ISA de processador. A gente finalizou, então, o desempenho e seus fatores e medidas. Então, vamos ver o que nós temos para a aula de hoje.",
        "video_source": "OAC_2022-01-31.mp4"
    },
    {
        "id": 2,
        "timestamp_start": 33.74,
        "timestamp_end": 86.97,
        "slide_description": "Como Engenheiro de Computação Sênior, procedo à análise do slide e conteúdo anotado da aula de Arquitetura de Computadores para fins de um sistema de busca semântica (RAG), focando na extração de informações técnicas densas.\n\n---\n\n**Transcrições e Descrição do Conteúdo do Slide:**\n\nO slide em questão, apresentado no contexto de uma \"Sala de Aula de OAC\" (Arquitetura de Computadores, pelo contexto), é intitulado \"Aula 4: Arquiteturas de Processadores\".\n\n1.  **Identidade Institucional e Curso:**\n    *   No topo do slide, o logotipo da \"Universidade de Brasília\" é visível, acompanhado do texto \"Universidade de Brasília\" e \"Departamento de Ciência da Computação\".\n    *   No canto superior direito, há uma repetição do logotipo e texto, com detalhes adicionais do curso: \"CIC0003 - Introdução aos Sistemas Computacionais\", e a identificação do docente: \"Prof. Marcus Vinicius Lamar\".\n\n2.  **Título da Aula:**\n    *   O corpo principal do slide, sobre um fundo em tons de laranja e vermelho, exibe em destaque o título:\n        *   \"Aula 4\"\n        *   \"Arquiteturas de Processadores\"\n\n3.  **Conteúdo Visual e Metáforas de Programação:**\n    *   A porção inferior do slide apresenta uma série de imagens que funcionam como metáforas visuais para diferentes linguagens de programação, ilustrando provavelmente sua complexidade, nível de abstração ou performance, sob o contexto de Arquiteturas de Processadores.\n        *   **\"Assembly\"**: Representada por uma imagem de uma mira telescópica de rifle combinada com uma baioneta. Isso evoca a natureza de baixo nível, precisão direta de hardware e controle \"mão-a-mão\" que a linguagem Assembly oferece.\n        *   **\"C++\"**: Representada por uma imagem de um rifle de assalto futurista, sugerindo um poder de fogo elevado com certo nível de automação ou complexidade. Isso pode aludir à capacidade do C++ de operar em alto nível com abstrações poderosas, mas mantendo controle de baixo nível e alta performance.\n        *   **\"C\"**: Representada por uma imagem de uma pistola compacta. Isso pode indicar uma ferramenta fundamental, eficiente, direta e de \"core\" para programação de sistemas, mas menos \"equipamentos\" ou abstrações complexas que C++.\n        *   **\"Python\"**: Representada por uma imagem de um robô quadrúpede complexo, com vários apêndices e ferramentas acopladas (como metralhadoras e antenas). Isso provavelmente simboliza a versatilidade, a riqueza de bibliotecas e frameworks, e a capacidade de realizar tarefas complexas e diversas com relativa facilidade, embora potencialmente com um custo maior em termos de recursos de hardware ou velocidade de execução em comparação com linguagens de mais baixo nível.\n\n4.  **Autoria do Slide/Aula:**\n    *   Abaixo das metáforas de linguagem, o nome \"Marcus Vinicius Lamar\" é novamente transcrito, indicando ser o autor ou apresentador do slide.\n\n5.  **Elemento de Humor/Meme:**\n    *   No lado direito inferior do slide, há um popular meme com a imagem de Robert Downey Jr. (como Tony Stark) e o seguinte diálogo:\n        *   \"WHEN DID YOU BECOME AN EXPERT IN COMPUTER ARCHITECTURE?\"\n        *   \"LAST NIGHT\"\n        *   (Texto pequeno e quase ilegível abaixo): \"memegenerator.net\"\n    *   Este meme serve como um elemento de humor, talvez para quebrar o gelo ou para enfatizar que o domínio de um tópico complexo como Arquitetura de Computadores requer tempo e dedicação, contrastando comicamente com a ideia de se tornar um especialista da noite para o dia.\n\n6.  **Apresentador (Vídeo):**\n    *   Uma caixa de vídeo no canto inferior direito exibe o apresentador, um homem com óculos, o que confirma a presença de um componente de vídeo da aula ao vivo.\n\n**Conteúdo do Chat (Contexto de Interação):**\n\nA barra lateral esquerda exibe o chat público da aula, fornecendo contexto sobre a interação durante a sessão.\n*   **Mensagens Iniciais do Sistema/Anfitrião:**\n    *   \"Bem vindos à sala de aula de OAC!\"\n    *   \"Esta sessão está sendo gravada.\"\n    *   \"Para mais informações, clique aqui. Novo na plataforma? Experimente o tour!\"\n*   **Interações dos Alunos (com horários):**\n    *   \"Ualiton Ventura ... 13:55 boa tarde professor\"\n    *   \"Arthur Souza Cor... 13:57 boa tarde\"\n    *   \"Marcello Brandao... 14:01 boa tarded\"\n\nEste slide, portanto, serve como uma introdução à Aula 4 sobre Arquiteturas de Processadores, utilizando elementos institucionais, um título claro, metáforas visuais para linguagens de programação (ilustrando possivelmente diferentes níveis de abstração e controle de hardware) e um toque de humor para engajar a audiência. O chat revela o início da aula e saudações dos participantes.",
        "transcription": "Então vamos começar com arquitetura de computadores, arquitetura do conjunto de instruções, então tem a ver com software. Boa tarde Edson. Ok, então só para vocês irem acompanhando. Cadê meu cursor? Vocês não estão vendo meu cursor não? Por que vocês não estão vendo meu cursor? Para que agora...",
        "video_source": "OAC_2022-01-31.mp4"
    },
    {
        "id": 3,
        "timestamp_start": 87.01,
        "timestamp_end": 301.5,
        "slide_description": "Como um Engenheiro de Computação Sênior, analiso o slide da aula de Arquitetura de Computadores para extrair e descrever o conteúdo visual e textual de forma densa e técnica para um sistema RAG.\n\nO slide apresenta uma capa ou introdução para a \"Aula 4\" de uma disciplina, provavelmente de Arquitetura de Computadores. No topo, são visíveis os identificadores da instituição: \"Universidade de Brasília\" e \"Departamento de Ciência da Computação\". Um logotipo menor e mais detalhado à direita reitera \"Universidade de Brasília\", \"Departamento de Ciência da Computação\", e especifica a disciplina como \"CIC0003 - Introdução aos Sistemas Computacionais\", creditando o \"Prof. Marcus Vinicius Lamar\".\n\nO título principal do slide é \"Aula 4\", com um subtítulo \"Arquiteturas de Processadores\". Esta seção está sobre um fundo vermelho predominante, com um padrão quadriculado em tons de amarelo e laranja na porção esquerda, sugerindo um design moderno e energético.\n\nA parte inferior do slide contém uma série de imagens ilustrativas, cada uma associada a uma linguagem de programação, provavelmente com a intenção de representar níveis de abstração ou poder computacional.\n1.  **\"Assembly\"**: É ilustrada por uma imagem de uma luneta de precisão acoplada a uma faca ou baioneta. Esta metáfora visualmente sugere a natureza de baixo nível e a proximidade com o hardware, onde o controle é muito direto e \"cirúrgico\", mas a tarefa é manual e detalhada, similar à programação em Assembly.\n2.  **\"C++\"**: Apresentada com um rifle equipado com múltiplos acessórios táticos (mira, laser, punho). Esta representação pode simbolizar uma linguagem que oferece grande poder e flexibilidade, permitindo um controle significativo sobre o hardware (como C), mas com a adição de recursos e paradigmas mais complexos e poderosos (programação orientada a objetos, templates), análogos aos acessórios que aprimoram a funcionalidade do rifle.\n3.  **\"C\"**: Ilustrada por duas pistolas, armas de fogo mais compactas e diretas. Pode ser interpretada como uma linguagem que oferece um equilíbrio entre controle de hardware e abstração, sendo mais direta e \"ao ponto\" do que C++, mas ainda poderosa e fundamental para sistemas operacionais e desenvolvimento de sistemas.\n4.  **\"Python\"**: Representada por um robô quadrúpede futurista e complexo, com múltiplas armas e dispositivos. Esta imagem evoca a ideia de uma linguagem de alto nível, com grande abstração e capacidade para desenvolver sistemas complexos, inteligentes e autônomos, como os encontrados em inteligência artificial e robótica, destacando seu poder e versatilidade.\n\nAbaixo dessas imagens e seus rótulos, o nome \"Marcus Vinicius Lamar\" é novamente visível.\n\nAo lado dessas ilustrações, à direita, há um meme popular com o ator Robert Downey Jr. (interpretando Iron Man), com o texto: \"WHEN DID YOU BECOME AN EXPERT IN COMPUTER ARCHITECTURE? LAST NIGHT\" (em português: \"QUANDO VOCÊ SE TORNOU UM ESPECIALISTA EM ARQUITETURA DE COMPUTADORES? ONTEM À NOITE\"). Este elemento humorístico visa criar engajamento e reconhecimento com a audiência, aliviando a carga de conteúdo técnico.\n\nFinalmente, no canto inferior direito, há uma imagem do professor Marcus Vinicius Lamar, sugerindo que a aula está sendo ministrada ao vivo ou que ele está interagindo com o material.\n\nEm síntese, o slide é uma introdução à \"Arquiteturas de Processadores\", parte da disciplina de Introdução aos Sistemas Computacionais da UnB, lecionada pelo Prof. Marcus Vinicius Lamar. O conteúdo visual principal são metáforas imagéticas que representam diferentes níveis de abstração e complexidade das linguagens de programação (Assembly, C, C++, Python), complementado por um elemento humorístico e a presença do docente. Não há diagramas técnicos de arquitetura (datapath, pipeline, etc.) diretamente visíveis neste slide introdutório.",
        "transcription": "Está aparecendo agora aí, professor, só que é bem pequenininho. Está aparecendo? É, ele é rosa, né, ou vermelho, sei lá. É vermelho, é, não vai dizer que é azul, mas é vermelho. Ele apareceu bem pequenininho, só que só nos cantos da tela aí, que eu não sei se você estava passando na frente ou alguma coisa. Não, espero que eu estou tentando descobrir onde é que está o... O problema disso aí. Ficou preto tudo, não é? Não. Sim, ficou. E não vem mesmo o cursor. Que magia negra é essa? Correto. O cursor não está sendo capturado. Eu mudei o monitor 2 e vocês são os primeiros a testar isso. O que? O meu monitor 3 não está capturando o cursor. Calma. Eu preciso de um computador. É isso aqui. Ok. Preto durante um tempinho. Ele usou isso.",
        "video_source": "OAC_2022-01-31.mp4"
    },
    {
        "id": 4,
        "timestamp_start": 301.5,
        "timestamp_end": 335.71,
        "slide_description": "Como Engenheiro de Computação Sênior, analisei o slide e o contexto da interface apresentada. O conteúdo é extraído e descrito a seguir, focado em elementos relevantes para um sistema de busca semântica em Arquitetura de Computadores.\n\n**Conteúdo Visual Principal (Slide):**\nO slide exibido é a \"Slide 1\" de uma apresentação. Visualmente, ele não contém diagramas técnicos específicos (como datapath, pipeline, ou hierarquia de memória), nem código (Assembly, C, Verilog). O fundo é um padrão abstrato em tons de azul, apresentando silhuetas difusas de pessoas e um motivo que lembra uma placa de circuito impresso com linhas e pontos interconectados, sugerindo conectividade ou infraestrutura tecnológica. Sobreposto a isso, há um gráfico de linha ascendente, que pode simbolizar progresso ou desempenho. Há elementos de branding inseridos diretamente no slide: o logotipo \"ConferênciaWeb\" no canto superior esquerdo da área de exibição do slide, o logotipo \"mconf\" no canto inferior esquerdo, e o logotipo \"RNP ORGANIZAÇÃO SOCIAL DO MCTI\" no canto inferior direito.\n\n**Conteúdo de Texto (Transcrições):**\n\n1.  **Título da Aula/Sessão (Barra Superior):**\n    *   \"Sala de Aula de OAC\" (OAC é uma sigla comum para \"Organização e Arquitetura de Computadores\").\n    *   Tempo de gravação visível: \"05:25\".\n\n2.  **Mensagens no Bate-papo Público:**\n    *   Mensagem inicial da plataforma: \"Bem vindos à sala de aula de OAC! Esta sessão está sendo gravada. Para mais informações, clique aqui. Novo na plataforma? Experimente o tour!\"\n    *   Mensagem de Ualiton Ventura (14:02): \"Apesar de ter estudado, acredito que você não falou sobre lei de Amdhal, só avisando mesmo pra caso você vá cobrar em prova.\"\n        *   *Análise Técnica:* Esta mensagem é semanticamente crucial, pois menciona explicitamente a \"Lei de Amdahl\". A Lei de Amdahl é um conceito fundamental em Arquitetura de Computadores, especialmente no contexto de processamento paralelo, quantificando o ganho teórico máximo de desempenho de um sistema quando apenas uma parte do sistema é melhorada. Sua menção indica que o tópico é relevante para o escopo da disciplina ou para discussões prévias na aula.\n\n**Ausência de Elementos:**\nNão há diagramas de arquitetura de computadores, fluxogramas de dados, ou blocos de código (Assembly, C, Verilog) visíveis neste slide específico. A informação técnica mais direta é a menção à \"Lei de Amdahl\" no chat.\n\n**Contexto Geral da Aula:**\nA aula é sobre \"Organização e Arquitetura de Computadores\" (OAC), e está sendo gravada. A interação no chat sugere que a discussão pode abranger tópicos como desempenho e paralelismo, dado o questionamento sobre a Lei de Amdahl.",
        "transcription": "Ah, Lei de Amdahl. Ok.",
        "video_source": "OAC_2022-01-31.mp4"
    },
    {
        "id": 5,
        "timestamp_start": 335.71,
        "timestamp_end": 426.12,
        "slide_description": "Como Engenheiro de Computação Sênior, analisei o slide apresentado de uma aula de Arquitetura de Computadores. A seguir, extraio e descrevo seu conteúdo para um sistema de busca semântica, focando na informação técnica visível.\n\nO slide é um material de apresentação, provavelmente do início de uma aula, exibindo elementos de identificação do curso e da instituição, além de um tema central e ilustrações introdutórias.\n\n**Conteúdo Textual e Títulos:**\nNa parte superior do slide, há a identificação da instituição e do departamento. O texto visível é:\n*   \"Universidade de Brasília\"\n*   \"Departamento de Ciência da Computação\"\n*   Em um logo menor à direita, há detalhes adicionais: \"Universidade de Brasília\", \"Departamento de Ciência da Computação\", \"CIC0003 - Introdução a Sistemas Computacionais\", e o nome do professor: \"Prof. Marcus Vinicius Lamar\".\n\nO título principal da seção ou aula é claramente destacado:\n*   \"Aula 4\"\n*   \"Arquiteturas de Processadores\"\n\nNa porção inferior do slide, associado a ilustrações, encontra-se a identificação de linguagens de programação e o nome do professor:\n*   \"Assembly\"\n*   \"C++\"\n*   \"C\"\n*   \"Python\"\n*   \"Marcus Vinicius Lamar\" (abaixo das ilustrações das linguagens).\n\nHá também um \"meme\" ou imagem humorística com texto:\n*   \"WHEN DID YOU BECOME AN EXPERT IN COMPUTER ARCHITECTURE?\"\n*   \"LAST NIGHT\"\n*   Uma atribuição parcial \"memegenerator.r\" é visível.\n\n**Descrição de Diagramas e Elementos Visuais:**\nEmbora não haja diagramas formais de datapath, pipeline ou hierarquia de memória, o slide apresenta um conjunto de quatro ilustrações que funcionam como metáforas visuais para diferentes linguagens de programação, dispostas em uma matriz 2x2:\n\n1.  **\"Assembly\"**: Ilustrada por um rifle de precisão equipado com uma luneta e uma baioneta. Esta imagem simboliza o controle de baixo nível, a granularidade fina e a complexidade inerente à programação em Assembly, onde se manipulam diretamente registradores e instruções da CPU. A baioneta pode sugerir a proximidade direta com o hardware.\n2.  **\"C++\"**: Apresentada por um rifle tático mais complexo, com múltiplos acessórios (possivelmente um lançador acoplado e miras). Representa a versatilidade, o poder e a complexidade de C++, que permite programação orientada a objetos, meta-programação e acesso a recursos de hardware com alta performance, mas com uma curva de aprendizado e gestão de recursos mais acentuada.\n3.  **\"C\"**: Mostrada por duas pistolas simples. Reflete a natureza fundamental, eficiente e relativamente \"bare-bones\" da linguagem C, que é a base para muitos sistemas operacionais e linguagens de alto nível, sendo valorizada por sua performance e controle de memória direto, sem a abstração adicional de C++.\n4.  **\"Python\"**: Ilustrada por um robô quadrúpede avançado (reminiscente de um robô da Boston Dynamics), com diversos módulos e articulações. Esta metáfora destaca a alta abstração de Python, sua vasta biblioteca de módulos e frameworks, a facilidade de desenvolvimento e automação, e a capacidade de integrar diferentes componentes de software, embora possa implicar uma \"máquina\" subjacente mais complexa e potencialmente menos eficiente em termos de performance bruta de execução, comparada a C ou Assembly.\n\nNo canto inferior direito, há uma imagem do professor Marcus Vinicius Lamar, capturada ao vivo durante a apresentação, com sua mão no queixo em um gesto reflexivo ou de atenção. Ao lado dessa imagem, o \"meme\" visual com Robert Downey Jr. como Iron Man brinca com a ideia de tornar-se um especialista em Arquitetura de Computadores \"da noite para o dia\", sugerindo a complexidade do tema ou a necessidade de dedicação contínua.\n\nEm suma, o slide serve como uma introdução à \"Arquiteturas de Processadores\", utilizando metáforas visuais para ilustrar as diferenças de nível de abstração e complexidade entre linguagens de programação, um conceito fundamental ao discutir como processadores são projetados e programados.",
        "transcription": "E nada do cursor ainda. Eu tenho o problema normal. Não vai, meu Deus, só vai até aqui, ó. Depois ele sobe. Tô pensando se eu alterar... É, tem o... Só que vocês não vão enxergar, porque é um pontinho ruim. E pior que nem esse não está passando ali também. Ó, eu consigo fazer riscos, mas vocês não estão vendo o ponteiro. Aí fica difícil.",
        "video_source": "OAC_2022-01-31.mp4"
    },
    {
        "id": 6,
        "timestamp_start": 426.12,
        "timestamp_end": 568.28,
        "slide_description": "Como Engenheiro de Computação Sênior, analisei o slide da aula de Arquitetura de Computadores. A seguir, apresento uma descrição detalhada e densa em informação técnica, adequada para um sistema de busca semântica (RAG).\n\n---\n\n**Título Principal do Slide:**\n*   \"Aula 4\"\n*   \"Arquiteturas de Processadores\"\n\n**Informações Institucionais:**\nO slide exibe a identidade visual da instituição de ensino:\n*   \"Universidade de Brasília\"\n*   \"Departamento de Ciência da Computação\"\nEm uma área secundária, à direita, há uma versão menor do logo com informações mais específicas do curso e do professor:\n*   \"Universidade de Brasília\"\n*   \"Departamento de Ciência da Computação\"\n*   \"CIC0003 - Introdução a Sistemas Computacionais\"\n*   \"Prof. Marcus Vinicius Lamar\"\n\n**Elementos Visuais e Metáforas de Linguagens de Programação:**\nA parte inferior do slide apresenta um conjunto de quatro imagens que servem como metáforas visuais para diferentes linguagens de programação, alinhadas com o contexto de Arquiteturas de Processadores para ilustrar os diferentes níveis de abstração e controle sobre o hardware:\n\n1.  **Assembly:** Representada por um fuzil de precisão com mira telescópica e uma faca de combate acoplada. Esta metáfora sugere um controle extremamente granular e direto sobre o hardware, alta performance, mas também complexidade e a necessidade de precisão cirúrgica, assim como uma linguagem de baixo nível exige.\n2.  **C++:** Ilustrada por um lançador de granadas/foguetes. Simboliza uma linguagem de alto poder e expressividade, capaz de manipular grandes volumes de dados ou executar operações complexas com eficiência, aproveitando paradigmas como a programação orientada a objetos, mas ainda mantendo controle significativo sobre os recursos do sistema.\n3.  **C:** Apresentada por um martelo e uma chave de fenda/inglesa. Estas são ferramentas fundamentais e versáteis, o que reflete a natureza do C como a \"linguagem-ferramenta\" por excelência para programação de sistemas, drivers, sistemas operacionais e hardware embarcado, oferecendo acesso robusto e direto à memória.\n4.  **Python:** Exibida como um robô quadrúpede avançado, similar a um cão robótico bípede (ou talvez um mecanismo articulado complexo). Esta imagem evoca a ideia de uma linguagem de alto nível, com vasta aplicabilidade em áreas como inteligência artificial, robótica, análise de dados e automação, focando na abstração e na produtividade, em detrimento do controle direto sobre o hardware, comparado às linguagens de baixo nível.\n\nA autoria do professor é reafirmada abaixo dessas ilustrações:\n*   \"Marcus Vinicius Lamar\"\n\n**Elemento Humorístico/Meme:**\nAo lado das metáforas de linguagem, há um meme popular com o ator Robert Downey Jr. e a seguinte transcrição:\n*   \"WHEN DID YOU BECOME AN EXPERT IN COMPUTER ARCHITECTURE?\"\n*   \"LAST NIGHT\"\nEste meme adiciona um toque de humor, brincando com a percepção de se tornar um \"especialista\" em um tópico complexo como Arquitetura de Computadores em um curto espaço de tempo, potencialmente ressaltando a curva de aprendizado ou a necessidade de estudo contínuo.\n\n**Anotações Manuscritas:**\nNo canto superior esquerdo da área principal do slide, há anotações em vermelho, que parecem ser rabiscos feitos com uma ferramenta de caneta ou laser, possivelmente para destacar ou contornar elementos durante a apresentação. Não formam texto inteligível ou diagramas estruturados.\n\n**Professor em Tempo Real:**\nUma imagem do professor, Marcus Vinicius Lamar, é visível na parte inferior direita, indicando sua presença e interação durante a aula.\n\n**Ausência de Diagramas de Arquitetura Complexos:**\nNão há diagramas tradicionais de datapath, pipeline, hierarquia de memória ou outros esquemas arquitetônicos explícitos neste slide específico. O foco visual está em metáforas e informações textuais introdutórias.",
        "transcription": "Como é que eu vou apontar as coisas pra vocês? Desconectar e conectar o mouse? Eu preciso tentar. O problema é que pra mim a flechinha funciona. O que não está funcionando é... o espelho do cursor pra vocês. Não está aqui a flechinha. Mudar a janela de captura. Só inverter os dois. Quer dizer, tô animado. Esse aqui é o monitor de apresentação. E aquele lá é o monitor de trabalho. Ok. Vou tentar fazer isso. Mas assim não me parece difícil, pessoal. Normalmente 10 minutos que ninguém sabe o que é. Já que tem como desenhar, a propósito. Você tem um PowerPoint, você desenha e fica apertando Ctrl+Z. E fica saindo. Soluções? Pra aí, pô. Vamos ver. Depois eu vou ter que dar uma olhada. Porque realmente não está nem mostrando o que vocês estão vendo.",
        "video_source": "OAC_2022-01-31.mp4"
    },
    {
        "id": 7,
        "timestamp_start": 568.28,
        "timestamp_end": 630.34,
        "slide_description": "Como um Engenheiro de Computação Sênior, analiso o slide apresentado para extrair informações relevantes para um sistema de busca semântica. O slide é parte de uma aula de Arquitetura de Computadores e contém uma mistura de informações textuais e visuais.\n\n**Conteúdo do Slide:**\n\n1.  **Cabeçalho e Identificação da Instituição:**\n    *   No topo do slide, à esquerda, há um logotipo da \"Universidade de Brasília\", representado por um símbolo gráfico estilizado em verde e branco.\n    *   Ao lado do logotipo, o texto claro indica:\n        *   \"Universidade de Brasília\"\n        *   \"Departamento de Ciência da Computação\"\n    *   No canto superior direito do slide, um logotipo menor e mais detalhado repete as informações e adiciona o contexto da disciplina:\n        *   \"Universidade de Brasília\"\n        *   \"Departamento de Ciência da Computação\"\n        *   \"CIC0002 - Introdução à Sistemas Computacionais\"\n        *   \"Prof. Marcus Vinicius Lamar\"\n    *   Duas anotações do instrutor em vermelho, em formato de rabisco, estão presentes na área do \"Departamento de Ciência da Computação\".\n\n2.  **Título da Aula:**\n    *   A porção central do slide, em um grande bloco laranja-avermelhado, exibe o título da aula em texto branco, indicando o tópico principal:\n        *   \"Aula 4\"\n        *   \"Arquiteturas de Processadores\"\n\n3.  **Metáfora Visual de Níveis de Abstração:**\n    *   Na parte inferior do slide, uma seção visualmente divide linguagens de programação em um espectro de complexidade/abstração, usando a metáfora de armamentos e máquinas:\n        *   **Assembly:** Ilustrado por uma mira telescópica de rifle acoplada a uma faca tática. O texto \"Assembly\" está posicionado abaixo da imagem. Há uma anotação do instrutor (rabisco vermelho) apontando para este texto.\n        *   **C++:** Apresentado como um fuzil de assalto equipado com um lançador de granadas. O texto \"C++\" está posicionado abaixo da imagem.\n        *   **C:** Representado por uma pistola com um acessório robusto e quadrado acoplado (que pode ser interpretado como um supressor ou um módulo funcional). O texto \"C\" está posicionado abaixo da imagem.\n        *   **Python:** Ilustrado por um complexo robô de combate quadrúpede, com detalhes mecânicos intrincados. O texto \"Python\" está posicionado abaixo da imagem.\n    *   A ideia por trás desta metáfora é provavelmente demonstrar os diferentes níveis de controle e complexidade de programação, desde o baixo nível e direto (Assembly) até o alto nível e altamente abstrato (Python), onde a complexidade do hardware subjacente é encapsulada por frameworks e bibliotecas.\n\n4.  **Meme Contextual:**\n    *   Ao lado direito da metáfora das linguagens, um popular meme de internet com o ator Robert Downey Jr. (como Tony Stark) é exibido. O meme contém o seguinte texto em faixas verdes:\n        *   \"**WHEN DID YOU BECOME AN EXPERT IN COMPUTER ARCHITECTURE?**\" (no topo)\n        *   \"**LAST NIGHT**\" (na parte inferior)\n    *   Pode haver uma pequena menção a \"memegenerator.net\" na parte inferior do meme, indicando sua origem. Este meme serve como um elemento de humor e provavelmente para aliviar a densidade do conteúdo, talvez ironizando a complexidade ou a curva de aprendizado rápida na área.\n\n5.  **Autoria:**\n    *   Na parte inferior central do slide, o nome do instrutor é novamente visível: \"Marcus Vinicius Lamar\".\n\n6.  **Componente de Vídeo:**\n    *   No canto inferior direito da tela, há um feed de vídeo ao vivo do instrutor da aula, o Prof. Marcus Vinicius Lamar, que está falando e gesticulando.\n\nEm resumo, o slide, intitulado \"Aula 4: Arquiteturas de Processadores\" da Universidade de Brasília, apresenta os conceitos introdutórios à arquitetura de computadores, utilizando uma metáfora visual de complexidade de armamentos para ilustrar os diferentes níveis de abstração de linguagens de programação (Assembly, C, C++, Python), complementado por um meme humorístico sobre a aquisição de expertise na área. O Prof. Marcus Vinicius Lamar é claramente identificado como o autor e instrutor.",
        "transcription": "O que vocês estão vendo. Isso aqui. Ok. Vou ter que tentar destacar com... Vamos rabiscar aqui tudo. Sim, legal. E vocês não têm nem condições de acompanhar. Isso vai aparecer num espaço aleatório na tela. Por exemplo. Assembly. Que oferece as mínimas condições para tu fazer o desenvolvimento e resolver problemas. C já é um pouquinho mais elaborado. C++. Só que tem algumas coisas interessantes. E Python. Python, vocês conhecem. Ele é um atirador de arminhas. E as arminhas ficam atirando para tudo que é lugar. Com isso ele abre, se autotransporta, faz tudo.",
        "video_source": "OAC_2022-01-31.mp4"
    },
    {
        "id": 8,
        "timestamp_start": 630.34,
        "timestamp_end": 6339.77,
        "slide_description": "Como Engenheiro de Computação Sênior, analiso o slide intitulado \"Organização da Memória\" de uma aula de Arquitetura de Computadores (UnB - CIC0099 - Organização e Arquitetura de Computadores, Prof. Marcus Vinicius Lamar).\n\nO slide aborda conceitos fundamentais de como a memória é estruturada e acessada em sistemas computacionais.\n\n**Conteúdo Textual Transcrito e Anotado:**\n\n1.  **Título Principal:** \"Organização da Memória\"\n2.  **Informações da Aula (canto superior direito):**\n    *   UnB - CIC0099 - Organização e Arquitetura de Computadores\n    *   Universidade de Brasília\n    *   Departamento de Ciência da Computação\n    *   Prof. Marcus Vinicius Lamar\n3.  **Tópicos Principais:**\n    *   \"Grande array unidimensional\"\n    *   \" \"Byte addressing\" significa que um endereço aponta para um byte na memória.\"\n        *   \"Double Word: 64 bits -> 8 endereços\" (Anotação manuscrita: uma seta vermelha apontando para a direita)\n        *   \"Word: -> 32 bits -> 4 endereços\" (Anotação manuscrita: uma seta vermelha apontando para a direita)\n        *   \"Half Word: -> 16 bits -> 2 endereços\" (Anotação manuscrita: uma seta vermelha apontando para a direita)\n        *   \"Byte: -> 8 bits -> 1 endereço.\" (Anotação manuscrita: uma seta vermelha apontando para a direita, e \"8 bits\" sublinhado em vermelho)\n    *   \"Processador:\"\n        *   \"32 bits: N=32\" (Anotação manuscrita: \"1GIB\" ou \"1GB\" e uma seta apontando para a esquerda, talvez indicando capacidade máxima de memória endereçável).\n        *   \"64 bits: N=36, 40, 48, ..., 64\" (Anotações manuscritas: um círculo vermelho ao redor do \"64\", \"4GIB\" ou \"4GB\" e \"1TB\" ou \"1TIB\" abaixo, com setas vermelhas apontando para as diferentes capacidades, sugerindo que N pode variar dependendo da implementação do processador e os limites de endereçamento associados).\n\n**Conteúdo Visual e Diagramático:**\n\n1.  **Tabela de Endereços e Dados:**\n    *   Apresenta uma estrutura tabular com duas colunas: \"Endereço\" e \"Dado\".\n    *   Na coluna \"Endereço\", são listados endereços sequenciais de memória: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ... até \"2^N-1\".\n    *   Na coluna \"Dado\", cada endereço é associado a \"8 bits\", indicando que a memória é byte-endereçável (cada endereço único referencia 8 bits de dados).\n    *   **Anotações Manuscritas na Tabela:**\n        *   Círculos vermelhos destacados nos endereços 0, 2 e 8.\n        *   Chaves vermelhas agrupam os endereços para ilustrar os conceitos de tamanho de dados:\n            *   Uma chave grande agrupa os endereços 0-7, correspondendo a 8 bytes (um Double Word, 64 bits).\n            *   Uma chave menor agrupa os endereços 0-3, correspondendo a 4 bytes (um Word, 32 bits).\n            *   Outra chave agrupa os endereços 0-1, correspondendo a 2 bytes (um Half Word, 16 bits).\n            *   Uma chave agrupa o endereço 0, correspondendo a 1 byte (um Byte, 8 bits).\n        *   Essas chaves visam demonstrar como dados de diferentes tamanhos são armazenados e endereçados na memória byte-endereçável.\n\n2.  **Diagrama de Alinhamento de Memória:**\n    *   Localizado à direita da seção \"Byte addressing\".\n    *   Consiste em duas linhas que representam blocos de memória ou \"palavras\", com quatro posições de byte numeradas de 0 a 3.\n    *   **\"Alinhado\":** Apresenta um único bloco retangular amarelo contínuo que ocupa as posições 0, 1, 2 e 3. Isso ilustra que uma palavra de 4 bytes (ou 32 bits) começa em um endereço múltiplo de seu tamanho (neste caso, 0, que é um múltiplo de 4).\n    *   **\"Não alinhado\":** Apresenta um bloco retangular amarelo que ocupa as posições 1, 2 e 3, e um bloco retangular amarelo separado que ocupa a posição 0. Isso demonstra uma situação onde uma palavra não começa em um endereço que é um múltiplo de seu tamanho, resultando em dados que se espalham por diferentes \"palavras\" ou blocos de memória, o que geralmente implica em custos de acesso maiores e operações mais complexas para o processador.\n\n**Conclusão para RAG:**\n\nEste slide descreve a organização fundamental da memória, com ênfase no endereçamento por byte e nos tamanhos de dados comuns (Byte, Half Word, Word, Double Word) em termos de bits e endereços de memória. Ele visualiza como esses dados são mapeados em um espaço de endereçamento sequencial e ilustra a importância do alinhamento de memória para acesso eficiente. As anotações manuscritas sugerem uma discussão sobre a capacidade máxima de memória endereçável para processadores de 32 e 64 bits, e como o número de bits (N) para endereçamento pode variar em processadores de 64 bits. Os termos-chave para busca semântica incluem \"Organização da Memória\", \"Byte Addressing\", \"Endereço de Memória\", \"Dado (8 bits)\", \"Double Word (64 bits)\", \"Word (32 bits)\", \"Half Word (16 bits)\", \"Byte (8 bits)\", \"Alinhamento de Memória\", \"Memória Alinhada\", \"Memória Não Alinhada\", \"Processador 32 bits\", \"Processador 64 bits\", \"Capacidade de Endereçamento\", \"UnB CIC0099\".",
        "transcription": "Beleza. Então vamos ver. Quais são as arquiteturas modernas de hoje em dia. Então hoje em dia a gente tem duas arquiteturas principais que dominam o mercado. No mercado de dispositivos móveis, a ARM. Então a ARMv7 seria uma arquitetura de 32 bits da ARM. E a ARMv8, uma arquitetura de 64 bits. Me parece que agora, esse ano, a ARM está lançando a arquitetura ARMv9. Só que eu ainda não vi o que é que ela ia ser. Mas essas duas são as duas principais. Em termos de PC, o x86 é a versão da arquitetura da Intel para 32 bits. E o x86-64, então, a versão de 64 bits dos processadores Intel e AMD. No nosso caso, a gente não vai usar nenhum desses aqui. Por que a gente não vai usar? Porque são muito complexos. O x86, então, é uma mirabolância só. Então, a gente vai ter uma aula que nós vamos estudar outras arquiteturas e, daí, a gente vai comparar essa arquitetura que nós vamos estudar agora, que é o RISC-V, com aquelas arquiteturas comerciais. Para vocês terem uma ideia do grau de complexidade que são as arquiteturas ARM e x86.\n\nBom, o RISC-V é uma ISA não proprietária. Então, é uma ISA que qualquer um pode usar, diferente da ARM e do x86, que, se vocês quiserem fazer um processador que utilize essa ISA, vocês têm que pagar. Ao contrário, para o RISC-V não. Vocês podem construir um processador que use essa ISA sem precisar pagar nada. Então, por isso que é dito uma ISA não proprietária, e ela é desenvolvida por uma comunidade. Então, assim como os programas open source geralmente têm uma comunidade de desenvolvimento por trás, essa ISA aqui também tem uma comunidade de desenvolvimento por trás. Ele é relativamente novo. Enquanto a ARM surgiu em 1984, o x86 surgiu com o 80386 em 85, essa aqui, a RISC-V, então, surgiu em 2010. Em 2015 foi criada a RISC-V Foundation, que é gerenciada, ou melhor, várias empresas pertencem a essa fundação, entre elas todas essas que estão aqui. Então, a ISA nova projetada... ela não foi projetada para substituir a ARM, substituir o x86. Na realidade, ela foi projetada para os dois. Então, a ideia dessa ISA é que ela seja eficiente energeticamente e com bom desempenho, que a gente já viu que é um gargalo de tempo de execução. Então, é uma open ISA, não necessita de licenciamento, como já falei. A ISA clássica, a RV32, a RISC-V de 32 bits, a RV64, que é a versão de 64 bits dessa ISA, e eles já previram a RV128, que não se tem nem ideia de quando isso aqui vai ser necessário, mas a RV32 e a RV64 é o que existe hoje no mercado. Ferramentas open source de desenvolvimento, como o GCC, simuladores, tudo isso já existe. Já existem chips e placas de desenvolvimento disponíveis no mercado, então vocês podem comprar uma plaquinha com processador RISC-V. Então, assim como vocês têm o Arduino, foi lançado também um similar ao Arduino, mas utilizando processador RISC-V. Então, compatível com o Arduino, só que usando RISC-V. As empresas, excluindo a Intel e a ARM, certo? Então, a Intel e a ARM não querem saber do RISC-V. Já a AMD está apostando no RISC-V também. A AMD está aqui embaixo, certo? Então, a AMD pretende utilizar o RISC-V nos produtos dela.\n\nOk. A arquitetura RISC-V. Então, como eu já falei, a RV32, 32 bits; a RV64, 64 bits; a RV128, 128 bits. Bom, ela foi projetada para ser uma ISA modular. Exatamente. Hoje em dia, tem um monte de gente que está aparecendo direto aí nas notícias o uso do RISC-V. Então, ela é uma ISA que foi pensada para ser modular. O que isso significa? A Intel fez com que a ISA dela fosse a ISA do 386, que é uma ISA que é conhecida de diversas outras instruções. A cada novo lançamento, ela crescia mais instruções. Por isso que o x86 cresceu, que é o CISC. Essa aqui não é uma ideia, foi outra. Então, a gente tem uma ISA básica, que é a ISA de inteiros. Ah, que dó de não ter o cursor aqui! Que é a ISA de inteiros. E de acordo com as necessidades, da tua necessidade, tu pode acrescentar módulos a essa ISA de inteiros. Então, os módulos mais comuns são: um módulo de multiplicação e divisão. Ah, professor, mas por que multiplicação e divisão é opcional? Porque encarece o hardware. No laboratório 2, a gente vai ver por que isso encarece o hardware. Vocês vão medir efetivamente a complexidade de um circuito com e sem multiplicação e divisão. Então, multiplicação e divisão é um módulo. Instruções atômicas para a sincronização de memória é outro módulo. Esse aqui. Operações de ponto flutuante, precisão simples, precisão dupla. E como, geralmente, esses módulos eram módulos que eram muito utilizados, eram sempre muito utilizados, eles criaram, então, a nomenclatura I, M, A, F, D. Quer dizer, cada vez que eu acrescento um módulo, por exemplo, RV32IM significa: é inteiros, mais um módulo de multiplicação e divisão. RV32IF significa: inteiros, mais multiplicação, mais ponto flutuante. E assim a gente cria o processador com os módulos que a gente precisa. E como esses cinco módulos aqui eram muito utilizados, foi criada, então, a denominação G para identificar que o processador possui esses cinco módulos. Então, seria, por exemplo, RV32G ou RV64G. Então, esse G aqui significa que tem esses módulos padrões básicos. Hoje em dia, já tem módulos para processamento vetorial, processamento matricial, operação com números complexos, para auxiliar a GPU em processamento gráfico, em processamento digital de sinais, por exemplo, processamento de áudio, já tem outro módulo que faz isso. Então, estão sempre criando novos módulos. E como é que isso acontece? Alguém pensa em um módulo, sugere à comunidade, e a comunidade, então, se organiza para formalizar a especificação desse novo módulo. De modo que a especificação da ISA é única. Então, todo mundo que for usar o módulo D, por exemplo, vai utilizar as mesmas especificações, porque é padronizado isso. E também, ela foi pensada para se trabalhar com sistemas embarcados, quer dizer, um conjunto reduzido de instruções para sistemas embarcados. Então, para fazer microcontroladores que não necessitem do poder computacional que o microprocessador tem. Então, criaram o módulo C, que seria o módulo mais reduzido, que o chip fica menor, fica mais rápido, menor custo, principalmente. Ok?\n\nE nós temos quatro modos de operação. O modo normal. Cadê o meu cursor? O modo normal, quer dizer, tanto para qualquer uma dessas ISAs de 32, 64, 128, o modo normal, ele possui instruções de tamanho 32 bits. Para qualquer uma das ISAs. Por exemplo, a de 64 bits e o tamanho das instruções tem 32 bits, assim como a de 32 tem de 32. O modo condensado seria o modo mais voltado para esse aqui. Quer dizer, quando tem um sistema embarcado que tem um espaço menor, para não encarecer o sistema, então, o RISC-V permite usar uma ISA C (condensada), onde o tamanho das instruções, ao invés de ser de 32 bits, é de 16 bits. Então, fazendo com que os programas fiquem menorzinhos, cabendo, então, em RAMs menores. E também tem o modo expandido, que eles já... já previram, pensando mais no futuro. Hoje, então, os tamanhos das instruções seriam de 48, 64 ou 96 bits. Ok? Quer dizer, uma instrução pode ter 96 bits. Quer dizer, tem muitos campos nessa instrução, então, poderia ser modo expandido também, eles já normatizaram isso. Só tem que criar ISA para usar esse modo expandido. Nós vamos trabalhar aqui com a RV32IMF. O módulo A a gente não vai utilizar. Porque o módulo A serve para a sincronização de memória. A gente não vai trabalhar com esse problema aqui. Principalmente quando tem múltiplos núcleos, e esses núcleos acessam a memória. Então, quando um núcleo está escrevendo a memória, o outro pode ler, por exemplo. Então, essas instruções atômicas servem para isso. São loads e stores específicos quando a gente tem sistemas multicore.\n\nContinuando, né? Foi? Foi. Então, para a gente começar a estudar essa arquitetura, primeiro vamos estudar onde que os operandos nessa ISA podem estar, certo? E os dados, onde que eles podem estar? Então, eles podem estar em três lugares. Pode estar no banco de registradores. Eita, tá demorando. Aqui. No banco de registradores, nós vamos ver que tem 32 registradores, de 32 bits cada um, no caso da RV32. E é o local onde o processador tem acesso a esses dados de maneira mais rápida. Seria aquele topo da pirâmide de hierarquia de memória. Então, são esses registradores aqui. O segundo lugar seria em memória RAM. Então, para acessar os dados da memória RAM, podem ser acessados como byte, como half-word, como word ou como double word. Certo? Então, double word seria 64 bits. Então, típico da RV64. E para a RV32, a gente tem esses três tipos: Word, que são 32 bits; Half-word, que são 16; e Byte, que são 8 bits. Tá, esse aqui nós vamos ver daqui a pouco. Ih, olha a COVID se manifestando. E o terceiro lugar onde os operandos podem estar é na própria instrução, certo? Por exemplo, essa instrução aqui, ela pede que um operando venha do banco de registradores, e o outro operando está na própria instrução. Então, quando se escreve o programa, vocês já colocam lá esse número 123. Certo? Então, nesse caso aqui, um operando está no banco de registradores e o outro está na própria instrução. Meu Deus do céu. Ok, então vamos ver direitinho cada um desses locais. Então, primeiro, banco de registradores. Antes de irmos para o banco de registradores, essa aqui vai ser a ISA básica que a gente vai trabalhar. São essas instruções. Então, nessa tabelinha aqui... Aff, meu Deus, não gosto de ficar faiscando. Nessa tabelinha, então, vocês têm as instruções. Cadê? Aqui. Um exemplo de uso. O que que essa instrução está fazendo. E alguns comentários. Certo? Então, essas aqui são as instruções que a gente vai trabalhar. Então, se vocês pegarem a primeira edição, o Patterson lançou vários livros sobre arquitetura de computadores. Tá? E ele escolheu três ISAs para se basear. Então, ele escreveu um livro baseado na ISA MIPS, certo? Que é o clássico dele. A gente não vai ver aqui o processador MIPS. Então, é um livro baseado na arquitetura ARM, né? Então, tem o livro do Patterson, onde todos os exemplos, todas as... Ele descreve a arquitetura ARM. E tem o livro do RISC-V, que é esse que está na nossa bibliografia. O livro do RISC-V tem duas edições dele. A primeira e a segunda. Então, cuidado. Se vocês forem... Se vocês pegarem a primeira edição, a ISA que ele utiliza na primeira edição é a RV64. Então, de 64 bits. Certo? Já na segunda edição, ele viu que 64 bits não adiantavam muito para fins didáticos. Ele voltou para a ISA RV32. Tá? E a ISA RV32 que a gente vai utilizar. Então, cuidado. Na segunda edição, ele já usa a RV32. Mas na primeira, não. Tá? Então, pode ser que vocês encontrem alguma coisa meio estranha aqui no interior da primeira edição. O MARS, que é a nossa ferramenta de simulação que a gente vai utilizar nesse curso. A versão 1.4 do MARS, que eu disponibilizo, é a RV32. A versão 1.5 do MARS, o autor do MARS, o Benjamin, ele colocou um flag que permite que tu use a RV32 ou a RV64. Então, a partir da versão 1.5, ele permite essa escolha da ISA. Então, isso aqui é interessante para a gente poder simular algumas coisas na ISA de 64 bits. Eu não consigo. Eu estou riscando aqui porque eu não consigo ver onde está meu cursor. Tá, pessoal? Ok? Então, vamos lá.\n\nPrimeiro lugar é o banco de registradores. Então, a gente tem 32 registradores de 32 bits cada um. E todos os registradores são iguais. Quer dizer, o que significa que todos os registradores são iguais? Vocês estudaram mais em circuitos lógicos o que são os registradores, certo? Estudar flip-flops, certo? Então, um registrador é um conjunto de flip-flops. Então, nos dois casos aqui, nós vamos considerar um conjunto de flip-flops tipo D, aquele mais tranquilinho de se utilizar. Então, o que significa que todos os registradores são iguais? Significa que cada registrador possui 32 flip-flops, todos eles iguaizinhos. Então, para fins de hardware, eu tenho 32 registradores com 32 flip-flops cada um. Certo? Então, são todos, em termos de hardware, iguais. Com exceção do X0, que é esse que está chamando aqui. Está aqui. Foi esse aqui. Com exceção do X0. O X0 é um registrador, mas vocês não conseguem gravar um valor nele. Certo? Então, é um registrador read-only. Vocês só conseguem ler dele. E vocês vão ler o valor zero. Então, para que serve um registrador que eu não posso escrever? Quando, por exemplo, não te interessa o resultado, pode escrever, na tua operação, no registrador zero. Assim, o resultado vai ser simplesmente descartável. Então, nós vamos ver que existem várias utilidades para esse registrador zero. Certo? Ok? Então, deixa eu ver se eu posso colocar aqui mais. Então, o primeiro, X0. Então, todo registrador vai ser identificado dessa maneira aqui: X0, X1, X2, X3, até X31. Certo? Só que, a fim de legibilidade do código em assembly, que já não é muito legível, mas, para tentar facilitar um pouco, foi criada a convenção dos registradores. Então, o que isso significa? Que, para cada registrador, eu posso ter um nome. Certo? Então, X0 é o registrador zero. Então, eu posso escrever nos meus programas tanto X0 quanto zero. Certo? Eu posso escrever no meu programa tanto X1 quanto RA. Vai dar o mesmo registrador. Certo? E, devido a esses nomes, a gente tem usos sugeridos seguindo essa convenção. Certo? Então, isso aqui é a convenção, é uma sugestão de uso. Não é uma obrigatoriedade. No final, todo mundo acaba usando a convenção porque facilita em diversos aspectos o desenvolvimento do programa. Então, vamos passar um tour aqui. Então, primeiro, X1 é chamado RA, ou Return Address, endereço de retorno. X2 é o ponteiro da pilha, ou Stack Pointer (SP). X3 é um ponteiro global para a área de dados, ou chamado GP (Global Pointer). Um ponteiro de Thread. Já expliquei o que era Thread, né? Expliquei, né? Ok. Então, esse aqui é um ponteiro de Thread. Quer dizer, se o teu processador for um processador multithread, que consegue executar duas instruções, entre aspas, ao mesmo tempo, de duas tarefas diferentes, a gente tem esse ponteiro aqui que colabora no chaveamento das Threads. Então, é um ponteiro que indica qual é a Thread que está sendo executada. No nosso caso aqui, a gente não vai trabalhar com um ponteiro de Thread. A gente não vai trabalhar com Threads. A gente vai trabalhar em um único programa sendo executado em um único processador. A gente não vai usar vários programas sendo executados em um processador, que é onde precisaria de Threads. Mas o RISC-V está preparado para isso. X5, X7 e X28 até X31 são chamados registradores temporários. Tá? Então, são registradores que nós vamos ver no próximo slide. Vocês podem usar para cálculos temporários, cujo resultado vocês precisam armazenar em algum lugar para ser usado depois. Registrador X8, ele tem dois nomes: que é o S0, que significa o registrador salvo zero, porque eu posso ter registrador S1, S2 até o S11. Que seriam os registradores salvos. Registradores salvos são aqueles registradores onde vocês querem que o dado esteja e que não deve ser modificado. Certo? Por procedimentos, por exemplo. Então, são registradores de uso mais restrito, que têm sua aplicação específica. E o caso do X8, ele pode ser utilizado como S0, como ele também pode ser utilizado como FP. Tá? Então, ele tem duas utilizações por essa convenção. Ou a gente utiliza ele como S0, ou como um frame pointer. Certo? Então, ponteiro de frame. Isso aqui nós vamos ver quando a gente ver mais adiante para que serve o ponteiro de frame. Tá? Quer dizer, todos os ponteiros a gente vai ver depois. E, assim, esses são os registradores salvos. Tá? Então, esses registradores temporários e os registradores salvos. Nós temos registradores A. Tá? O A0, A1, A2, A3, A4, A5, A6, A7. Então, nós temos oito registradores A de argumentos. Certo? Então, são registradores, quando a gente vai chamar uma função, são onde os argumentos dessa função e desse procedimento que eu estou chamando devem estar. E eles são também registradores de retorno. Quer dizer, se a minha função retorna um valor, é nesses registradores A0 e A1 que eles têm que estar. Tá? Então, por isso está separado aqui. O A0 e A1 são registradores de argumento, mas também podem ser utilizados como retorno de resultados, resultados de funções. Já que A2 até o A7 são só para passagem de argumentos. Certo? Para as funções. E isso aqui, então, é o que a gente chama de convenção. Tá? Ah, professor, mas por que usar um registrador X5 a X7 para T0, T1 e T2 e depois lá o X28, 29 para o T3, T4, T5 e T6? Não seria mais lógico colocar todos eles em sequência? Olha, seria. Para a minha concepção, seria. Tá? Mas, os desenvolvedores do RISC-V resolveram dar essa convenção. Deve ter um porquê disso. Só que eu não sei qual é o porquê de fazer essas coisas quebradas assim. Ah, que problema interminável isso. Ok? Como sempre, escrevam as dúvidas de vocês no Notepad. E depois deem um Ctrl+C, Ctrl+V aqui, quando vocês tiverem perguntas. Outra coisa. A questão de responder à presença lá no Aprender e no FATIM. Tá? Respondam à presença no FATIM também.\n\nEntão, vamos continuar aqui. Ok. Então. Para que que serve a tal convenção? Para a gente poder fazer principalmente chamadas de funções. Tá? Que seria esse aqui. Chamadas de procedimentos. Ei, meu Deus. Cadê? O que eu tenho que fazer? Vou fazer um teste aqui rapidão, pessoal. Pomba. Nenhum cursor aparece. Eu estou com um cursor de um problema aqui. Mas nem esse cursor aparece. Que sem graça. Pega uma imagem do cursor pequeno e vai passando pela frente dos slides. Arrastando o cursor, é? Pela porta. É, exatamente. Ai, meu Deus do céu. Talvez. Solução tem para tudo, né? A solução certa, no meu caso, acho que vai demorar um pouquinho para eu achar. Mas soluções alternativas, acho que a solução alternativa de... Ah, não é só o RISC-V. Vocês conseguem ver, mas o cursor não. Tudo bem. Então, vamos lá. Agora, como é que eu apago isso? Não sei. Apaga tudo. Então, vamos. Então, o que seria a nossa chamada de procedimentos? Então, eu tenho aqui o meu programa principal. Aqui. Certo? Que vocês estão executando o programa principal de vocês. E, de repente, esse programa principal precisa chamar um procedimento, um subprograma, uma função, né? Que está em outra posição de memória, tá? Isso aqui não é outra memória diferente. É só outra porção de memória. Então, nós vamos ver que nós vamos utilizar a instrução JAL para fazer isso. Então, a instrução JAL `PROC` é o que a gente chama de label. Ao invés de a gente trabalhar com os endereços absolutos, os números de 32 bits em hexadecimal que designam o endereço, a gente vai utilizar labels, tá? Aqui, o montador traduz esse label, por exemplo, PROC, para o endereço físico que ele corresponde. Então, nesse caso aqui, `JAL PROC`, eu vou chamar o procedimento PROC. Esse procedimento é executado. Acabou de executar o procedimento. Ele vai executar, então, a pseudo-instrução RET. Certo? Então, ele retorna para a instrução seguinte ao JAL e continua executando. Ok? Todo mundo entendeu esse mecanismo? JAL chama esse procedimento. O procedimento é executado. E a instrução RET manda o processador de volta para o programa principal para ele continuar executando o programa principal. Tranquilo? Então, uma parada, professor. Quando a gente retorna, o endereço, ele pode meio que dar uma... Sim. Uma alterada? Sim. Tem essa paradinha aí. Mas isso aí é para mais tarde. Quando a gente vê especificamente isso aí. Aqui eu só estou querendo mostrar a convenção dos registradores. Sem entrar nesses probleminhas da chamada de procedimento. Mas tem sim. Então, o que acontece nessa chamada desse procedimento? O que significa registradores não preservados? Que são esses aqui. E o que significa registradores preservados? Que são esses aqui. Então, registradores não preservados significa: se eu estou usando um deles aqui, por exemplo, T0 igual a 100. Aqui, eu defini que o valor de T0 aqui era 100. Ao chamar esse procedimento, vem para cá. O procedimento pode alterar o valor de T0. Por exemplo, passar ele para 5. E ao retornar, esse valor de T0 vai ser 5. Opa, T0 igual a 5. Porque o procedimento alterou. Por isso que é chamado não preservado. Quer dizer, o procedimento pode alterar à vontade. Que o programa principal não pode pensar ou pressupor que o valor de T0, depois da chamada do procedimento, continue sendo 100. Não, ele não pode pressupor isso. Porque o procedimento pode ter alterado o valor desse registrador. Então, todos os registradores não preservados podem ser modificados à vontade pelo procedimento. Certo? Os registradores preservados, por exemplo, ao invés de usar o T0, vou colocar aqui o S0. Certo? O que acontece? S0 igual a 100 é o meu programa principal. Ao chamar o procedimento, o procedimento pode usar o S0. Tá? Temos que garantir que, ao acabar aqui, o S0 continue tendo 100. De modo que, quando retornar, o valor de S0, aqui depois do retorno do procedimento, vai continuar sendo o mesmo de antes do procedimento. Como se esse valor tivesse sido preservado. Certo? Preservado por quem? Pelo procedimento. Certo? Pode ser que o procedimento nem use o S0. Ótimo. Então ele já não vai ser alterado. Ah, mas se o procedimento precisar utilizar o S0? Ah, então o procedimento vai ter que salvar o valor original dele, fazer o processamento que necessita e depois restaurar o valor original dele para retornar. Porque o programa principal, ele não quer saber se o S0 foi utilizado ou não. Ele quer saber, ele pressupõe que o S0 antes tinha um valor e depois da chamada do procedimento, ele continua com o mesmo valor. Certo? Isso que significa registradores preservados e não preservados. Tá? Depois a gente vai ver onde que é que nós vamos salvar isso aí. Ok? Aqui então, só para entender. Registradores. Ah, eu não posso utilizar o mouse. Registradores. Ah, caramba. Cadê eu aqui? Estou aqui. Registradores não preservados e registradores preservados. Caraca, que diabo. Ok. Então esse aqui é o nosso banco de registradores. Que é o primeiro lugar onde nós temos os operandos das nossas instruções. Que é o lugar mais rápido.\n\nO segundo lugar de acesso mais rápido é a memória RAM. Então os operandos também podem estar na memória RAM. Então em nosso caso, a memória RAM, a gente vai adotar o modelo byte-addressable. O que significa um modelo byte-addressable? Significa que cada endereço, então endereço 0, endereço 1, 2, 3, até o 2^N-1, vai armazenar um byte. Certo? Por isso que ela é chamada byte-addressable. Cada endereço armazena um byte. Essa é a forma mais comum que tem de gerenciamento de memória nos computadores atuais. Pode ter aplicações específicas. Por exemplo, uma aplicação específica que eu já disse que faz. Posso ter aqui uma ideia de 8 bits, 14 bits, onde cada dado ali seja de 14 bits. Não deixa de ser um estrambolho. Ok. Pode ter. O tamanho do dado aqui. O tamanho do dado aqui. Não tem que ser sempre 8. Vocês podem encontrar um sistema aí onde o tamanho do dado é em quantidade de bits diferentes. A gente sempre vai considerar aqui, então, que cada endereço tenha 8 bits. Ok? Então, se o dado que eu quero é um byte, eu vou precisar de um endereço para armazenar esse byte. Então, quer dizer, eu preciso somente de um endereço. Se o dado que eu tiver querendo ler ou escrever for uma half-word, significa que eu vou precisar de 16 bits para armazenar esse dado. Um dado half-word. Então, com isso, eu vou precisar de dois endereços agora. Vou precisar de dois endereços para armazenar esse dado. Certo? Então, um byte requer um endereço. Uma half-word requer dois endereços. Uma word são 32 bits. Logo, para eu armazenar uma word na memória, eu vou precisar de 4 endereços. Por exemplo, esses 4 endereços aqui. Ok? Se eu quisesse armazenar uma double word, que seria 64 bits, aí eu precisaria de 8 endereços. Então, na minha memória, para armazenar um dado de 64 bits, eu preciso de 8 endereços de memória. Entendido isso, pessoal? Tranquilo até agora? Beleza.\n\nAqui a gente pode ter que nossos dados estejam alinhados ou não alinhados. Então, por que é importante a gente saber isso? Porque existem processadores que conseguem trabalhar com dados desalinhados. O RISC-V trabalha somente com dados alinhados. Então, o que seria esse alinhamento? Tá? Bom, se meu dado for um byte, ele pode estar em qualquer porção de memória. Sem problema nenhum. Tá? Se o meu dado for uma half-word, é necessário que o último bit do endereço seja 0. O que significa o último bit do endereço ser 0? Significa que o endereço é par. Certo? Se o último bit for 0. Quer dizer... Se o meu dado está alinhado... Cadê meu cursor? Cursor, cursor, cursor... Tá aqui. Então, se o meu dado está alinhado, ele só pode estar no endereço 2 ou no endereço 4 ou no 6 ou no 8. E vamos utilizar esses dois bytes aqui para representar... Opa! Isso que eu fiz errado. Esses dois bytes aqui para representar o dado half-word. Ok? Isso significa que ele está alinhado. Ah, professor. Eu poderia usar então esses dois aqui? Não. Não vai poder utilizar esses dois aí, porque o dado não estará alinhado. A mesma coisa acontece para 32 bits. Para 32 bits, a memória, eu preciso de 4 posições de memória, não 2. Então, como que eu sei que ele está alinhado? Quando os dois últimos bits do endereço forem 0. Bom, o que que significa que os dois últimos bits do endereço ser 0? Significa que o endereço é múltiplo de 4. Certo? Então, quando o dado estiver alinhado, ele vai poder utilizar esses dados aqui. Né? Então, o endereço 0 pode utilizar esses dados aqui, que é o endereço 4. Pode utilizar os dados a partir daqui, que é o endereço 5. Certo? A partir daqui, que é o endereço 8. Aí, o dado vai estar alinhado. Eu poderia usar para uma word, por exemplo, o endereço 2 para armazenar uma word? O que que você acha? Eu poderia usar um endereço 2 para armazenar uma word? Não, né? Porque vai estar desalinhado. Tá? Então, seria a utilização desses aqui. Certo? Porque o endereço 2, então, não é um endereço alinhado para uma word. Certo? E o dado double word, que a gente não vai usar [na RV32], significa o quê? Que o endereço tem que ser múltiplo de 8. Ou que os 3 últimos bits do endereço sejam 0. Então, se os 3 últimos bits do endereço forem 0, significa que é múltiplo de 8. Então, quais são os endereços que uma double word poderia estar? Uma double word poderia estar utilizando. Poderia ser utilizada no endereço 0, a próxima seria o endereço 8, a próxima no endereço 16, a próxima no endereço 24. Então, de 8 em 8. Ok? Isso significa estar alinhado. Tá? O último bit ser 0 em caso de half-word. Dois zeros em caso de word. E três zeros em caso de double word. Entendido? Entendido? Então, um dado byte pode estar desalinhado? O que vocês acham? Um dado do tipo byte pode estar desalinhado na memória? Não, né? Então, um dado byte, vocês podem usar qualquer porção de memória para armazenar ele. Ok.\n\nAqui, nós vamos considerar que o tamanho da memória é 2^N-1. Certo? Então, vai do endereço 0 até o endereço 2^N-1. Onde N é o número de bits do processador. Então, o que seria o número de bits do processador? É o número de bits do tamanho dos registradores. Então, nesse caso da RV32, cada registrador tem 32 bits. Então, esse nosso N aqui seria 32. Por quê? Se eu tenho um registrador de 32 bits. Se eu quiser armazenar um endereço nele. Então, o registrador ser um ponteiro. Significa que o endereço vai ter, no máximo, 32 bits. Faz sentido isso para vocês? Se o registrador é de 32 bits e eu quero armazenar um endereço, então, quer dizer que o endereço, no máximo, vai poder ter 32 bits. Certo? Então, para processadores de 32 bits, o N é 32. O que isso significa? Qual é o tamanho da memória que eu posso endereçar? Qual é esse último elemento? Qual é o tamanho dessa memória? Do endereço 0 até o endereço 2^32-1? Se eu tenho a RV32. Calma aí, pessoal. Vocês têm um computador na frente para resolver esse problema. Ou então, perguntem no chat. Qual é o tamanho da memória? Não, eu quero saber o tamanho da memória. O que é o tamanho da memória? O tamanho da memória é quantos endereços eu tenho. É isso aqui. É o número de endereços. Ok? Então, quantos endereços eu tenho se o tamanho do endereço é de 32 bits? Exatamente, Jorge. Esses... 4.294.967.296 bytes. Vamos escrever direito, João. Deixa eu escrever aqui. É 4 gigabytes. Não. 4 gigabytes. Eu já falei para vocês a diferença entre o prefixo decimal e o prefixo binário. Quer dizer, para processadores de 32 bits, eu conseguiria colocar... Olha só, ficou bonitinho essa forma de escrever aí. Eu poderia ter, no máximo, uma memória de 4 gigabytes. Ok. Então, por que surgiram os processadores de 64 bits? Para poder ter palavras de 64 bits? Não, não, não. O principal motivo foi essa limitação aqui que dava 4 gigabytes. Quer dizer, as aplicações foram ficando mais complexas, o sistema operacional foi ficando mais pesado e 4 gigabytes de memória já não era suficiente. Então, o que eles fizeram? Vamos evoluir. Então, eles fizeram os processadores de 64 bits, que é o que a gente tem hoje. Todo mundo utiliza processador de 64 bits. Por que isso? Porque agora eu posso ter... O meu registrador tendo 64 bits, o meu endereço vai poder ter até 64 bits. Então, qual é o tamanho da memória que eu tenho, que eu posso endereçar se o meu processador é de 64 bits? Vamos lá. Escrevam aí. Qual é o tamanho da memória em bytes, em múltiplos de bytes, se por acaso eu tenho um tamanho de palavra de 64 bits? Então, ponham e coloquem aqui o resultado. Ó, então escreve aí bonitinho, 2 elevado a 64. Quero ver. Certo. Muito bem. Tá, quanto dá isso aí? Qual é o número que dá? Qual é o número que dá 2 elevado a 64? Isso aí. É o 18... Cuidem aí, é 18 exabytes. Tá, não é 1,8 exabytes. É 18 exabytes. Certo? Ok, vocês têm ideia do que é esse número em termos de memória? Vocês terem uma memória no computador de vocês de 18 exabytes? Vocês têm noção do que é? Quanto que tem de memória o computador? No PC de vocês agora. No monitor. No monitor. Escrevam aí, que eu quero ter ideia. Não é 18 exabytes. É 16 exabytes. Tá? Certo? Arrumem ali. Não é 18 exabytes. É 16 exabytes. Ok, vocês têm 4 gigas, 32 gigas, 32 gigas já é bastante. Então agora vocês pegam essa memória aí de vocês, multipliquem por 1024. Tá? Vocês vão ter a memória em terabytes. Multipliquem por 1024. Vocês vão ter a memória em peta. Multipliquem por 1024. Vocês vão ter a memória em exa. Tá? Então só essa memoriazinha de vocês aí, teriam que multiplicar por 1024, por 1024 e por 1024. Então é uma quantidade de memória, sim, que a gente não tem tecnologia para montar uma memória desse tamanho. Tá? Então, se o meu computador tem 64 bits e eu não consigo utilizar todo esse espaço de endereçamento de memória, que seria de 16 exabytes, tá? O que é feito hoje em dia? Hoje em dia é feito que ao invés de usar os 64, se utilizam quantidades menores de bits, dependendo da aplicação. Então, por exemplo, eu posso ter um processador que tem 64 bits, mas desses 64, somente 40 são utilizados para o endereçamento. Os outros 24 bits são descartados, tá? Não são utilizados. Com isso, qual o tamanho de memória que eu consigo ter se o meu endereçamento é de 40 bits? Eu consigo endereçar até quanto? Qual o tamanho máximo de memória que eu posso ter se, dos 64 bits do registrador, eu usar 40 apenas para endereçamento? Calculem aí, 2^40, dá quanto? Isso, 1 terabyte, certo? Então, máquinas com 1 terabyte, falando assim leigamente, né? Então, vocês têm servidores, máquinas de 1 terabyte de memória RAM, né? Ok, 1 terabyte não é o suficiente. Então, eu vou botar 48, que endereça 256 terabytes. Então, dependendo da aplicação, a gente pode usar mais bits até os 64. Até os 64 seria desperdício, uma vez que algum fabricante que montar uma memória de 16 exabytes não vai existir tão cedo. Tão cedo que eu digo por décadas, tá? Ok, então essa aqui é a nossa memória, tá? Alguma dúvida, pessoal? Arthur, o que tu escreveu aí está errado, tá? É, 2^40 bytes. Beleza. Então, vamos continuar aqui.\n\nOutra coisa que é importante a gente saber em relação à memória. Vamos supor que eu queira armazenar uma word nessa minha memória. Acho que eu tenho um exemplinho aqui. Não, eu não tenho um exemplinho aqui. Eu queira armazenar uma word na memória. Então, eu vou usar, por exemplo, esses 4 endereços aqui. Tá? A minha word, nos 32 bits, então, em bits 0 até o bit 31, eu posso dividir em 4 bytes: o byte 0, byte 1, byte 2 e byte 3. Certo? Então, essa aqui é a word que eu quero armazenar na memória. Ela tem a proposta de 4 bytes. Então, por isso que eu preciso de 4 endereços. Qual é a ordem que eu vou gravar esses bytes na memória? Será que eu posso... Será que eu posso colocar aqui o byte 0, aqui o byte 1, byte 2 e byte 3? Posso fazer isso? Posso? Ah! Então, eu também posso colocar aqui o byte 3... Esse aqui é 3, tá, pessoal? Byte 2, byte 1 e byte 0. Estou armazenando os 4 bytes na memória, só que da maneira inversa agora. Tranquilo. Assim como eu posso ter qualquer outra combinação: Byte 2, byte 3, byte 1 e byte 0. Posso armazenar desse jeito? Só que vai ficar mais complicado de ler isso aqui, né? Mas posso. Então, eu tenho várias maneiras de se colocar a minha word na memória, tá? Para reduzir essa grande quantidade de combinações que eu posso utilizar, foi definido dois ordenamentos de bytes. Seria byte order, ou também chamada de endianness. Seria o Big Endian e o Little Endian. São os dois formatos padrões de armazenamento de dados na memória. Então, vamos supor que eu tenha esse número aqui de 32 bits. Notem que isso aqui está em hexadecimal. 0x significa hexadecimal. Então, 0x12345678. Ok. Se eu quero armazenar essa word em modo Big Endian, então, eu vou colocar aqui o byte mais significativo primeiro. Então, ele começa escrevendo esse byte, depois esse, depois esse, depois esse. Dessa maneira aqui, na memória. Certo? Então, Big Endian significa que o byte mais significativo vem primeiro. Little Endian é o contrário. Significa que eu vou escrever primeiro o byte menos significativo (Last Significant Byte). Quer dizer, eu vou começar então com esse byte: 7, 8. Depois o 5, 6. Depois o 3, 4. E o 1, 2. Certo? Então, Little Endian: o byte menos significativo vem primeiro, e no endereço menor aqui. Ok? E o mercado então se dividiu em relação a essas duas formas de se armazenar uma word na memória. Quer dizer, armazenar uma word na memória. Uma double word na memória. Até mesmo uma half-word na memória. Uma half-word pode ser escrita de duas maneiras. Então, a gente tem processadores que utilizam Big Endian. Por exemplo, os IBMs, os processadores da IBM, Motorola 68000, os processadores da HP. Toda a rede de processadores da HP, o MIPS 32 e o MIPS 64. Então, são processadores que utilizam Big Endian. Nós temos processadores que utilizam Little Endian. Então, por exemplo, o x86, DEC Alpha, AVR. Tá? E também temos os processadores bi-endian, que preferencialmente utilizam Little Endian. Por que preferencialmente? Porque a gente tem processadores onde a gente pode escolher qual é a forma que o processador vai trabalhar, tá? Se é Little Endian ou Big Endian. Então, seria o bi-endian. Esse aqui embaixo. Significa que eles são configuráveis. Então, exemplo típico: o MIPS R2000, o SPARC V9 da Sony, né? A arquitetura ARM toda é configurável. E o RISC-V também é configurável. Certo? Então, a gente poderia configurar como que a gente iria gravar os bytes na memória: Little Endian ou Big Endian. Tá? Mas, eles preferem. Eles recomendam que a gente use o Little Endian. Então, vai ser isso que a gente vai utilizar. Ok. Então, vamos lá. Ok. Então, se eu tenho aquela word lá em cima 0x12345678. Na memória. Se eu quiser armazenar a partir do endereço 0, eu vou ter então esses valores armazenados aqui. Ok? Então, isso é o nosso endianness (byte order).\n\nSeguindo adiante. Ok. Os dados estão lá, bonitinhos na memória. Como é que eu acesso aqueles dados? Como é que o processador acessa aqueles dados? Né? Processadores RISC, eles geralmente são uma arquitetura load/store. O que que significa isso? Uma arquitetura load/store significa que eu tenho as instruções load e a instrução store e somente essas instruções, esses dois conjuntinhos de instruções é que acessam a memória. Nenhuma outra instrução acessa a memória. Certo? Então eu tenho instruções específicas de acesso à memória: load e store. Ok? O x86, por exemplo, não. x86 não é uma arquitetura load/store, o x86-64. Ela é uma arquitetura onde instruções aritméticas podem acessar a memória. Então, inicialmente as instruções load/store acessam a memória. Outras instruções podem acessar a memória. Mas eu volto a falar nisso mais tarde. Ok? Então somente as instruções load acessam a memória e as outras instruções acessam alguns dados dos registradores.\n\nBom, como é que nós vamos definir o endereço nessa memória? Então nós vamos utilizar a seguinte notação. Essa notação aqui. Essa notação aqui a gente vai escrever nos programas, tá? Então é o offset e entre parênteses a definição de um dos registradores (registradores de X0 até X31, ou o nome que vocês quiserem). Essa anotação aqui significa o quê? Significa que o endereço que eu quero acessar é dado pelo valor armazenado no registrador, somado com esse offset. Então esse offset aqui é um número, por exemplo, 10, e o registrador é qualquer um dos registradores, por exemplo, T0. Então o que significa `10(T0)`? Significa que o endereço que eu quero acessar vai ser dado pelo conteúdo de T0, o número que estiver armazenado em T0, mais 10, que é o offset. Aí, quer dizer, o montador permite que vocês usem uma ou várias outras formas de se escrever isso. Quando vocês começarem a mexer com o MARS, vocês vão ver, ah, eu posso escrever, então, em vez de `10(T0)`, de uma outra forma? Pode, tá? Mas não é o padrão, tá? São facilidades apenas que o montador te oferece, tá? A ISA padrão, essa aqui é a forma de nós termos de representar os nossos endereços. Cadê o endereço? Ah, aqui. Dessa forma aqui é que nós vamos utilizar, tá? Então o montador pode permitir outras formas, ok? Então ele só tem esse modo de endereçamento aí, no caso do RISC-V.\n\nOk, princípios básicos de projeto de uma ISA, né? Então esse aqui foi do Patterson também, quando ele começou a trabalhar com microprocessadores lá na década de 80. Então ele colocou as seguintes regrinhas, assim, ou os seguintes mandamentos, ou as seguintes diretrizes, né? Seria: simplicidade favorece regularidade. Quer dizer, se tu tem uma coisa que é simples, tá? Ela pode ser facilmente colocada de uma forma regular. E se alguma coisa é regular, é porque tu consegue acessá-la de maneira simples, tá? Então simplicidade favorece regularidade. Menor significa mais rápido, tá? Aqui ele estava falando do número de registradores, do banco de registradores. Quanto mais eu aumento o número de registradores, do banco de registradores, mais lento fica para eu acessar um registrador. Ok, então por que ele escolheu 32? Porque ele viu que era uma boa relação entre o custo do processador e a velocidade de acesso aos dados do banco de registradores. Então o menor significa mais rápido. Ah, então por que ele não fez? Por que ele não fez? Daí, por surpresa de vocês, o x86 e o x86-64 não são avarentos com o número de registradores. E ele viu que um número de registradores era pouco, então ele usa mais registradores. Bons projetos existem bons compromissos. O que isso significa? Significa que se tu for alterar alguma coisa, ela tem que ser muito bem justificada. Tá? Então o objetivo de se projetar uma ISA é maximizar o desempenho, minimizar o custo e reduzir o tempo de projeto. O projeto de um novo processador, digamos assim. Então maximizar o desempenho do processador, minimizar o custo do processador e reduzir o tempo de projeto daquele processador. Ok, então vamos começar a ver as operações em assembly mais básicas.\n\nO que aconteceu aqui? Tá? Então, eu sempre vou referenciar aquilo que vocês já conhecem, vocês são geração Python também, né? Então, vocês não sabem se... Certo. Não, meu irmão, vocês são... Ok. Uma da geração que veio antes de mim. Mas vamos lá. Então, eu sempre vou referenciar como é que se faria aquilo em C, porque é mais próximo de assembly do que Python. Python é uma linguagem mais de alto nível, eu sempre digo que não difere muito, tá? Então, primeiro, instruções aritméticas. As operações aritméticas são o que a gente chama de instruções tipo R. Tipo R porque se utiliza de três registradores, tá? O acrônimo de registradores, tá? Que vai ser um registrador de destino e dois registradores de operando, tá? Então, por exemplo, é vocês, vocês são ainda da geração Z. Ah, vocês não são millennial ainda, né? Os millennials... Não, vai, agora já era... Não, parei nisso. A Y que veio depois da minha, a Z. Ah, tá certo, vocês são geração Z. Meus filhos são geração Z. Tá certo. O próximo aí é que vai ser... Vai ser a geração de millennial. Tá, mas voltemos para cá, esquecendo as gerações. Até 2012, tá certo. Então, vamos... Então, por exemplo, se um trechinho em C eu quisesse fazer, né? Esse trechinho aqui: `int A, B, C;`. Isso aqui está fazendo o quê? Para quem não conhece C, isso aqui está declarando que eu tenho três variáveis com os nomes A, B e C. Tá? E que são do tipo inteiro. O tipo inteiro significa que eles são armazenados em 32 bits. Tá? Então, esse `int` aqui significa que cada variável dessas é uma word. Ok? E eu quero fazer `A = B + C;`. Tá? Então, como é que se faz isso aqui em assembly? Depois a gente vê como é que passa de variável para registrador, tá? Então, para a gente fazer essa soma, eu preciso primeiro que todos os meus dados estejam em registradores. Porque, no tipo R, todos os operandos são registradores. Então, eu vou associar aqui rapidamente. Vou dizer que o A corresponde ao registrador S0. B corresponde ao registrador S1. E C ao registrador S2. Então, isso aqui é o que a gente chama de associação de variáveis aos registradores. Quem faz isso é o compilador. Certo? Então, no nosso caso, o que a gente está fazendo aqui? Quando eu estou passando dessa linguagem para essa linguagem, o que eu estou fazendo? Eu estou fazendo uma compilação. Estou passando de uma linguagem de um mais alto nível para assembly. Certo? Então, eu estou fazendo as vezes do compilador. O compilador aqui sou eu. Então, eu estou associando a variável A ao registrador S0, a variável B ao S1, e a variável C ao S2. Então, para executar esse comandinho em C, o que eu preciso fazer? `ADD S0, S1, S2`. Então, a instrução `ADD` faz a soma. Certo? Os operandos são o S1 e o S2. Sempre nessa ordem aqui. E o destino é o S0. Certo? Ele vai somar o S1 com o S2 e colocar o resultado em S0. Ok? Compreendido isso, pessoal? Dúvidas? Dúvidas? Lembrem-se, quando vocês tiverem dúvidas, escrevam no Notepad. Depois, Ctrl+C, Ctrl+V aqui. Sem dúvidas. Então, vamos continuar.\n\nEntão, esse aqui era um exemplinho bem simples. Vamos fazer aqui um exemplinho um pouquinho mais complicado. Agora, eu tenho cinco variáveis inteiras: F, G, H, I, J. E eu quero calcular quanto é que vale `F = G + H - (I + J)`. Eu estou apontando aqui, não estou riscando. Então, vocês não sabem onde é que eu estou falando. Então, eu tenho cinco variáveis: F, G, H, I, J. E eu quero calcular isso aqui. Beleza? Então, primeiro. Primeira coisa que se faz: se associa as variáveis aos registradores. Então, nesse caso aqui, eu estou associando o registrador S1 à variável G, S2 ao H, S3 ao I, S4 ao J e S0 ao F. Essa é a associação que eu estou fazendo. Então, para a gente calcular `G + H - (I + J)`, como os nossos argumentos estão sempre nessa ordem, eu só posso fazer a operação com dois números. Eu não consigo fazer uma operação com quatro números, que é o que isso aqui está pedindo. Então, eu vou ter que dividir essa operação em duas ou mais. Então, nesse caso aqui, eu vou seguir a ordem dos parênteses. Então, primeiro eu vou calcular G mais H. Depois, eu vou calcular I mais J. E esses dois resultados eu vou subtrair para dar o resultado em F. Certo? Então, como é que eu faço G mais H? G é o S1, H é o S2. Então, eu vou fazer `ADD T0, S1, S2`. E o resultado de G mais H? Me interessa para o programa principal? O programa principal vai precisar desse resultado de G mais H? Não, né? Ele precisa só do `G + H - (I + J)`. O `G + H`, então, é um resultado intermediário, um resultado temporário. Então, eu vou armazenar no registrador temporário T0. Porque é um resultado que me interessa, mas eu preciso dele. Depois, I mais J. Então, é esse caso aqui: S3 somado com S4, para dar o resultado de I mais J. Vou armazenar onde? No registrador temporário também. Então, está aqui, T1. Certo? E agora, eu preciso fazer, então, esse resultado menos esse resultado. Então, `SUB S0, T0, T1`. T0, que é o `G + H`, menos T1, que é o `I + J`. E o resultado agora me interessa. Vou colocar no registrador S0. Ok? Então, o que antes aqui era uma linha de código em C, agora, ele virou três instruções em assembly. Certo? A nossa compilação resultou em três instruções em assembly. Entendido isso, pessoal? Muito isso. Porque se vocês ficam quietos, ou significa que vocês não entenderam nada, ou que vocês entenderam tudo. Qual das duas alternativas? Sim, o quê? Vocês não entenderam nada. Ou não entenderam tudo? Sim. Começou. Sim. Se a gente for mandar para uma função, tem que ser um endereço. Então, a gente tem que ter um endereço. Não, espera. Espera. Não, não. A gente vai chegar em função mais adiante, tá? Aqui, eu quero que vocês entendam essa coisinha básica aqui. Depois, a gente complica as coisas, tá bom? Tá, valeu. Não, eu quero saber se vocês entenderam essa coisinha básica aqui, né? De como se faz a compilação de um código de alto nível para assembly. Então, a compilação de um código de alto nível para assembly. Então, repetir. Ok. Então, vou pegar e vou repetir só esse mais básico, porque eu prefiro repetir esse outro mais complicado. Sim, sempre são os S's e T's para fazer contas, S's e T's, porque os outros são registradores de argumentos, que a gente não vai usar agora por enquanto, e os outros são todos ponteiros, que a gente não está usando aqui agora. Tá? Então, sempre aqui a gente vai usar S's e T's. Então, se no meu programa principal eu estou declarando essas variáveis, A, B, C, eu tenho que associar a elas registradores para poder operar. Então, nesse caso aqui, eu vou fazer a associação do A sendo S0, o B do S1 e C do S2. Então, a compilação desse trechinho aqui em cima seria simplesmente `ADD S0, S1, S2`, certo? Porque todas elas são variáveis. São variáveis que eu efetivamente declarei, que eu tenho, já no caso desse aqui mais complicadinho. Se tiver tanta variável que acabam os S's e os T's, a gente vai passar por isso. E o que a gente faz quando acaba? A gente tem somente 32 registradores, vocês já fizeram programas com mais de 32 variáveis? Basta ter um vetor que já é mais do que 32 variáveis, né? Então o que se faz? A gente vai usar a memória. A gente vai ter que armazenar os dados na memória. Então, se você tiver tanta variável que acabar os S's e os T's, tem que usar a memória. Certo? Tudo é variável? Só não? Pelo amor de Deus. Tudo bem. Tá? Vamos então seguir em frente.\n\nComo o RISC-V tem uma arquitetura load/store, então quais são as instruções que leem da memória e escrevem na memória? Aqui a gente vai ter que, se não tivermos S's e T's, a gente vai ter que gravar dados na memória e depois ler os dados da memória. Então as instruções são essas seis aqui, a princípio. Tem mais uma que depois a gente vê. Então, instruções de load. Todas elas começam com L. L de load. Então é load word (LW), load half-word (LH) e load byte (LB). Certo? Então, dependendo de qual é o tipo de variável que vocês querem trabalhar, se for uma word, que é o mais comum para nós aqui, vai ser utilizada então a instrução LW. Certo? Se vocês querem ler somente uma half-word, seriam dois bytes, então LH, load half-word. E se for um byte, LB, load byte. Tá? Então, o que que essa instrução load vai fazer? Ela vai pegar a partir desse endereço aqui (notem que esse aqui é o mesmo para todos), que é calculado como sendo T0 mais 16 (isso aqui é só um exemplo, tá pessoal, T0 mais 16). Então, a `LW` vai ler 32 bits e armazenar no S0. A `LH` vai ler 16 bits, estender o sinal e armazenar no S0. E a `LB` vai ler 8 bits, estender o sinal e armazenar no S0. Depende do teu programa. É o programador que define onde que estão as coisas. Esse número aqui, 16, é isso? Não, isso aí depende do teu programa. Isso aqui é só um exemplo. No teu programa, tu vai ter que ver. Ah, está localizado em tal coisa, tipo 16 mais 3 é isso. Vai ser 16 mais T0 é o endereço de onde eu vou buscar esses dados. Ok? Sim, T0 tem que ser definido. Mas da onde sai esse T0? Calma, vamos estudar primeiro isso, depois a gente pega e vamos fazer um mapeamento de memória para ver quais são as regiões de memória que a gente pode utilizar, para saber quais são os valores de T0 que eu poderia usar aqui, por exemplo. Mas isso só depois que a gente ver como é que é feito o mapeamento de memória. Ok, então isso aqui são instruções de load, instruções de leitura da memória.\n\nEu posso ter instruções de store, né? Então eu posso querer armazenar na memória. Então notem que a sintaxe é a mesma, só muda que aqui é load e aqui é store. Muda só a instrução. Então o que que significa isso aqui? Eu quero armazenar a minha word, os 32 bits desse registrador S0. É bem isso aí mesmo. Deixa essas perguntas para depois, quando chegar nesse ponto aí. Mas a pergunta do Arthur tudo bem. De onde é que vem o valor de T0? É o endereço da memória que a gente vai utilizar. Qual é esse endereço? Só depois do mapeamento a gente vai poder saber. A princípio, a princípio, pode ser qualquer um desses endereços aqui, de 0 até 4 GB. Então o store. Eu quero store word (SW). Eu quero armazenar esses 32 bits na memória a partir desse endereço aqui. Certo? Então dado esse endereço, ele vai pegar os 32 bits de S0 e vai armazenar nos 4 endereços seguintes. Certo? Ah, eu quero armazenar uma half-word. Para double word a gente não tem aqui porque nós estamos utilizando a RV32I. Se a gente estivesse utilizando a RV64I, aí seria load double (LD), store double (SD). Assim. Mas essas instruções LD e SD não existem na RV32, que é o nosso processador de 32 bits. Ok? De 64 bits, tem. Tem mais um aqui, LD, SD. Ok. Se eu quero armazenar uma half-word. Então uma store half-word (SH) que está armazenada em S0 nesse endereço de memória. E eu quero armazenar um byte. Então eu vou pegar a store byte (SB) desse registrador e eu quero armazenar nesse endereço de memória. Ok?\n\nBeleza. Então, geralmente, quando vocês fazem um programa, certo? Seja lá qual for a linguagem que for, onde que estão localizadas as variáveis que vocês definem nesse programa? Pensem lá em APC e ED. As variáveis dos programas estão localizadas onde? Onde que são armazenadas as variáveis dos programas de vocês? Na memória. Justamente aqui. Está lá na memória RAM. Certo? Todas elas estão na memória RAM. Então as variáveis em C, em Python, seja lá qual for a linguagem de programação, estão sempre armazenadas na memória RAM. Então, significa o quê? Que eu vou precisar ler de lá. Então, por exemplo, o valor de B está armazenado na memória RAM. Então eu vou precisar ler lá na memória RAM e colocar dentro desse registrador S1. Eu vou precisar pegar o valor de C que está lá na memória RAM, ler e colocar dentro de S2 para então pegar. E esse valor aqui, o que eu vou ter que fazer? Com ele, com o valor de S0, eu vou ter que armazenar lá na memória RAM. É longe. É longe. Porque demora muito para chegar lá. Mas é verdade. Botou, mas passa dentro. Certo? Então é lá mesmo. Porque demora para chegar lá.\n\nOk. Vamos ver esse exemplinho aqui. `int H;`. Então eu estou declarando. Estou declarando aqui uma variável H. Tem que ser uma variável de 32 bits, né? E aqui eu estou declarando um vetor que eu estou chamando ele de A que tem tamanho de 100. 100 o quê? 100 números inteiros. Ok? Tranquila essa anotação aqui, pessoal? Então eu estou declarando o H como uma variável `int` de 32 bits. E aqui eu estou declarando um vetor de um nome A, certo? De tamanho 100. Significa 100 números `int`s. Já que ele é um vetor de `int`. Ok? Ok. Vocês fizeram ED, né? ED. E está sendo em Python ou em C? Agora bateu essa dúvida. ED é em Python ou em C? É em Python, não é? Meu Deus do céu. Meu Deus do céu. Tudo bem. Pior que o pessoal de rádio não pode nem reclamar disso aí. TP1, meu fã em Java e C++. Tudo bem. Mas TP1 já é para programação de mais alto nível, né? Então faz sentido usar linguagens orientadas a objetos. Porque esse é o objetivo de TP1: apresentar linguagem orientada a objetos. Mas APC e ED, né? Ok. Mas tudo bem. Então entenderam que isso aqui é um vetor que está localizado na memória. Certo? Todos os vetores, seja qual for a linguagem, estão localizados na memória. Certo? E aí vem uma pergunta. Em qual posição da memória está armazenado esse vetor A? É uma variável. Onde que as variáveis são armazenadas? Na memória. Em qual endereço da memória essa variável H está armazenada? Certo? Se vocês souberem um pouquinho... Não. Em que endereço? Esse é um endereço específico. Se vocês souberem um pouquinho de C, o que significa isso aqui: `&H` para quem sabe C? Isso é o endereço de H. Então em C vocês conseguem descobrir qual é o endereço que a variável está na memória. Desse jeito assim. Fazendo o `&H` ele vai te dar qual é o endereço da memória que está o valor de H. Certo? É o ponteiro para aquele endereço lá. Beleza? Aqui A também é onde que está o início desse vetor na memória. Então A, assim como isso aqui. O A por si só já é um ponteiro. Certo? Então o que significa o A sozinho? Se eu desse um `print` no A ele vai me retornar qual é o endereço da memória que começa esse vetor A. Certo? Já que o vetor A é de 100 elementos, vai ocupar vários bytes da memória. Então o A ele te indica qual é o endereço inicial. Ok? Entendido isso, pessoal? Ótimo!\n\nEntão, o que eu quero fazer aqui, então esse aqui é o ponteiro que corresponde ao endereço inicial do vetor na memória. O endereço do primeiro elemento. Certo? O primeiro elemento está localizado no endereço A. Certo? Ok. E eu quero calcular então essa expressão aqui: `A[12] = A[8] + H;`. Eu quero ler o elemento A[8] que está lá na memória, somar com a variável H que eu já associei ao registrador, e essa soma eu quero colocar no elemento A[12]. O A[12] está localizado aonde? Lá na memória. Certo? Porque o ponteiro do vetor está lá na memória. Então como é que nós vamos fazer isso? Ok, então a primeira coisa que tem que fazer é a associação de variáveis. Quantas variáveis a gente tem aqui? Duas variáveis. A gente tem o H e o A. São duas variáveis. Então eu vou associar o H ao S0 e o A eu vou associar ao S1. Então o S0 vai ter o valor de H (que veio) da memória, e aqui o S1 vai ter o valor de A, que é o ponteiro, que é o endereço. Certo? O S1 vai ter o endereço, o início do vetor lá da memória. Beleza. Então para executar essa linhazinha de comando aqui, o que eu preciso fazer? Então a primeira coisa, pegar o endereço A[8]. Vou desenhar aqui a memória. E o pior, eu vou desenhar a memória aqui já considerando que eu estou armazenando inteiros, que significa múltiplos de 4. Certo? Então esse aqui é o endereço 0, esse aqui é o endereço 4, o endereço 8, o endereço 12, o endereço 16, o endereço 20 e assim por diante. Ok? Eu vou considerar que o meu A começa nesse endereço aqui. Então esse aqui é meu A. Então o A, o valor dele é 4. É onde começa. Certo? Então esse aqui seria o A[0]. Esse aqui seria então... Eu tenho 32 bits aqui. Só para eu não fazer um monte de bagunça. Estou considerando o endereço 0. Tem 32 bits. Ok. Qual é o próximo endereço que eu posso armazenar? É o endereço 4. Então mais 32 bits. O próximo endereço é o endereço 8. Mais 32 bits. Só para facilitar o desenho da memória. Tá, pessoal? Mas a nossa memória é byte-addressable. Cada endereço corresponde a um byte. Ok. Então no endereço 8 eu vou ter o A[1]. No endereço 12 o A[2]. No endereço 16 o A[3]. No endereço 20 o A[4]. Ok, assim continua. Beleza? Entenderam essa minha representação aqui da memória? Como eu tenho um vetor de inteiros na memória, ao invés de eu fazer o endereço 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, e assim por diante, os endereços já múltiplos de 4. Para que cada uma dessas caixinhas aqui da memória eu tenha um elemento. Só para facilitar a representação. Entendido isso, pessoal? Repete aí, professor. Não entendi muito não. Aqui. Essa aqui é a nossa memória. Certo? Se eu quero armazenar uma word nessa memória em um endereço 0, eu vou utilizar o endereço 0, o endereço 1, o endereço 2 e o endereço 3 para eu ter 32 bits aqui. Ok? Então com isso eu tenho um inteiro no endereço 0. Qual é o endereço que eu vou poder utilizar em seguida? O próximo endereço que eu posso utilizar é o endereço 4. Eu vou utilizar esses 4 bytes aqui para armazenar o dado. O próximo endereço que eu vou utilizar agora é o endereço 8, que eu vou utilizar para armazenar o dado. Significa, hoje, os dados têm que estar alinhados. Os dois últimos bits têm que ser 0. Ok? Só que ao invés de eu escrever dessa maneira aqui com o endereço 0, 1, 2, 3, 4, 5, 6, 7, 8, eu estou compactando. Eu estou compactando que tudo isso aqui é endereço 0, tudo isso aqui é endereço 4, tudo isso aqui é endereço 8 e assim por diante. Ok? Entendido, pessoal? Só para ser uma representação mais compacta aqui.\n\nEntão, vamos supor que o meu A está no endereço 4. Então, o A[0] está no endereço 4. Então, o A[0] está localizado nesses 32 bits. O A[1] está localizado nesses 32 bits, corresponde ao endereço 8, 9, 10, 11. Certo? Então, a partir do endereço 12, vai ocupar o 12, 13, 14 e 15. O próximo, a partir do 16: 16, 17, 18 e 19. Ok? Beleza. Então, vamos... Eu preciso ler o elemento A[8]. Porque o A[8] é o nono elemento desse vetor. Por isso que, para não causar confusão, eu escolhi o elemento A[8]. Qual é o endereço que está o A[8]? Qual é o endereço disso aqui? Em que endereço está esse elemento A[8]? É só vocês seguirem aqui. Vem o A[0], depois de 4, vem o A[1], depois de 4, vem o A[2], depois de 4, vem o A[3], depois de 4, vem o A[4]. Então, o A[8] vai estar em que endereço? 36? Ok. Agora que eu tenho definido o A, vamos fazer o seguinte. Aqui, o A está definido como 4. Certo? Mas, o A poderia ser qualquer valor. Ai, meu Deus. Cadê o meu mouse? Nesse exemplo aqui, eu coloquei o A valendo 4. No meu programa, eu não sei qual é o valor do A. Concorda? Eu sei que ele está na memória. Mas, eu não sei se o A é 4, se o A é 1356, qual é o valor do A. Então, eu vou ter que achar o endereço desse aqui que seja genérico. Então, por exemplo, o A[I] está em qual endereço? A[I] vai estar no endereço A mais 4 vezes K (onde K é o índice). Então, se eu quero o endereço A[0], o endereço do primeiro elemento, qual vai ser? Vai ser o A mais 4 vezes 0, que dá o próprio A. Então, o A é o próprio endereço do primeiro elemento. O endereço do elemento A[1] vai ser A mais 4. O endereço do elemento A[2], o A mais 8. A mais 12. A mais 16. Então, o elemento A[K] vai estar no endereço A mais 4 vezes K. Por que 4? Porque são todos inteiros. E inteiros são 32 bits. 32 bits, a gente precisa de 4 bytes para armazenar. Certo? Então, eu consigo achar o valor de qualquer elemento A. O endereço de qualquer elemento desse vetor bastando fazer essa continha aqui. Pegar o endereço inicial, pegar o índice do vetor, que é o K, e multiplicar por 4 e somar. Ok? Entenderam isso, pessoal? Entenderam isso? É justamente por isso que eu não coloquei o A começando no 0 aqui, para não causar confusão. Se o nosso A fosse 0, não precisaria entrar nessa continha. O endereço A[8] vai ser igual ao quê? Esse endereço A[8] vai ser igual ao A mais 4 vezes 8. Certo? Então, vai ser o A mais 32. Certo? Beleza. Então, eu quero ler esse endereço. Então, eu vou fazer uma `LW`. Quem é o A? O A é o registrador S1. Então, S1 contém esse endereço inicial. Então, daqui eu vou ler de `32(S1)`, que é o A mais 32. Então, é isso que essa representação `offset(registrador)` colabora bastante. Porque eu quero o A mais 32. Então, `32(S1)`. Então, S1 está associado ao A. Então, eu vou ler do endereço `S1 + 32`. Tranquilo isso? Porque eu quero ler do A mais 32. Certo? Eu vou ler esse número lá da memória. Vou colocar ele aonde? O A[8] me interessa? Não, me interessa para fazer essa conta. Então, eu vou colocar isso aqui dentro de um registrador temporário. Qual? Qualquer um que esteja sendo utilizado. T0, por exemplo. Certo? Então, eu vou ler desse endereço aqui, que é o A[8]. Aí, colocar dentro do registrador T0. Então, T0 agora contém o A[8]. O que eu preciso fazer? Somar isso com o H. Então, `ADD T0, S0, T0`. O S0, que é o H, com o T0, que é o valor que eu li do A[8]. Vou colocar esse resultado aonde? Eu posso colocar em qualquer lugar. Vou colocar no registrador temporário. Que pode ser o próprio T0. Eu não preciso mais do valor do T0 aqui. Então, vou armazenar no próprio T0. Então, agora, T0 contém o que? T0 contém o valor de H mais o A[8]. Certo? E o que eu preciso fazer com esse valor de H mais A[8]? Eu preciso armazenar nesse endereço aqui, no A[12]. Então, qual é o endereço do A[12]? O endereço do A[12] vai ser o A mais 4 vezes 12. Então, A mais 48. Certo? Então, eu vou dar um `STORE WORD` desse valor aqui, que está em T0, nesse endereço: `48(S1)`, que é o A mais 48. Complicado, pessoal? Dúvidas?",
        "video_source": "OAC_2022-01-31.mp4"
    },
    {
        "id": 9,
        "timestamp_start": 6339.77,
        "timestamp_end": 6736.33,
        "slide_description": "O slide apresenta o tema \"Arquitetura RV32I - Instruções de acesso à memória\" no contexto da disciplina \"Organização e Arquitetura de Computadores\" da Universidade de Brasília (UnB), ministrada pelo Prof. Marcus Vinicius Lamar.\n\nO conteúdo textual é dividido em seções sobre instruções de `LOAD` e `STORE` e um exemplo de manipulação de variáveis em C traduzido para Assembly RV32I.\n\n**Instruções de Acesso à Memória:**\nAs instruções de acesso à memória são categorizadas em `LOAD` (carregar dados da memória para um registrador) e `STORE` (armazenar dados de um registrador para a memória).\nExemplos fornecidos para diferentes tamanhos de dados:\n*   **word (palavra, 4 bytes):**\n    *   `LOAD`: `lw s0, 16(t0)` - Carrega uma palavra do endereço `16 + (conteúdo de t0)` para o registrador `s0`.\n    *   `STORE`: `sw s0, 16(t0)` - Armazena o conteúdo do registrador `s0` no endereço `16 + (conteúdo de t0)`.\n*   **half-word (meia-palavra, 2 bytes):**\n    *   `LOAD`: `lh s0, 16(t0)` - Carrega uma meia-palavra do endereço `16 + (conteúdo de t0)` para `s0`.\n    *   `STORE`: `sh s0, 16(t0)` - Armazena o conteúdo de `s0` (os 16 bits menos significativos) no endereço `16 + (conteúdo de t0)`.\n*   **byte (1 byte):**\n    *   `LOAD`: `lb s0, 16(t0)` - Carrega um byte do endereço `16 + (conteúdo de t0)` para `s0`.\n    *   `STORE`: `sb s0, 16(t0)` - Armazena o conteúdo de `s0` (os 8 bits menos significativos) no endereço `16 + (conteúdo de t0)`.\n\n**Variáveis em C e Acesso à Memória RAM:**\nO slide enfatiza que variáveis em C são armazenadas na memória RAM. Um exemplo prático é dado para ilustrar a tradução de código C para Assembly RV32I:\n\n**Código C:**\n```c\nint h;\nint A[100];\nA[12] = h + A[8];\n```\n\n**Representação em Assembly RV32I:**\nAssume-se que:\n*   `h` está armazenado no registrador `s0`.\n*   O endereço base do array `A` (`&A`) está no registrador `s1`.\n*   Inteiros (`int`) ocupam 4 bytes.\n\nA instrução `A[12] = h + A[8];` é traduzida para:\n1.  `lw t0, 32(s1)`: Carrega o valor de `A[8]` para o registrador temporário `t0`. O offset `32` é calculado como `8 * 4 bytes` (índice 8 vezes o tamanho de um inteiro).\n2.  `add t0, s0, t0`: Soma o valor de `h` (em `s0`) com o valor de `A[8]` (em `t0`), armazenando o resultado novamente em `t0`.\n3.  `sw t0, 48(s1)`: Armazena o resultado da soma (em `t0`) na posição `A[12]` da memória. O offset `48` é calculado como `12 * 4 bytes`.\n\n**Diagrama de Memória:**\nUm diagrama visual representa a organização de um array `A` na memória RAM. É uma representação de memória segmentada verticalmente, com endereços de byte mostrados à esquerda e o mapeamento dos elementos do array à direita:\n*   Endereço `0`: `A[0]`\n*   Endereço `4`: `A[1]`\n*   Endereço `8`: `A[2]`\n*   Endereço `12`: `A[3]`\n*   Endereço `16`: `A[4]`\n*   Endereço `20`: ... (continua)\nCada célula no diagrama ocupa 4 bytes, ilustrando que um `int` consome uma \"palavra\" de 4 bytes, e os endereços são de byte em byte (byte-addressable memory), daí o incremento de 4 entre os endereços de elementos consecutivos.\n\nEm resumo, o slide aborda as instruções fundamentais de acesso à memória (LOAD/STORE) para diferentes granularidades de dados na arquitetura RISC-V de 32 bits (RV32I), e demonstra como um trecho de código C que manipula um array e uma variável é mapeado para instruções Assembly, com cálculos de offset baseados no tamanho dos tipos de dados e no endereço base do array.",
        "transcription": "Dúvidas a respeito disso aqui, pessoal? O professor só está botando na minha cabeça: a gente está colocando no T0 o que está em H, né? Não. O H está em S0. O H está em S0. O A[8], quer dizer, né? Isso. O A[8] eu estou colocando nessa linha de `load word` (`lw`) `t0, 32(s1)` e estou carregando, então, o A[8] no T0. Cadê? Aqui. Isso aqui. Aqui eu estou carregando o A[8] no T0. Isso. S1 está associado ao `A`. Foram essas associações aqui que a gente fez: o S0 ao `h` e S1 ao `A`. Se fosse carregar o A[0], não seria `lw t0, 0(s1)`? Para indicar que o offset efetivamente é zero. Mais dúvidas, pessoal? Sobre isso aqui. Nenhuma dúvida. Como sempre, escrevam no Notepad, abrindo e depois do encontro você vê com tranquilidade. OK. Tranquilo. Além dessa aula, tem outros semestres também, que vocês podem ver, porque eu explico isso aqui, mas não desse jeito. Pode ter explicado um pouquinho diferente. Desenho um pouco diferente. Coisa do tipo. Entendi. Porém, eu fiquei meio confuso com qual seria a utilidade do `half-word`? Quando se usa `half-word` ou `word`? Geralmente, tu usa `word`, tá? `Half-word`, tu usa quando tu precisa reduzir o teu espaço de dados. Então, no `half-word`, são só dois bytes. Se a tua aplicação precisa que tu economize e dois bytes forem suficientes, aí tu usa `half-word`. Certo? É pra economizar. Então, se você usou esses registradores de 32 bits, ou só agrupou um de 8, eu fiquei meio confuso. Não. Todos os registradores aqui são de 32 bits. O que é de 8 é que cada endereço da memória armazena 8 bits. Isso. O resultado está armazenado na memória por causa dessa instrução aqui: `store word` (`sw`). Daí eu botei lá na posição do A[12]. Registrador não é 32 bits? É. Registrador é 32 bits de tamanho. Tem provas anteriores, tem livro, tá? Mas isso aqui é um conceito básico, acho, para ter. Exercício. Professor, se não fosse um vetor, o `A[100]` ali no caso, não fosse um vetor, fosse só um inteiro, tu ia colocar zero entre parênteses S1 também? Espera aí, tu tá querendo definir um inteiro? É isso? Ao invés de ter um vetor `A[100]` ali, é um inteiro que está na memória e eu quero carregar ele. OK. É que a gente não viu. Eu estou passando por essa parte de como que eu carrego esses valores aqui, um `int h` e um `int A`. O `A` ali é um inteiro, tá? Que está no endereço `A`. Esse aqui está no endereço `H`. Então, o que que teria que se fazer a princípio? Teria que dar um `load word`, por exemplo, da S... Vou fazer com `h`, tá? Da S0 do endereço... Bom, e agora esse endereço aqui, qual é? Esse é uma das grandes coisas. Isso aqui está numa tabela de endereços. Então, o montador, ele sabe qual é esse endereço. Tá? Então, vamos botar aqui zero. Agora, `lw s0, 0(t0)`, por exemplo. Onde `t0` seja o endereço de onde que está o `h`. Tá? Vamos supor. Ah, o `h` está aqui. No endereço 40. Aqui está o `h`. Beleza. Então, eu vou aqui no endereço 40. 40 mais zero. Que eu sei que o `h` está aqui no endereço 40. Então, eu preciso definir onde é que está o `h`. Certo? Aqui é assim como aqui eu precisaria definir qual era esse endereço base S1. Que eu não defini aqui. Eu defini qual era o endereço do A[8], do A[12], o que quer que seja a posição da memória do `A`. Acho que é isso que está te deixando confuso. Eu não cheguei a ler qual era... ler o `h` da memória e armazenar em S1. A gente não fez isso. Tá? E é isso que tu está perguntando, né? É, é. Exato. Tá? Então, o compilador, quando faz isso, ele vai gerar uma tabela dizendo: o `A` está em tal endereço, o `B` está em tal endereço, o `C` está em tal endereço. Tá? Então, no nosso caso aqui, como é genérico, eu não tinha feito nada. Simplesmente eu disse, olha, o `h` está definindo o conteúdo de `h` está aqui. Como que eu coloquei o conteúdo de `h` aqui, tá? Não mostrei. Sabe que não está mostrado aí. Assim como eu também não mostrei como que eu coloquei um `A` aqui em S1. Esse `A` aqui em S1. Também não mostrei. Então, OK. Beleza, pessoal. Vamos terminar por aqui. Daí na aula que vem a gente...",
        "video_source": "OAC_2022-01-31.mp4"
    },
    {
        "id": 10,
        "timestamp_start": 6736.33,
        "timestamp_end": 6765.68,
        "slide_description": "Como Engenheiro de Computação Sênior, analiso o slide apresentado no contexto de uma aula de Arquitetura de Computadores. O conteúdo principal do slide foca em **Arquiteturas RISC-V**, especificamente na implementação de **instruções com operando imediato**.\n\n**Conteúdo do Slide:**\n\n1.  **Cabeçalho da Apresentação:**\n    *   \"Unb - CICO099 - Organização e Arquitetura de Computadores\"\n    *   Logotipo da \"Universidade de Brasília\"\n    *   \"Departamento de Ciência da Computação\"\n    *   \"CICO099 - Organização e Arquitetura de Computadores\"\n    *   \"Prof. Marcus Vinicius Lamar...\" (nome do professor parcialmente visível).\n\n2.  **Título Principal:** \"Arquiteturas RISC-V\"\n\n3.  **Subtítulo:** \"Instruções com operando Imediato\"\n\n4.  **Pontos Chave e Exemplos:**\n    *   Primeiro ponto: \"Instruções tipo-I: Imediato\" – Este ponto indica que a discussão é sobre o formato de instrução Tipo-I do RISC-V, que é caracterizado pelo uso de um valor imediato (constante) diretamente na instrução.\n    *   Segundo ponto: \"É comum a operação com constantes, logo agilize!\" – Enfatiza a eficiência e a frequência do uso de constantes em operações computacionais, justificando a inclusão de operandos imediatos para otimizar o desempenho.\n    *   Terceiro ponto: \"Exemplo:\" – Apresenta um cenário prático em C e sua tradução para Assembly RISC-V.\n        *   **Código C:**\n            ```c\n            int a,b;\n            b++;\n            a=b-37;\n            ```\n            Este código declara duas variáveis inteiras, `a` e `b`, incrementa `b` em 1 e então subtrai 37 de `b`, armazenando o resultado em `a`.\n        *   **Código RISC-V:**\n            ```assembly\n            addi s1,s1,1\n            addi s0,s1,-37\n            ```\n            A tradução para RISC-V utiliza a instrução `addi` (add immediate).\n            *   `addi s1,s1,1`: Esta instrução incrementa o registrador `s1` em 1, simulando `b++`. Assumindo que `b` está mapeado para `s1`.\n            *   `addi s0,s1,-37`: Esta instrução adiciona -37 ao conteúdo do registrador `s1` e armazena o resultado em `s0`, simulando `a=b-37`. Assumindo que `a` está mapeado para `s0`.\n\n5.  **Observação Importante:**\n    *   \"Obs.: Nesta arquitetura não existe subi !\" – Esta observação destaca uma característica específica da ISA (Instruction Set Architecture) RISC-V, que é a ausência de uma instrução explícita de subtração imediata (`subi`). Em vez disso, a subtração de uma constante é realizada através da adição de um valor imediato negativo (`addi rd, rs1, -imm`).\n\n**Diagramas:**\nO slide não contém diagramas de fluxo de dados, pipeline ou hierarquia de memória. O foco é exclusivamente na apresentação de conceitos textuais e exemplos de código.\n\n**Resumo para Sistema de Busca Semântica (RAG):**\nO slide aborda a implementação de instruções com operando imediato na arquitetura RISC-V (CICO099, UnB). Descreve o formato de instrução Tipo-I, sua importância para operações com constantes visando agilidade, e demonstra com um exemplo de código C (`b++; a=b-37;`) e sua tradução para Assembly RISC-V usando a instrução `addi` (ex: `addi s1,s1,1; addi s0,s1,-37`). Um ponto crucial é a ausência da instrução `subi` em RISC-V, onde a subtração imediata é realizada com `addi` e um valor negativo. O conteúdo é técnico e relevante para tópicos como ISA, Assembly, otimização de código e fundamentos de arquitetura de processadores RISC.",
        "transcription": "Faltam só dois slidezinhos e a gente termina rapidão, ou na aula que vem? Ou vocês têm três minutos aí? Grande, grande. Não, vamos falar isso na aula que vem. Tá? Vamos terminar no horário aqui. Então, ficamos por aqui hoje. Tá? Eu vou tentar consertar esse problema do mouse que realmente eu instalei um monitor no final de semana e não me dei conta que isso podia acontecer. Então, vou parar as gravações. Parei aqui.",
        "video_source": "OAC_2022-01-31.mp4"
    }
]