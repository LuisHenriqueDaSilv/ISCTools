[
    {
        "id": 1,
        "timestamp_start": 0.0,
        "timestamp_end": 41.1,
        "slide_description": "Como Engenheiro de Computação Sênior, analisei o slide e o conteúdo anotado da aula de Arquitetura de Computadores.\n\nO material central exibido é um documento intitulado \"Cronograma das Aulas\", parte da disciplina \"CIC0099 - Organização e Arquitetura de Computadores\" da \"Universidade de Brasília\", ministrada pelo \"Prof. Marcus Vinicius Lamar\". O nome do arquivo visível é \"OAC_A_Plano_2021_2_v0.docx\".\n\nO cronograma está organizado em uma tabela com as seguintes colunas: \"Sem\" (Semana), \"Dias\" (Datas), \"Segunda\" (Conteúdo da aula de segunda-feira) e \"Quarta\" (Conteúdo da aula de quarta-feira, embora alguns tópicos possam ocorrer em outros dias da semana ou serem laboratórios). Os tópicos incluem referências a capítulos (C.x), aulas teóricas (Tₓ), laboratórios (Lₓ) ou provas (Pₓ).\n\nSegue a transcrição detalhada do cronograma:\n\n*   **Semana 0 (17/1, 19/1):**\n    *   Segunda: Apresentação e 0) Introdução (C.1)\n    *   Quarta: 1) Introdução, abstrações e histórico (C.1)(T₀)\n*   **Semana 1 (24/1, 26/1):**\n    *   Segunda: 2) Desempenho: Fatores (C.1)\n    *   Quarta: 3) Desempenho: Medidas (C.1)(T₁)\n*   **Semana 2 (31/1, 2/2):**\n    *   Segunda: 4) Ling. de Máquina: ISA (C.2)\n    *   Quarta: 5) Ling. de Máquina: Assembly (C.2)(T₂)\n*   **Semana 3 (7/2, 9/2):**\n    *   Segunda: 6) Ling. de Máquina: Procedimentos (C.2)\n    *   Quarta: 7) Ling. de Máquina: Recursividade e I/O (C.2)(T₃)\n*   **Semana 4 (14/2, 16/2):**\n    *   Segunda: 8) Arit. Computacional: Inteiros (C.3)\n    *   Quarta: 9) Arit. Computacional: ULA (C.3)(T₄)\n*   **Semana 5 (21/2, 23/2):**\n    *   Segunda: 10) Arit. Computacional: Fracionários, IEEE 754 (C.3)\n    *   Quarta: 11) Outras Arquiteturas (T₅)\n*   **Semana 6 (28/2, 2/3):**\n    *   Segunda: FERIADO\n    *   Quarta: Lab 1A: Software – Rars (T₆) (Nota: \"Rars\" provavelmente se refere ao RARS - RISC-V Assembler and Runtime Simulator, uma ferramenta comum para ensino de arquitetura RISC-V.)\n*   **Semana 7 (7/3, 9/3):**\n    *   Segunda: Lab 1B: Software – Compilador C\n    *   Quarta: Lab 2: Hardware – Verilog – ULA (T₇)\n*   **Semana 8 (14/3, 16/3):**\n    *   Segunda: 1ª Prova (P1)\n    *   Quarta: 12) Processador Uniciclo: Unidade Operativa (C.4) (T₈)\n*   **Semana 9 (21/3, 23/3):**\n    *   Segunda: 13) Processador Uniciclo: Unidade de Controle (C.4) (L₁)\n    *   Quarta: Lab 3: Processador Uniciclo (T₉) (L₁)\n*   **Semana 10 (28/3, 30/3):**\n    *   Segunda: 14) Processador Multiciclo: Unidade Operativa (C.4)\n    *   Quarta: 15) Processador Multiciclo: Unidade de Controle (C.4) (T₁₀)\n*   **Semana 11 (4/4, 6/4):**\n    *   Segunda: Lab 4: Processador Multiciclo\n    *   Quarta: 16) Processador Pipeline: Conceitos (C.4) (T₁₁)\n*   **Semana 12 (11/4, 13/4):**\n    *   Segunda: 17) Pipeline: Unidade Operativa e Controle (C.4)\n    *   Quarta: Lab 5: Processador Pipeline (T₁₂)\n*   **Semana 13 (18/4, 20/4):**\n    *   Segunda: 18) Exceção e Interrupção (C.4) (L₃)\n    *   Quarta: 19) Memória: Hierarquia (C.5)\n*   **Semana 14 (25/4, 27/4):**\n    *   Segunda: 19.1) Memória: Cache (C.5)\n    *   Quarta: 2ª Prova (P2) (L₄)\n*   **Semana 15 (2/5, 4/5):**\n    *   Segunda: Prova Substitutiva\n    *   Quarta: Apresentação dos Projetos (P₃) (T₁₅)\n\nNão há diagramas de datapath, pipeline ou hierarquia de memória visíveis neste slide; o conteúdo é predominantemente textual, focado na ementa e cronograma da disciplina.\n\nA janela de chat (\"Bate-papo público\") contém mensagens relevantes para o contexto da aula: \"Bem vindos à sala de aula de OAC!\", \"Esta sessão está sendo gravada.\", e uma mensagem de aluno \"hj é lab\", o que indica que a aula atual pode ser um laboratório, possivelmente o \"Lab 1A: Software – Rars\" ou \"Lab 1B: Software – Compilador C\", ou outro laboratório previsto no cronograma.",
        "transcription": "Então tá, agora eu tô gravando os dois lugares e espero que esteja tudo com áudio. Então vamos lá, então boa tarde pessoal, vamos dar mais uma aulinha de OAC, hoje é dia 2 de março, né, 2 de março já, estamos quase chegando na metade do curso, né, então hoje é para ser a primeira parte do Laboratório 1. O Laboratório 1 é dividido em duas partes, Parte A e Parte B, né, quando a gente vai começar então com software, né, e a parte 2 começa então o hardware, tá? Então hoje a gente vai ver o software RARS, né, e na aula que vem como é que funciona o compilador C, né, o que que é que ele te gera.",
        "video_source": "OAC_2022-03-02.mp4"
    },
    {
        "id": 2,
        "timestamp_start": 42.36,
        "timestamp_end": 56.52,
        "slide_description": "A imagem exibe um slide de abertura de uma aula de Arquitetura de Computadores, apresentada em um ambiente de conferência web. O conteúdo principal do slide é uma introdução à ferramenta \"Rars\".\n\n**1. Transcrição de Texto:**\n\n*   **Cabeçalho da Instituição (superior esquerdo do slide):**\n    *   \"Universidade de Brasília\"\n    *   \"Departamento de Ciência da Computação\"\n*   **Identificação da Disciplina e Professor (superior direito do slide):**\n    *   \"Universidade de Brasília\" (com um logo menor e diferente)\n    *   \"CIC0099 - Organização e Arquitetura de Computadores\"\n    *   \"Prof. Marcus Vinícius Lamar\"\n*   **Título Principal do Slide (fundo azul):**\n    *   \"Rars\"\n    *   \"RISC-V Assembler and Runtime Simulator\"\n*   **Conteúdo do Bate-papo Público (painel esquerdo, parcialmente visível):**\n    *   **Mensagens sobre áudio/presença:**\n        *   \"Ualiton Ventura da Silva 13:57 pq no meio da aula ia ser complicado kkkkkkk e não tô dando conta de ouvir\"\n        *   \"Ualiton Ventura da Silva kkkkkkkkkk deu pra ler os lábios\"\n        *   \"Ualiton Ventura da Silva 13:58 vocês estão ouvindo o professor?\"\n        *   \"João Alberto Travassos Ev... (offline) 13:58 ainda não estou ouvindo\"\n        *   \"Marcus Vinícius Lamar (offline) 13:59 Vou sair e reentrar\"\n        *   \"João Alberto Travassos Ev... (offline) 13:59 isso\"\n        *   \"Victor Hugo França Lisboa 14:00 Boa tarde\"\n        *   \"O que houve?\"\n        *   \"Ualiton Ventura da Silva 14:01 cê tá ouvindo o professor?\"\n        *   \"Ualiton Ventura da Silva 14:01 e boa tarde\"\n        *   \"Ualiton Ventura da Silva 14:01 aeeeee\"\n        *   \"sim\"\n        *   \"Victor Hugo Rodrigues Fernandes 14:02 Agora sim.\"\n        *   \"João Alberto Travassos Evangelista 14:02 BELE\"\n        *   \"João Alberto Travassos Evangelista 14:02 hj é lab\"\n    *   **Informações da aula/plataforma:**\n        *   \"Bem vindos à sala de aula de OAC!\"\n        *   \"Esta sessão está sendo gravada.\"\n        *   \"Para mais informações, clique aqui. Novo na plataforma? Experimente o tour!\"\n*   **URL da Conferência:** `live-aws034.mconf.rnp.br/html5client/join?sessionToken=ye0pskku9bw3gdlr`\n*   **Identificação da Sala:** \"Sala de Aula de OAC\"\n*   **Tempo da Sessão:** \"01:31\"\n\n**2. Descrição de Diagramas/Estruturas Visuais:**\n\nO slide exibido não contém diagramas técnicos de arquitetura de computadores, como datapath, pipeline, ou hierarquia de memória. O design de fundo na seção azul do slide é composto por um padrão quadriculado decorativo em tons de azul e cinza, que não representa uma estrutura lógica ou fluxo de dados. Os logos institucionais da Universidade de Brasília são apresentados em duas variantes: uma versão maior e mais elaborada em verde e branco na parte superior esquerda, e uma versão menor e simplificada, acompanhada do nome por extenso, na parte superior direita.\n\n**3. Ignorando Elementos de UI/Logos Irrelevantes:**\n\nElementos como os botões de navegação do navegador (setas, recarregar), a barra de pesquisa, ícones da conta do usuário, controles de áudio/vídeo da plataforma de conferência, e a lista de usuários participantes do chat, foram deliberadamente ignorados por serem parte da interface da ferramenta e não do conteúdo didático em si. A imagem do professor em miniatura no canto inferior direito também foi desconsiderada como conteúdo do slide, sendo apenas a representação visual do palestrante.",
        "transcription": "Então, antes da gente começar, né, vamos dar uma pequena revisãozinha, né, sobre o que que é o RARS, né, o RISC-V Assembler,",
        "video_source": "OAC_2022-03-02.mp4"
    },
    {
        "id": 3,
        "timestamp_start": 56.76,
        "timestamp_end": 785.32,
        "slide_description": "O slide, parte de uma aula de \"Organização e Arquitetura de Computadores\" (CIC0099) da Universidade de Brasília (UnB), ministrada pelo Professor Marcus Vinicius Lamar, aborda o tema de \"Operações de Entrada e Saída\". O conteúdo principal do slide é um \"Exemplo de Polling no RISC-V\".\n\nA seção de texto descreve a convenção de endereçamento para dispositivos de E/S usando polling:\n*   Um endereço base é armazenado no registrador `s0`.\n*   No endereço `BASE+STATUS`, reside a sinalização (status) do dispositivo.\n*   No endereço `BASE+DATA`, encontra-se o dado enviado pelo dispositivo.\n\nUm trecho de código Assembly RISC-V ilustra a rotina de polling:\n```assembly\nWAIT:   lw   t0, STATUS(s0)  # lê estado do dispositivo\n        andi t1, t0, MASK    # Isola o bit status por MASK\n        beq  t1, zero, WAIT  # se não está pronto repete\n        lw   s1, DATA(s0)    # senão lê o dado para s1\n```\nEste código implementa um loop de espera (`WAIT`) onde o programa repetidamente lê o registrador de status do dispositivo (carregando o valor de `STATUS(s0)` para `t0`). Em seguida, ele isola o bit de status relevante usando uma operação AND imediata (`andi t1, t0, MASK`). Se o bit de status indicar que o dispositivo não está pronto (comparando `t1` com zero), o programa salta de volta para o início do loop (`beq t1, zero, WAIT`). Somente quando o dispositivo sinaliza estar pronto, o programa procede para carregar o dado do dispositivo (lendo de `DATA(s0)` para `s1`).\n\nNão há diagramas de datapath, pipeline ou hierarquia de memória visíveis neste slide. O foco é a demonstração textual e prática, via código Assembly, de um mecanismo de controle de E/S por polling.",
        "transcription": "Runtime Simulation, Simulator. Então, a gente vai utilizar aqui a versão 1.5 Custom 2, que eu corrigi alguns bugs dessa versão 1.5. O autor, se eu não me engano, ele está com a versão mais nova lá, mas ainda não tive tempo de pegar aquela versão e ajustar para os nossos casos aqui. Então, aconselho vocês a usarem essa versão que eu estou disponibilizando na página, ok? Aqui no Aprender. Então, o RARS é uma ferramenta que permite, é uma IDE, né, permite escrever o programa Assembly, montar o código de máquina, executar programas nessas duas ISAs, a RV32 e suas extensões M, F e D, e a RV64 e suas extensões M, F e D, né, e possuir serviços básicos de sistema operacional. E além disso, ele contém várias outras ferramentas. Dessas outras ferramentas aqui, a gente só não vai trabalhar com esse Digital Lab Sim e com esse Timer Tool, porque Timer Tool já está obsoleto e esse Digital Lab Sim existe aí, acho que desde que começou a fazer o MARS, que foi o avô do RARS, e eu acho que ninguém sabe para que que serve esse negócio e o autor tem medo de tirar daí, ok? Então, a gente vai usar todo o resto dessas outras ferramentas. Então, para quem nunca abriu o RARS, né, abram, que a gente vai trabalhar bastante. Então, para quem nunca abriu o RARS, né, abram, que a gente vai trabalhar bastante.\n\nEntão, antes, vamos ver alguma parte teórica em relação a dispositivos de entrada e saída. Bom, a forma que os dispositivos de entrada e saída se comunicam com o processador, mais especificamente o RISC-V, é através de MMIO, né, então Memory Mapped IO. Isso eu já falei, já mostrei como é que é o mapa de memória do RARS, já, né, ok. Eu sempre me confundo, assim, com... Então, a gente pode acessar esses dispositivos de duas formas. Uma é por polling. Quer dizer, o dispositivo está em uma determinada região da memória, e o processador vai, de tempos em tempos, verificar se aquele dispositivo tem algum dado para enviar. Se tiver, ele lê. Se não tiver, então ele simplesmente continua fazendo o que ele está fazendo, ou seja, executando um programa. E de tempos em tempos, ele vai lá ver se o dispositivo quer enviar um dado, ou se ele precisa receber um dado. Então, isso aqui é bem fácil de fazer, é por software, e o problema é que consome muito tempo do processador, porque o processador está executando o programa, e de tempos em tempos, ele tem que ir lá verificar se o hardware quer mandar alguma coisa. Então, há uma perda de tempo do processador.\n\nUma forma mais eficiente é utilizando interrupção. Só que aí a gente precisa... A gente precisa ter mudanças no hardware. A gente vai estudar a interrupção mais depois, quase lá no final. Vamos ver como é que é a implementação disso aqui em hardware. Mas então, como é que seria? O dispositivo... O processador está rodando, e o dispositivo pede para interromper o processador. Então, o processador não fica olhando se ele tem um dispositivo que quer enviar dado. O dispositivo simplesmente interrompe o processador. Então, ao interromper, o processador vai, executa as operações necessárias com o dispositivo. Ele, por exemplo, lê um dado do teclado ou do mouse, e continua fazendo. Quando o dispositivo quer mandar outro dado, ele interrompe novamente o processador, e o processador lê. Então, é mais eficiente do ponto de vista do processador. Ele não perde tempo consultando o dispositivo se ele quer mandar alguma coisa. O problema é que o hardware é um pouco mais complexo. A gente vai ver como é que se implementa isso no RISC-V, mais adiante. E o RARS, ele implementa os dois. O RARS, ele tem isso aqui para utilizarmos por software, mas ele implementa também interrupção por hardware. Então, se vocês tiverem curiosidade, é só procurar informações sobre interrupções no RARS, que ele tem exemplos de como é que se utiliza isso.\n\nO exemplo de polling no RISC-V. Então, a gente vai ter, por exemplo, o endereço de base, onde está o dispositivo, no registrador `s0`. No endereço `BASE+STATUS`, a gente tem a sinalização do dispositivo. Quer dizer, por exemplo, meu dispositivo pode ter o dado que ele quer enviar, e o status, que diz se ele quer enviar um dado ou não. Então, no endereço `BASE+STATUS`, a gente tem a sinalização do dispositivo, indicando que ele quer enviar um dado. E no endereço `BASE+DATA`, a gente tem, efetivamente, o dado que o dispositivo está enviando. Então, aqui está um trechinho que fica fazendo o polling. Então, ele vai ler do registrador `s0`, que é a base, mais o offset `STATUS`, que é um valor imediato (isso aqui), um número imediato que depende do dispositivo, e vai ler isso para `t0`. Então, lê o estado do dispositivo. Mascara o bit que interessa, porque o que ele lê aqui é uma palavra de 32 bits. Desses 32 bits, provavelmente, um bit é o que interessa para saber se o dispositivo quer mandar ou não quer mandar. Então, é necessário mascarar esse bit, isolar o bit, através de mascaramento. O que é o mascaramento? É a aplicação de uma máscara pela operação `AND`. Quer dizer, eu deixo todos os bits dessa máscara zerados, e somente aquele bit que eu quero verificar, ele fica em 1. Então, seleciona apenas um bit. E com a operação `AND` desse valor com a máscara, eu vou verificar. E com a máscara, eu tenho, então, isolado no registrador `t1`, se aquele bit está acionado ou não. Ou seja, ou ele vale 0, ou ele vale um número (que pode ser 1, 2, 4, 8, 16, 32, e assim por diante). Ok, se `t1` for igual a 0, quer dizer que o dispositivo não quer mandar nada. Então, ele volta de novo para a rotina `WAIT` aqui, e fica assim, fazendo o polling o tempo todo, verificando se o dispositivo... se o dispositivo está querendo mandar alguma coisa. Caso contrário, quer dizer, se esse aqui for diferente de 0, é porque tem um dado para ser enviado pelo dispositivo. Então, ele vai ler do endereço `s0` mais o offset `DATA` (data é um imediato, o dado do dispositivo), e vai ler para o registrador `s1`. Certo? Esse aqui é um exemplo simples de polling. Só que aqui o polling está feito diretamente. Quer dizer, ele trava aqui o processador, nesse loop aqui, e não sai mais. Está entendido isso? Dúvidas, pessoal? Isso aqui é o que vocês vão usar, muito provavelmente, para leitura do teclado. Então, vocês vão ter, a gente vai ver como é que faz, temos um dispositivo de teclado, que vocês vão lá, de tempos em tempos, ler. Ou então, programa a ferramenta do RARS para ser por interrupção, e assim, quando tiver uma tecla pressionada, o RARS vai interromper o programa de vocês. Mas esse aqui é o modo mais fácil.\n\nEntão, quais são as ferramentas de E/S que a gente vai utilizar no RARS? Então, embora tenha várias ferramentas, a gente vai utilizar essas três aqui. Por que essas três? Porque quando estávamos no modo presencial, quando vocês implementavam o processador na placa FPGA, essas três ferramentas aqui foram feitas para ser exatamente compatíveis, o RARS e o processador no FPGA. Quer dizer, o mesmo programa que roda no RARS, utilizando essas ferramentas, vai ser executado da mesma forma no processador em FPGA. Só que, no nosso caso, a gente não tem processador em FPGA, e nos interessa aprender a usar isso aqui no RARS. Então, o Keyboard and Display MMIO Simulator. Então, ele permite a entrada por leitura de teclado, que é o que a gente vai utilizar, uma saída em terminal de texto, que é um eco, na realidade, só do teclado, e simula a E/S por polling ou por interrupção. Então, aqui vocês escolhem o que vocês vão utilizar. O Bitmap Display, que é uma saída gráfica em display. Não o VGA, mas um quarto de VGA. VGA é 640x480. Então, um quarto de VGA é 320x240. Então, a resolução é selecionável, mas sempre usa isso aqui. Obviamente, a gente considera essa resolução baixa, porque na placa FPGA a gente tinha essa limitação, certo, de memória, na placa FPGA. Então, a gente tinha que usar essa resolução de 320x240. No entanto, vocês estão usando aqui no RARS. Então, a princípio, vocês não precisam se limitar a isso aqui, certo? A princípio, então, vocês poderiam utilizar uma resolução maior. O acesso direto à memória de vídeo. Quer dizer, o processador acessa diretamente a memória de vídeo. A memória de vídeo é aquilo que o driver do VGA vai ficar lendo e mostrando na tela, certo? Então, essa é a memória de vídeo. O dado é a cor de cada pixel na tela, e o driver de VGA fica lendo essa porção da memória e mostrando no vídeo, certo? E aqui, como a gente não tem GPU, é o processador que acessa diretamente a memória de vídeo, certo? Geralmente, a gente tem uma GPU no meio, que trata essa parte de renderização, que a gente chama. No nosso caso, não. É a própria CPU que vai ter que renderizar a imagem. A gente tem um sintetizador de áudio, né? Então, a saída de áudio sintetizado por MIDI. MIDI é Music Instrument Digital Interface. Então, ele utiliza esse padrão MIDI para gerar sons. Então, a definição do instrumento, nota, duração e volume, vocês conseguem fazer, seguindo esse padrão MIDI, ok? Então, assim a gente vai sintetizar áudio.\n\nEntão, vamos ver eles um pouco mais de perto. Então, o Keyboard Display Simulator. Em que endereço eles estão? Então, nesse RARS 1.5 Custom 2, ele está nesse endereço aqui. Se vocês baixarem o RARS do autor, ele vai estar em outro endereço. Então, cuidem disso. Esse endereço só é este porque a gente está usando o nosso RARS que foi customizado. Então, está nesse endereço aqui: `0xFF200000`. `0xFF200000`. Então, nesse endereço, o que que a gente tem? Aqui a gente tem o que seria o equivalente ao status aqui, certo? Então, o que que é o status? O bit zero indica o status do teclado, se o teclado foi pressionado e quer mandar uma tecla ou não, e o bit 1 define o modo de operação, se é por interrupção ou polling. Então, setando e resetando o bit 1, você define qual é a forma que o teclado vai funcionar. E o endereço `0xFF2004`, que é uma palavra de dados, os oito primeiros bits desse endereço, já que aqui eu posso ler um byte a partir desse endereço, ele contém o código ASCII da tecla que foi pressionada, ok? Então, aqui seria o status e aqui o data, onde efetivamente eu vou ler. Esses outros aqui, que estão em cinza claro, a princípio a gente não precisa usar. Por quê? Porque esse Keyboard Display Simulator, deixa eu ver, achar ele aqui, vou mostrar aqui,",
        "video_source": "OAC_2022-03-02.mp4"
    },
    {
        "id": 4,
        "timestamp_start": 785.46,
        "timestamp_end": 1043.88,
        "slide_description": "O slide apresenta a tela de uma aula online em andamento, identificada como \"ConferênciaWeb - Sala de Aula de OAC\" (Arquitetura de Computadores), com o tempo de 15:53 exibido. A interface inclui um painel de chat à esquerda e a tela compartilhada de um computador, mostrando uma janela do Explorador de Arquivos do Windows, ao centro e à direita.\n\n**Conteúdo do Painel de Chat:**\nO painel lateral esquerdo exibe uma conversa em \"Bate-papo público\" entre alunos e o professor. Mensagens indicam o início da aula e problemas técnicos de áudio:\n*   \"vocês estão ouvindo o professor?\" (Ualiton Ventura Da Silva, 13:58)\n*   \"ainda não estou ouvindo\" (João Alberto Travassos Ev..., 13:58)\n*   \"Vou sair e reentrar\" (Marcus Vinicius Lamar, 13:59)\n*   \"isso\" (João Alberto Travassos Ev..., 13:59)\n*   \"Bem vindos à sala de aula de OAC! Esta sessão está sendo gravada. Para mais informações, clique aqui. Novo na plataforma? Experimente o tour!\" (13:59, mensagem de sistema ou professor)\n*   \"Boa tarde\" (Victor Hugo França Lisboa, 14:00)\n*   \"O que houve?\" (Victor Hugo França Lisboa, 14:00)\n*   \"cê ta ouvindo o professor?\" (Ualiton Ventura Da Silva, 14:01)\n*   \"e boa tarde\" (Ualiton Ventura Da Silva, 14:01)\n*   \"aaaaeee\" (Ualiton Ventura Da Silva, 14:01)\n*   \"sim\" (Ualiton Ventura Da Silva, 14:01)\n*   \"Agora sim.\" (Victor Hugo Rodrigues Fernandes, 14:02)\n*   \"BELE\" (João Alberto Travassos Evangelista, 14:02)\n*   \"fj é lab\" (João Alberto Travassos Evangelista, 14:02)\n*   \"já\" (Filipe de Sousa Fernandes, 14:06)\n*   \"obr prof\" (João Alberto Travassos Evangelista, 14:18)\nA lista de \"USUÁRIOS (27)\" mostra \"Marcus Vinicius Lamar...\" como o apresentador.\n\n**Conteúdo da Tela Compartilhada (Explorador de Arquivos):**\nA tela principal exibe uma janela do Explorador de Arquivos do Windows, navegando até o diretório: `Marcus Vinicius Lamar > Dropbox > kiko > Disciplinas > UnB > OAC > 2021-2 > Lab1`. Isso contextualiza o conteúdo como materiais para a disciplina de Arquitetura de Computadores (OAC) da Universidade de Brasília (UnB), especificamente para o \"Lab1\" do período 2021-2.\n\n**Estrutura do Explorador de Arquivos:**\n*   **Barra de Ferramentas Superior:** Contém abas \"Arquivo\", \"Início\", \"Compartilhar\", \"Exibir\" e botões de ação como \"Recortar\", \"Copiar\", \"Colar\", \"Mover para\", \"Copiar para\", \"Excluir\", \"Renomear\", \"Nova pasta\", \"Novo item\", \"Fácil acesso\".\n*   **Painel de Navegação Esquerdo:** Lista atalhos como \"Acesso rápido\", \"UnB\", \"Documentos\", \"Alunos\", \"Downloads\", \"Projeto-FAPDF-Biomet...\", \"Pesquisa\", \"Área de Trabalho\", \"Google Drive\", \"Este Computador\", e pastas sincronizadas como \"Dropbox\" e \"OneDrive - unb.br\".\n*   **Painel de Conteúdo Principal:** Exibe os arquivos e pastas dentro do diretório \"Lab1\". As colunas visíveis são \"Nome\", \"Data de modificação\", \"Tipo\" e \"Tamanho\".\n\n**Conteúdo do Diretório \"Lab1\":**\nO diretório \"Lab1\" contém uma variedade de arquivos e pastas relevantes para um laboratório de Arquitetura de Computadores:\n*   **Pastas:** \"ArquivosC\", \"exemplos\", \"System\".\n*   **Documentos (Microsoft Word/PDF):**\n    *   `$C_LAB1.docx` (Documento do Mi..., 1 KB)\n    *   `OAC_LAB1.docx` (Documento do Mi..., 190 KB)\n    *   `Lab1-Rars15.pdf` (Adobe Acrobat D..., 4.900 KB)\n    *   `OAC_LAB1.pdf` (Adobe Acrobat D..., 231 KB)\n*   **Apresentações (Microsoft PowerPoint/similar):**\n    *   `~$Lab1-Rars15.pptx` (Apresentação do..., 89 KB)\n    *   `Lab1-Rars15.pptx` (Apresentação do..., 216 KB)\n    *   `lab1-Rars15_appx` (Apresentação do..., 216 KB) - Este arquivo está selecionado. O sufixo \"appx\" pode indicar um formato de apresentação específico ou um arquivo temporário/corrompido de um editor de apresentação. A presença de \"Rars15\" sugere fortemente o uso do simulador RARS (RISC-V Assembler and Runtime Simulator), comum para programação em assembly MIPS ou RISC-V em cursos de OAC.\n*   **Arquivos Compactados (.zip, .rar):**\n    *   `convertallimages.rar` (Arquivo RAR, 9.752 KB)\n    *   `exemplos.zip` (Pasta compactada, 41 KB)\n    *   `FPGRARS-1.1.1.zip` (Pasta compactada, 47 KB)\n    *   `FPGRARS-1.13.1.zip` (Pasta compactada, 78 KB)\n    *   `Lab1.zip` (Pasta compactada, 4.900 KB)\n    *   `System.zip` (Pasta compactada, 2.963 KB)\n    *   Os arquivos `FPGRARS-1.1.1.zip` e `FPGRARS-1.13.1.zip` possivelmente contêm diferentes versões do simulador RARS, que é uma ferramenta fundamental para a disciplina.\n*   **Outros Arquivos:**\n    *   `~WRL2990.tmp` (Arquivo TMP)\n    *   `linhas_compilacao.txt` (Arquivo TXT, 1 KB) - Este arquivo pode conter logs de compilação, instruções ou resultados de exercícios.\n\nA barra inferior do explorador de arquivos indica \"17 itens\", \"1 item selecionado\", \"215 KB\" e uma notificação de \"Due 23 de fevereiro de 2022\", seguida por \"39 de 42 tentativas\", que pode ser um lembrete de prazo para alguma atividade ou submissão relacionada ao Lab1.\n\nNão há diagramas de datapath, pipeline, hierarquia de memória, ou código Assembly/C/Verilog diretamente visíveis neste slide, mas o contexto dos nomes dos arquivos (\"Rars15\", \"linhas_compilacao.txt\", \"ArquivosC\") implica que tais tópicos são parte integrante do material e das atividades do laboratório.",
        "transcription": "Tá, o Keyboard Display Simulator é esse bichinho aqui, esse tool. Ele possui a parte de eco, né, então tudo que a gente clicar vai aparecer aqui um eco, e ele tem esse displayzinho aqui pra vocês poderem escrever nesse displayzinho, mas isso aqui a gente não vai usar. A gente vai usar só a parte de aquisição do teclado, ok? Então, é isso que nos interessa. E essa parte em cinza aqui seria como mostrar coisas naquele displayzinho, tá, status do monitor, então são o pulso do monitor, qual é o caractere, né, qual é o limpa-tela, qual é a posição do caractere naquela tela. Então, só com isso aqui já daria pra fazer um joguinho, né, com letras, tá, então mover uma, uma, uma, uma visinha que seja um asterisco pra lá e pra cá, daria. Mas a gente vai fazer coisa mais complexa que isso, então isso aqui vocês não precisam utilizar, ok? Então, nesse Keyboard Display Simulator, o display aqui a gente não vai utilizar, a gente vai utilizar só o Keyboard. Aqui tá o exemplo, tá, então vocês têm dois exemplinhos, né. Ah, antes de mais nada, eu esqueci o que eu tô falando aqui, vocês devem estar falando e perguntando: \"Pá, o que o professor tá falando aí?\" Eu esqueci e ninguém me falou. Ai, Deus meu, cadê a semana 3? Eu esqueci de abrir isso aqui pra vocês, tá, aqui, ó. Tá, então vão aqui na semana 5, laboratório 1 e abaixem esse `.zip` e deszipem ele na máquina de vocês. Tá, ao deszipar isso aí, vocês vão criar, aqui, vocês vão criar, ah, isso aqui. Tá, vai ter esses arquivos lá dentro. Então, o `lab1.doc`, que é o roteiro do laboratório 1, esse aqui é o `lab1.doc`. É justamente esse PDF que eu tô apresentando pra vocês, tá, é esse aqui. Vocês vão ter arquivos em C, que nós vamos ver na aula que vem, e nós vamos ter o System, tá. Dentro de System, a gente vai ter o RARS, que tá aqui, tá, o Custom 2, e mais um monte de outras coisas que a gente vai utilizar, tá, e tem vários exemplos. Entre esses exemplos, a gente tem o, tá aqui, `keyint` e `keypool`, tá, que são exemplos de como se utiliza a interrupção e como se utiliza o polling, né, do teclado no RISC-V. Então, se a gente abrir aqui, vai ter o códigozinho, né, abrir esse exemplo, o códigozinho do `keyint` e do `keypool`. Tá, o programinha é bem simplesinho, tá, só pra mostrar como é que funciona. Então, isso aí é uma das coisas que eu tinha esquecido, realmente, de mostrar pra vocês logo no início, tá, onde é que tava esse material todo. Então, vamos continuar aqui, tá. Então, tá aqui os dois, o `keypool` e o `keyint`, tá, por polling e por interrupção. Daí vocês podem rodar, né, e ver como é que funciona. Então, essa ferramentazinha, tá, de display em um simulator. Ok, como é que a gente usa isso? Vocês estão acostumados a fazer, no RARS, né, a gente fazer as chamadas do sistema, por exemplo, o serviço 1, o serviço 5 é o `read_int`, o serviço 6 é o `read_float`, o serviço 8 é o `read_string`, o serviço 12 é o `read_char`, certo? Quando a gente queria que...",
        "video_source": "OAC_2022-03-02.mp4"
    },
    {
        "id": 5,
        "timestamp_start": 1045.24,
        "timestamp_end": 3059.32,
        "slide_description": "Como Engenheiro de Computação Sênior, procedo com a análise do slide e do conteúdo da tela, conforme solicitado, para um sistema de busca semântica (RAG).\n\n**Contexto Geral:**\nA imagem apresenta uma tela de aula online de Arquitetura de Computadores (OAC) da Universidade de Brasília (UnB), focada em programação MIPS assembly e simulação, utilizando a ferramenta RARS (MIPS Simulator/Debugger) para manipulação e visualização de dados em formato de bitmap. O slide principal serve como base teórica ou introdutória, enquanto a aplicação demonstra a execução prática.\n\n**Conteúdo do Slide (Parcialmente Visível):**\nO slide visível, intitulado \"Bitmap\", aborda conceitos fundamentais para a representação de imagens ou dados gráficos em memória. Os tópicos principais delineados pelos bullet points são:\n*   \"A frame que...\" (Provavelmente \"A *frame buffer* que...\" ou \"A moldura que...\")\n*   \"0 ou 1 no en...\" (Sugere a representação binária de pixels, possivelmente \"0 ou 1 no *endereço*\" ou \"0 ou 1 no *espaço*\")\n*   \"Endereço(X...\" (Provavelmente \"Endereço (X,Y)\" ou alguma fórmula de cálculo de endereço para pixels)\n*   \"Com X de 0...\" (Continuação do cálculo de endereçamento ou coordenadas)\n*   \"Codificação\" (Indica a forma como os dados do bitmap são armazenados, como cores ou valores de pixel). Abaixo, há um fragmento visual \"7 6\" e \"B B\", que pode representar um campo de bits ou bytes para codificação de cor/pixel.\n*   \"Observ...\" (Possivelmente \"Observação\" ou \"Observações\")\n*   \"Exemplos:\"\n    *   \"bitmap.s\" (Nome de um arquivo fonte MIPS Assembly, provavelmente o código que está sendo simulado)\n    *   \"frames.s\" (Outro arquivo fonte MIPS Assembly, sugerindo a manipulação de múltiplos *frames* ou animações)\n\n**Conteúdo da Aplicação RARS (MIPS Simulator/Debugger):**\nA janela principal da aplicação é o simulador RARS 1.5 Custom 2, exibindo o arquivo `bitmap.s` e diversos painéis que compõem um ambiente de depuração e execução MIPS.\n\n1.  **Título da Janela Principal:** `C:\\Users\\mvlam\\Dropbox\\Kiko\\Disciplinas\\UnB\\OAC\\2021-2\\Lab1\\System\\Exemplos\\bitmap.s - RARS 1.5 Custom 2` – Indica o caminho do arquivo assembly sendo trabalhado.\n\n2.  **Barra de Menus e Ferramentas:** Contém as opções `File`, `Edit`, `Run`, `Settings`, `Tools`, `Help` e ícones de atalho para operações comuns como abrir, salvar, montar (assemble), executar (run), passo a passo (step) e um checkbox \"Run speed at max (no interaction)\".\n\n3.  **Painel \"Text Segment\":**\n    *   Exibe o código MIPS Assembly montado.\n    *   **Colunas:** `Address` (endereço de memória da instrução), `Code` (código de máquina hexadecimal), `Basic` (representação básica da instrução), `Source` (código fonte assembly original com comentários).\n    *   **Instruções Visíveis:**\n        *   `0x00400000 0x0fffo000 lui t0, 0xffff0000` `# endereco inicial...`\n        *   `0x00400004 0x0ff00313 lui t2, 0xffff00` `# endereco final`\n        *   `0x00400008 0x0ff0387b lui t7, 0xffff00`\n        *   `0x0040000c 0x00000000 li t1, 0x0ff01200`\n        *   `0x00400010 0x707070e3 lui t3, 0x70707070` `# cor vermelho/ver...`\n        *   `0x00400014 0x707070e3 addi t28, t28, 0x0000`\n        *   `0x00400018 0x007383e3 beq t6, t7, FORA` `# Se for o ultimo ...`\n        *   `0x0040001c 0x01202023 sw t0, 0(t1)` `# escrev...`\n        *   `0x00400020 0x00000000 lw t1, 0x0ff01200`\n        *   `0x00400024 0xfff0ff0f jal x0, 0xfffffa` `# volta...`\n        *   `0x00400028 0x0ff00037 lui t6, 0xffff0000` `# endere`\n        *   `0x0040002c 0x00003013 addi x6, x6, 0x0000`\n    *   As instruções `lui` e `addi` são comuns para carregar valores em registradores, e `sw` (store word) para escrita na memória, `lw` (load word) para leitura. O `beq` (branch if equal) e `jal` (jump and link) indicam controle de fluxo de programa. Os comentários sugerem manipulação de endereços de memória para pixels ou cores.\n\n4.  **Painel \"Labels\":**\n    *   Lista os rótulos simbólicos definidos no código assembly e seus endereços correspondentes.\n    *   **Conteúdo Visível:** `bitmap.s` `0x00400018`, `LOOP` `0x00400028`, `FORA` `0x00400044`, `LOOP1` `0x00400050`, `FORAT` `0x0040005C`, `SP2` `0x00400060`, `FILM` `0x00400074`.\n\n5.  **Painel \"Data Segment\":**\n    *   Exibe o conteúdo da memória de dados em formato hexadecimal.\n    *   **Colunas:** `Address` (endereço inicial da linha), `Value (+0)`, `Value (+4)`, `Value (+8)`, `Value (+C)` (valores de palavras de 32 bits em offsets relativos ao endereço inicial da linha).\n    *   **Conteúdo Visível (a partir de `0x10010000`):**\n        *   `0x10010000 0x00000040 0x00000020 0x1a1a1a1a 0x1a1a1a1a`\n        *   `0x10010010 0x0000000a 0x0000000a 0x0090909a 0x0090909a`\n        *   `0x10010020 0x0090909a 0x01111111 0x0090909a 0x01111111`\n        *   `0x10010030 0x0090909a 0x0b1b1b1a 0x595a1a51 0x59595959`\n        *   `0x10010040 0x0b1b1b1a 0x0b1b1b1a 0x00000000 0x00000000`\n        *   Linhas subsequentes são preenchidas com `0x00000000`.\n    *   A caixa de seleção \"Hexadecimal Addresses\" está marcada.\n\n6.  **Painel \"Messages\":**\n    *   Exibe mensagens do simulador, como o status da execução.\n    *   **Conteúdo:** `--- program is finished running (0) ---` (Indica que o programa MIPS terminou a execução sem erros).\n\n7.  **Painel \"Control and Status\" (Registers):**\n    *   Exibe o estado dos registradores MIPS.\n    *   **Colunas:** `Name` (nome simbólico do registrador), `Number` (número do registrador), `Value` (valor hexadecimal atual).\n    *   **Conteúdo Visível (Registradores de Uso Geral):**\n        *   `zero` `0` `0x00000000`\n        *   `at` `1` `0x00000000`\n        *   `v0` `2` `0x00000000`\n        *   `v1` `3` `0x00000000`\n        *   `a0` `4` `0x00000000`\n        *   `a1` `5` `0x00000000`\n        *   `a2` `6` `0x00000000`\n        *   `a3` `7` `0x00000000`\n        *   `t0` `8` `0x00000000`\n        *   `t1` `9` `0x00000000`\n        *   `t2` `10` `0xfff11200`\n\n**Janela Flutuante \"Bitmap Display, Version 1.0\":**\nEsta é uma ferramenta de visualização gráfica do RARS, crucial para entender a saída do programa `bitmap.s`.\n*   **Título:** `Bitmap Display, Version 1.0`.\n*   **Controles de Configuração:**\n    *   `Unit Width in Pixels`: `1` (largura de cada unidade de dado em pixels na tela)\n    *   `Unit Height in Pixels`: `1` (altura de cada unidade de dado em pixels na tela)\n    *   `Display Width in Pixels`: `320` (largura total do display em pixels)\n    *   `Display Height in Pixels`: `240` (altura total do display em pixels)\n    *   `Base address for display (frame 0 = 1)`: (campo de seleção para o endereço de memória onde o display deve ler os dados do bitmap, com a nota `frame 0 = 1` sugerindo múltiplos buffers de frame).\n    *   `Showing frame`: (campo de seleção para qual frame está sendo exibido, reforçando a ideia de múltiplos frames).\n*   **Área de Display:** Uma tela preta retangular que exibiria o bitmap renderizado pelo programa MIPS.\n*   **Controles da Ferramenta:** Botões `Disconnect from Program`, `Reset` e `Help`.\n\n**Conteúdo do Chat (Bate-papo público - Lateral Esquerda):**\nO chat mostra a interação dos alunos e do professor durante a aula.\n*   **Mensagens Importantes para o contexto da aula:**\n    *   \"Bem vindos à sala de aula de OAC!\"\n    *   \"Essa sessão está sendo gravada.\"\n    *   \"Para mais informações, clique aqui. Novo na plataforma? Experimente o tour!\"\n    *   Perguntas como \"O que houve?\", \"cê tá ouvindo o professor?\" e afirmações como \"BELE\", \"hj é lab\" (hoje é laboratório) indicam que a aula inclui uma sessão prática.\n    *   Comentário \"teste hoje ta dificil, seta doido\" indica dificuldades com exercícios ou avaliações.\n    *   A menção de \"256\" pode se referir a um valor numérico relevante para o contexto (e.g., número de cores, tamanho de buffer, etc.).\n\n**Conclusão Técnica:**\nA imagem fornece uma rica representação de uma aula prática de Arquitetura de Computadores focada em MIPS Assembly para manipulação gráfica (bitmaps). O RARS simulator, com seus painéis de código, dados, registradores e a ferramenta de visualização de bitmap, demonstra a depuração e o resultado da execução de um programa de baixo nível que interage diretamente com a memória para gerar uma imagem. A análise do código assembly (`lui`, `sw`, `beq`, `jal`) e dos dados na memória (`Data Segment`) junto com a configuração do `Bitmap Display` (320x240 pixels) permite inferir que o objetivo do laboratório é programar a escrita de pixels em uma área de memória que será interpretada como uma imagem.",
        "transcription": "Que a gente utilizasse esse terminalzinho aqui, né, pra gente ler do teclado, ler um inteiro, ler um *float*, ler uma *string*, a gente sempre utilizava esse terminalzinho aqui, certo? Espero que vocês já tenham brincado com isso, tá? Ler o inteiro, trabalhar esse terminalzinho inteiro, etc. e tal. Só que agora, tá, ao invés da gente utilizar essa interfacezinha... A gente quer utilizar essa... Esse dispositivo aqui. Então, notem, eu vou escrever aqui, não vou escrever aqui, eu posso utilizar, por exemplo, o serviço 1, o serviço 5 pra ler um inteiro, ele vai ler do teclado, né, que ele vai disponibilizar aqui. Mas não, agora eu quero ler desse dispositivo aqui. Não quero ler do sistema operacional que o RARS tem. Ok? Eu quero ler daqui. Então, como é que eu faço pra ler coisas desse... Desse novo dispositivo? Então, pra isso, tá, o `SystemV21`, tá? Então, se vocês abrirem o `SystemV21`, deixa eu abrir aqui só pra mostrar a cara dele pra vocês. Ai, Deus meu, *desktop* não, tá, vou passar por aqui, tem que descer até lá... `2028`... `2028`... `2028`... `2028`... `2028`... `2028`... `2028`... `2028`... `21`... `21`... `21`... Não, tá em `System`, que é o `SystemV21`, nós temos aqui o `SystemV21` e o `Macros21`. Então, o que que é esse `SystemV21`? Ele é uma... Vocês têm os serviços que o próprio RARS te disponibiliza, né, que são esses serviços aqui, esses *syscalls* aqui, tá, dessa tabelinha. Esses aqui são os serviços que o *hardware* disponibiliza, e todos esses serviços aqui, tem os serviços de entrada, tem como entrada esse terminalzinho aqui, certo? Só que eu não quero usar esse terminal pra entrada, eu quero usar aquele dispositivo de teclado. Então, a gente teve que fazer novas rotinas de leitura de inteiro, de leitura de *float*... *Double* não, a gente não implementou *read double*, leitura de *string*, leitura de caractere para usar aquele dispositivo. Então, a gente criou os serviços `105`, `106`, `108` e `112`, que são os mesmos serviços `5`, `6`, `8` e `12`, só que com `100` na frente. Quer dizer, se eu chamar o serviço `5`, eu vou usar o microssistema operacional do RARS para ler daquele console. Se eu usar o serviço `105`, eu vou ler agora um inteiro também, só que do dispositivo `Keyboard and Display Simulator` daqui, certo? Então, essas novas rotinas aqui estão todas codificadas nesse `SystemV21`. Então, é como se fosse uma extensão do sistema das rotinas do sistema. Ok? Então, para ler um número inteiro do teclado dessa tela aqui, vocês vão chamar, então, o `syscall 105` e assim vai. Então, o número vai ser lido para `$v0`, vai ser exato, tudo igual que era no RARS, só que agora ele vai ler do teclado. Depois vocês vão dar uma olhadinha. Deixa eu ver se eu consigo dar uma olhadinha rápida nisso aqui. Então, só pra vocês terem ideia da complexidade desse código. O tamanho desse negócio aqui são 1820. Então aqui está implementado várias novas serviços do sistema, vários novos... Deixa eu ver se eu tenho como ver aqui. São esses novos serviços aqui: `exit`, `print_int`, `print_string`, `print_char`, `print_float`, `read_char`, `read_int`, `read_string`, `read_float`, `print_hexadecimal`, `print_unsigned_int`, `read_out`, `read_5`, `read_out`, `read_out`. Não vou usar isso aqui do `halt`. Quer dizer, pra sincronizar a coisa de `read_time`, a gente não vai usar mais `sleep`. Interessante pra a gente parar o processador, mas aconselho vocês não usarem esse `sleep` aqui. Vocês fazerem um *sleep* mesmo no código de vocês e não usar esse aqui porque gasta muito tempo chamando essa rotina do sistema para gerar o número randômico, para limpar a tela... E esse é um desenhozinho que aparece depois que a gente vai ver. Certo? Essas aqui são os novos serviços, utilizando, então, os novos dispositivos. Então, esses aqui vai ser para o *keyboard*. Próximo dispositivo é o *Bitmap Display*. Então, o *Bitmap Display*, ele usa mapeamento da memória de vídeo direto em memória. Em quais endereços, então, vai estar? Então, ele vai ter esse *pixel* aqui, tá? O primeiro, superior à esquerda, vai estar no endereço `FF0000`. Depois, o próximo *pixel* no endereço `FF0001`, porque nós estamos colocando apenas um *byte* por *pixel*. Certo? Então, assim, mais um, mais um, mais um. O endereço desse *pixel* aqui vai ser o `FF0013F`. Depois, volta para a próxima linha. Que seria o `FF14`, aqui, final `FF14`. E vai escaneando, assim, até aqui embaixo. Esse *pixel* aqui é esse endereço. E o último *pixel* aqui é esse endereço aqui. Ok? Então, dando 320 colunas por 240 linhas. Então, esse aqui já vem com essa resolução aqui selecionada por *default*. Quando a gente abre o *Bitmap Display*. Então, abrindo o *Bitmap Display*. O *Bitmap Display* aqui. Ó, ele já abre direto para 320 por 240. Isso aqui é pequenininho. Se vocês quiserem ampliar isso aqui, tá? Sem mexer nessa resolução, dá. Daí, o monitor vai dar a dica de como é que se faz isso. Ok? E aqui a gente tem duas *frames*. Tá? Duas *frames*: *frame* 0 e *frame* 1. Já vamos mostrar o que significa isso. Vamos voltar aqui. Certo? Com duas *frames*: 0 e 1. Ou a *frame* 0. Tá? Então, o que significa duas *frames*? É que eu tenho duas telas VGA na memória. A *frame* 0 e a *frame* 1. Certo? Então, eu posso mostrar essa tela na memória. Ou eu posso mostrar essa tela na memória. Desculpe. Essa tela no monitor. Ou essa tela no monitor. Certo? E eu posso selecionar qual dessas duas telas eu quero mostrar no monitor. Então, eu tenho dois endereços diferentes. Um para a tela *frame* 0. Que é toda essa aqui. Onde esse número aqui é 0. E a mesma coisa para a *frame* 1. Onde esse número aqui que está em vermelho 0. Passa a ser 1. Certo? Então, vocês têm aqui o mapeamento das duas *frames*. Se aqui for 0, é a *frame* 0. Se aqui for 1, é a *frame* 1. Certo? Então, vocês podem estar mostrando uma *frame* e trabalhando na outra. E depois vocês trocam. Passa a mostrar essa e trabalhar nessa. É uma questão de vocês brincarem com o uso dessas duas *frames*. Então, a *frame* é selecionável escrevendo 0 ou 1 nesse endereço aqui. Então, se você escreve 0 nesse endereço, vocês vão estar mostrando a *frame* 0. Se vocês escrevem 1 nesse endereço, vocês vão estar mostrando a *frame* 1. E eu posso calcular qual é o endereço de uma coordenada x variando de 0 a 319. E y variando de 0 até 239. 320 por 240. Acabando fazendo essa equaçãozinha aqui. Que é o endereço base mais a linha vezes 320 mais x. Certo? Então, assim vocês calculam qual é o endereço de qualquer *pixel* aqui da memória. Quer dizer, de qualquer *pixel* aqui do vídeo. Da tela. Basta saber a posição x e y dele. Sabendo que o `0, 0` é aqui. Aqui é o `319` por `239`. `0, 0`, `0, 1`, `0, 2`, `0, 3`. Aí sim vai até o último aqui. Ok? Então, isso é como se acessa os *pixels* na *frame* de vídeo. As cores. Aqui, a princípio, a gente poderia utilizar 24 *bits* por *pixel*. O problema é que no FPGA, a gente não tinha memória para isso. Então, a gente não esperava que essa pandemia fosse durar tanto. A gente não modificou isso aqui esperando que a pandemia acabasse e a gente pudesse voltar a usar as plaquinhas. Então, como na plaquinha... O FPGA tem pouca memória, a gente fez a codificação de 8 *bits* por *pixel*. Ok? Com 8 *bits* por *pixel*, escrevam aí. Sério que o teste está difícil? Façam lá o testinho. Então, com essas 8 *bits* por *pixel*, a gente consegue colocar quantas cores? 8 *bits* por *pixel*. 256. São essas 256 cores aqui. E como é que é definida uma cor? Os primeiros 3 *bits* correspondem à intensidade de vermelho. Então, que pode ir de 0. 0 até 7. Os próximos 3 *bits* vai ser a intensidade de verde. Que pode ir de 0 até 7. E os 2 *bits*, a intensidade de azul. Que pode ir de 0 a 3. Então, a gente perde um pouco do azul justamente porque nosso olho não é muito sensível ao azul. Já que o céu é azul, a gente não poderia ser muito sensível a isso. A gente é mais sensível ao vermelho, que é o sangue, e ao verde, que são as folhas. Então, na época de caçada lá dos tigres e dentes de sabre, essas duas aqui eram mais importantes para a gente poder visualizar do que essa aqui. E isso é verdade. Tem uns estudos que foram feitos que mostraram que o nosso olho é menos sensível ao componente azul. Então, `0, 0` seria essa aqui. `0, 0`, a cor 1 seria essa. A cor 2, a cor 3, a cor 4, a cor 5, a cor 6, até a cor 7. Então, essa aqui seria desde o... Preto, até o vermelho mais vermelhão. E os outros aqui vão sendo combinações, até que eu chegue aqui no branco. Certo? Que é o tudo 1 aqui. É 255. A cor `C7`, essa cor aqui, que é o magenta, ela não é mostrada na tela. Então, se vocês tentarem pintar um *pixel* com `C7`, ele não vai ser pintado. Então, o que isso faz? Faz com que essa cor aqui seja transparente. Quer dizer, o que estava a cor do *pixel* original, quando eu *printo* com `C7`, ela não muda. Certo? Então, é como se estivesse *printando* com transparente. Ok? O resto tudo é normal. E aqui a gente tem dois exemplos. O `bitmap.s` e o `frames.s`. Vamos abrir esses exemplinhos aí, rapidão. Exemplo, `system`, exemplo. Ah, tem `bitmap`, `bitmap2`. Eu nem me lembro mais o que que é. Ah, `bitmap`. Acho que não vai dar certo, mas tudo bem. Vai dar erro. Como sempre, pode dar erro. Então, eu abri o programinha. Aqui, eu vou incluir dois arquivos de dados. Certo? Então, `frogger.data` e o `oac.data`. Onde que estão esses `.data`? Estão lá naquele diretório de exemplos. O `frogger.data` é esse aqui. E o `oac.data` é esse aqui. Eles foram gerados a partir desse programinha `bmp2oac3`. Aqui vocês têm o código fonte dele aqui em C. Por acaso, se vocês quiserem ver. Então, o que esse programinha faz? Ele converte uma imagem *bmp*. Ele pega uma imagem *bmp*, por exemplo, essa aqui. E te gera três arquivos de saída. O `frogger.bin`, o `frogger.data` e o `frogger.mif`. Ok? Então, o que que é o `frogger.data`? O `frogger.data` é um arquivo de saída. O `frogger.data` é um arquivo de saída. O `frogger.data` é um arquivo de saída. O `frogger.data` é um arquivo de saída. O ponto `.mif` a gente não vai utilizar, porque era utilizado para carregar no FPGA. Certo? Então, como a gente não tem FPGA, esse ponto `.mif` agora, por enquanto, não serve para nada. Então, a gente tem dois aqui. O `frogger.data` e o `frogger.bin`. O `frogger.data`, vamos abrir. Ele é um arquivo que foi feito para simplesmente incluir no programa de vocês na parte de dados. Então, aqui eu defino um *label*, que é o nome do arquivo, que é `frog`. Depois, duas *words*, indicando o tamanho do arquivo. E depois, uma sequência de 76 mil e alguma coisa *bytes*, que é 320 por 240. Então, esse aqui vai ser o *pixel* na posição `00`, *pixel* na posição `01`, `00`, `01`, `02`, `03`, e assim vai até aqui. Aqui já é o *pixel* na posição `10`, `11`, `12`, e assim vai. Certo? Até o último aqui. Certo? Então, ele está no formato texto e a gente pode incluir ele diretamente no nosso programa. Desse modo aqui. No `.data`, eu estou incluindo o `frogger.data` e incluindo o `oac.data`. Como eles são arquivos de texto, o montador, ao ver essa diretiva *include*, ele vai lá, lê aquele arquivo e coloca aqui. Depois vai lá, lê o arquivo e coloca aqui. A gente não precisa botar aquele monte de números aqui. Beleza. E o que esse programinha está fazendo? Então, primeiro ele vai preencher a tela de vermelho. Então, está aqui um exemplo de como é que se faz isso. Carregar a imagem 1, certo? Na *frame* 0. E carregar a imagem 2 na *frame* 1. Certo? E depois retorna para o sistema operacional. Depois vocês analisam direitinho isso aqui. Tenho certeza que vai dar errado, mas... Então, pra a gente utilizar, eu montei o programa. Eu abri o *tool*, o *Bitmap Display*. O importante, sempre vocês têm que conectar essa ferramenta ao programa de vocês. Então, eu estou conectando agora essa ferramenta ao processador MIPS que faz, que está sendo simulado pelo RARS. E agora eu vou executar. Então, viu que eles preencheram lá de vermelho primeiro. Não sei se deu para ver devido ao atraso da rede. E depois colocou essa imagenzinha do *frogger*. Eu posso ver a *frame* 0. Eita. Boa pergunta. Que saco. Eu tenho que resetar isso aqui? Não. Deixa eu mudar aqui. Não está mostrando as duas *frames*. Não está mudando, só está mostrando a *frame* 0. Ah, meu Deus do céu. Alguém mexeu no ensino. Vitor, sabe o que está acontecendo aqui? Por que só está mostrando a *frame* 0? Não está deixando eu selecionar? Ué, professor. Nos... Nos... Nos arquivos do semestre passado funcionavam esses exemplos. Pois é. O que eu estou achando estranho aqui. Deixa eu ver aqui se está funcionando. Tá, eu vou mostrar a *frame* 1. Então, reseto esse negócio. Reseto. Ó, a *frame* 1 ele mostra, mas aqui ele não está deixando a gente selecionar qual é a *frame* que a gente quer. Porque aqui deveria estar mostrando o *frogger*. Está muito estranho isso aqui. Muito estranho. Certo? Então, a *frame* 1 que eu tinha carregado. E além disso, ele deveria manter. Eu não mexi na memória, ele deveria manter isso aqui. A imagem aqui. Ele não está mantendo. Enfim. A gente começa a verificar *bugs* agora. Porque ele, como eu não mexi na memória, as duas imagens estão aqui. Eu só estou querendo mostrar a partir desse endereço ou a partir desse endereço. 0 ou 1. E... Não está fazendo isso. Tenho a impressão que aconteceu algo de inesperado que eu não estava esperando. Bom. Enfim. O Victor vai ver o que é que está... Por que está dando esse comportamento estranho. Tá? Mas a princípio vocês têm as duas *frames* lá. Deixa eu rodar esse `frames.s` para verificar se esse está funcionando. `frames.s`. Vejam se vocês têm esse mesmo comportamento que eu estou tendo. Ou se vocês conseguem rodar de vez. Perfeitinho. Corta o programa. E roda. Ah. É. Esse está funcionando. Olha. O *frame* 0 e o *frame* 1 estão... Estão sendo alternados. Certo? Então nesse caso aqui o atraso da rede eu estou vendo que ele está bem pesado. Se vocês rodarem isso aqui no micro de vocês, vocês vão ver que essas alterações aqui estão... Esqueci o nome dela. Qual é o nome dela? É a `Mom`. A `Mom`. É a `Mom`. É a `Mom`. É a `Mom`. Luiz. A `Mom`. Vocês vão ver que a `Mom` está na realidade chaveando as duas *frames* de modo muito rápido. Ele não está escrevendo tudo em um e depois escrevendo a outra em cima. Então para fazer efeitos assim é bem interessante. Mas está muito estranho. Não está mostrando as *frames* aqui. Eu acho que o raciocínio é assim. Depois que você muda, se ele está mostrando o *frame* 0, 1, o *frame* só 0, o *frame* só 1, você tem que rodar de novo o programa para ele identificar. Eu testei aqui no *custom* 1. Como é que é? Fala alto, Gustavo. Eu não entendi. Ah, foi mal. Tipo, o *hardware* eu acho que ele sempre foi assim. Quando você roda o programa e muda o *frame* que ele está exibindo, vai ficar preto. Aí você tem que rodar o programa de novo no outro tipo de *frame*. Quando você coloca para exibir sua *frame* 1, você tem que rodar o programa de novo. Não era assim. A teoria é que não era assim. Eu testei no *custom* 1 aqui e está assim. No *custom* 1 sim, mas tem o 1.4. Eu vou testar no *custom* 1. Eu vou testar no *custom* 1. Eu vou testar no *custom* 1. Eu vou testar no *custom* 1. Aí deixa eu testar. No 1.4 isso aqui. Eu não tenho certeza se o autor do RARS mexeu em alguma coisa que acabou afetando de maneira periférica. É isso. Bom. Então, enquanto eles testam lá. A teoria é que não era assim. Quando você coloca para exibir sua *frame* 1, você tem que rodar o programa de novo. Não era assim. A teoria é que não era assim. Eu testei no *custom* 1 aqui e está assim. No *custom* 1 sim, mas tem o 1.4. Eu vou testar no 1.4 isso aqui. Eu não tenho certeza se o autor do RARS mexeu em alguma coisa que acabou afetando de maneira periférica. É isso. Bom. Então, enquanto eles testam lá. Eu vou testar no 1.4. É isso. Bom. Então, enquanto eles testam lá. Então, isso aqui seria como vocês vão desenhar no *Bitmap Display*. E a gente pode utilizar aquelas mesmas serviços de *syscall*, que era o `PrintInt`, `PrintFloat`, `PrintString`, `PrintChar`, `PrintIntX`, também agora no *Bitmap Display*. Ao invés de mostrar essas mensagens. Não. mensagens aqui nesse terminalzinho. Sempre que a gente usava o serviço 1, `print_int`, era aqui que era apresentado, mas não, eu quero apresentar agora nesse *display* aqui, eu quero usar agora esse *display*, `print_int`, `print_float`, `print_string`, por aí vai, certo? Então, a gente teve que criar novos serviços, tá? Então, serviços `101`, `102`, `104`, `111`, `134`, tá? Então, `101` é um `print_int`, no original do RARS, a gente só precisava colocar qual era o inteiro que a gente queria mostrar em `$a0`, certo? Então, a única coisa que eu precisava de parâmetro aqui para mostrar o inteiro, era o inteiro estar em `$a0`. Agora não. Agora, eu preciso, além de dizer qual é o inteiro, eu preciso dizer onde que ele está, certo? Em que coluna, em que linha, quais são as cores que eu vou utilizar, as cores de frente e de fundo do caractere, certo? Então, as cores de frente e fundo, a gente define dessa maneira aqui, o `$a3`, tá? Os primeiros 8 *bits* é a frente, esse aqui. E o seguinte? Os primeiros 8 *bits* é o fundo. Então aqui eu defino com que cor eu quero imprimir o caractere e aqui qual é o fundo desse caractere, certo? E mais ainda, eu preciso definir em que *frame* que eu quero escrever isso, se vai ser na *frame* 0 ou na *frame* 1, certo? Então, diferente do `print_int` normal do RARS, eu preciso fazer todas essas definições para poder escrever na posição que eu quero no *Bitmap Display*, certo? Onde é que eu quero escrever... E a fonte é sempre 8 *pixels* por 8 *pixels*, quer dizer, é 8 por 8, tá? E também só tem uma fonte para escrever, tá? E assim todos eles, então. Então, essas implementações nesses aqui estão nesse arquivo `SystemV21` também. E esse aqui continua, então, o `print_int` e o `signer`. `ClearScreen` não usa isso aqui porque ele é muito lento. Mas se quiserem utilizar, então é o *syscall* `48` ou `148`, que dá no mesmo. Eu quero imprimir na *frame* 0 ou 1 todos os *pixels* dessa cor. Então ele preenche tudo. E `drawLine`. Então se eu quero fazer uma linha entre os pontos `$a0` e `$a1` até o ponto `$a2` e `$a3`, na *frame* `$a5` com a cor `$a4`. Certo? Então ele vai imprimir uma linha de *pixels* entre aquelas duas coordenadas com a cor que vocês desejarem, que é essa aqui. Ok? Então isso aqui facilita bastante algumas coisas. E esse teste `syscall V21` está dando o mesmo comportamento no 0.4? Estou ficando maluco que esse negócio não dá para trocar a *frame*. Eu sempre já vi tocando a *frame* estranho. Depois eu vou dar uma olhada nisso também. O que será? Bom, depois eu vejo isso. E aqui nesse teste `syscall V21`, a gente tem então um teste de todas essas chamadas de sistema. Que é esse aqui. Então a gente tem o `teste_syscallV21` para rodar no RARS. E o `teste_syscallV21_FPGA_RARS`, se vocês quiserem utilizar o `FPGA_RARS`. Depois os monitores vão dar as dicas para vocês sobre o que é o `FPGA_RARS` e como ele pode ser utilizado. Então. Vamos rodar esse `teste_syscallV21` para a gente ver o que que é. Então é esse aqui. Esse aqui. Pronto. Certo? Então ele é um programinha que vai escrever um monte de coisa na tela, depois vocês analisem. Vai tentar chamar todas as rotinas de escrever e ler do teclado. Para testar se essas rotinas implementadas estão realmente corretas. Então. Então aqui a gente monta ele. Eita. Montei. Vou abrir o *Bitmap Display*. Conectei. E vou abrir o *Keyboard* e o *Menu Tool*. Conectei. Certo? Então esse *keyboard* aqui, geralmente vocês vão abaixar o tamanho dele para não incomodar muito. Certo? Então tá aqui. E eu vou agora então executar. Então. Executando. Executando. Executando. Ele vai botar algumas cores aqui aleatórias e vai pausar. Então uma vez que ele tá pausado, vocês aqui digitem qualquer tecla. Por exemplo, um *enter*. Ah não, desculpe. Ele ficou pausado. Tá aqui, ele entrou em pausa aqui. Tá? Então é só mandar a gente continuar aqui. Ok, continuou. Ele vai escrever algumas coisas na tela que vocês não estão lendo. Deixa eu ver se eu consigo fazer isso aqui em tempo real. Provavelmente vai ter que... Botar de novo. Aumentar isso aqui. Só pra vocês verem. Conecta, conecta, *reset*. Para, volta aqui. Pronto, agora vai. Eita, o que eu fiz aqui? Dois e dois. Dois e dois. *Reset*. Volta. Agora sim. Parou. Continuo. Ok. Ele mostra aqui uma frase. Eu até esqueci de atualizar. Vou atualizar isso aqui. Tá? Digite seu nome. Então vocês vão digitar o nome de vocês aqui. Tá? Ah, não tem acento. Tá? Então o Joãozinho tem que ser posto assim, sem acento. Tá? Então manda para lá. Olha, ele escreveu aqui. Joãozinho. Digite sua idade. Bom, o Joãozinho tem 13 anos. Quer dizer, aqui ele testou o `read_string`. Aqui ele testou o `read_int`. Né? Aqui ele está testando `print_strings`, qual é o peso do Joãozinho? Joãozinho pesa, vamos lá, pesa cento e cinco vírgula setenta e cinco quilos, tá? Então o Joãozinho ele é meio gordinho. Certo? E aqui ele mostrou, mostrou um monte de outras informações. Tem um temporizadorzinho aqui. Certo? E depois ele vai ficar fazendo essa figurinha em cima aí só pra mostrar que os negócios de desenhar linhas estão funcionando. Ok? A velocidade com que isso aqui tá rodando pode ser mais baixa no computador de vocês, tá? Porque depende do processador a velocidade que isso aqui tá rodando. Ok? Depois vocês tentem rodar isso aí no `FPGA_RARS`, né, que daí os monitores vão mostrar pra vocês como é que se faz. Daí vocês vão ver quanto que o RARS é lento. Beleza. Então esse aqui é o teste, né, dos do `SystemV21` naquela tela que ele mostrou um monte de coisas aqui. Vamos fazer de novo, tá? Vamos dar um *reset*, parar nisso aqui, dar um *reset*, *reset*, e vamos rodar de novo. Ok? Digite seu nome. Digite sua idade. Digite seu peso. 22,25. Parei, tá? Eu dei um *pause* aqui por quê? Porque eu queria que vocês vissem o que que tá sendo mostrado aqui, tá? Então o peso que foi, que é um *float*, tá, ele sempre vai mostrar em notação científica, tá? Porque senão ficaria muito difícil, né, a gente fazer um `print_float` que fosse adaptativo ao tipo de *float*. Então ele sempre vai mostrar em notação científica. `2,25` vezes `10` na `1`. Aqui ele mostra um número randômico. Qual que é? Tem uma rotina onde a gente chama número randômico aqui. É o tempo de sistema. Certo? Então é o número de 64 *bits*. Esses dois aqui nós vamos ver daqui a pouco aqui. Qual é a ISA que ele tá sendo utilizado? Nesse caso, a ISA `R32IMFD`. O desempenho que é calculado como tempo de execução vezes I, vezes CPI, vezes T, tá? Então o tempo de execução a gente pode, eu quero dizer o tempo, isso aqui vai te dar em milissegundos. Essas aqui, então, o tempo de execução total até aqui foi `1272 milissegundos`. O `I`, uma contagem de instruções, quantas instruções ele fez até aqui, ciclos de *clock*, tá? Como o RARS ele simula um processador, ele faz com que cada instrução seja executada em um ciclo de *clock*. Então uma CPI igual a 1. Então por isso que o número de instruções é igual ao número de ciclos de *clock*, tá? Porque a nossa CPI é 1. Tá aqui o período. Então ele vai te dar qual é a frequência que dado essas medidas qual seria a frequência equivalente do processador que estaria executando isso aqui. Então seria um processador de `182 kHz`. Que esse aqui é `1,82` vezes `10` na menos 1 MHz. Então `182 kHz` é a frequência do processador simulado aqui. Então depois vocês podem ver o programa para verificar como é que se obtém tudo isso aí. E a última coisa, como é que se faz MIDI? Como é que se faz sonzinhos? Se vocês executaram esse teste, eu tô falando lá de tempo de execução, não de desempenho, entendeu, Alisson? Então se vocês executaram esse teste `SystemV21`, vocês viram que ele toca uma musiquinha. Então ali também tem como é que se toca a musiquinha de exemplo lá nesse arquivo, nesse teste do `SystemV21`. E aqui então são as três *syscalls* que a gente usa para gerar musiquinha. Essas *syscalls* aqui então são originais do RARS. Então o RARS é que provê essas *syscalls*. Então `31` sintetiza a nota `$a0` com duração `$a1` com instrumento `$a2` e com volume `$a3` e retorna ao programa enquanto a nota é tocada. Certo? Então ele manda tocar o sintetizador, vai tocar essa nota, mas o programa de vocês podem continuar. Tá? O `MIDI_OUT_SYNC` significa que vocês vão tocar essa nota, mas o programa vai ficar parado até a nota acabar de ser tocada. Então nota que tem uma diferença fundamental entre esses dois, certo? Esse aqui manda tocar a nota e continua o programa. Esse aqui manda tocar a nota e fica esperando a nota acabar de ser tocada. Ok? Então com esse aqui vocês conseguem fazer acordes e esse aqui melodias. E obviamente a gente precisa de pausas. Então ele faz uma pausa de `$a0` milissegundos aqui. E aqui o programinha exemplo, o `midi.s` que vocês executam.",
        "video_source": "OAC_2022-03-02.mp4"
    },
    {
        "id": 6,
        "timestamp_start": 3059.32,
        "timestamp_end": 3063.08,
        "slide_description": "Como Engenheiro de Computação Sênior, procedo com a análise do artefato visual fornecido, interpretando-o como um frame de uma aula síncrona de Arquitetura de Computadores em um ambiente virtual de aprendizagem.\n\n**Contexto Geral:**\nO frame apresenta um ambiente de conferência web, denominado \"ConferênciaWeb - Sala de Aula de OAC\" (Organização e Arquitetura de Computadores), com o tempo de sessão em \"51:38\". O palestrante, \"Prof. Marcus Vinicius Lam\", está visível no canto inferior direito. A tela principal de apresentação de slides exibe uma mensagem de encerramento, indicando que a parte expositiva da aula foi concluída, mas o chat ativo sugere que a discussão ou sessão de perguntas e respostas ainda está em andamento.\n\n**1. Transcrição Fiel de Texto, Títulos e Código:**\n\n*   **Barra Superior (Título da Sessão e Tempo):**\n    *   \"ConferênciaWeb - Sala de Aula de OAC\"\n    *   \"Sala de Aula de OAC\"\n    *   \"51:38\" (indicando o tempo decorrido da sessão)\n    *   \"Marcus Vinicius Lam...\" (nome do professor/apresentador, parcialmente visível)\n\n*   **Área Principal de Conteúdo (Tela de Apresentação - Fundo Preto):**\n    *   No centro superior: \"Fim da apresentação de slides. Clique para sair.\"\n    *   No canto superior direito, há um logotipo (não textual) e as seguintes informações textuais, indicando a afiliação e o contexto acadêmico:\n        *   \"Universidade de Brasília\"\n        *   \"Departamento de Ciência da Computação\"\n        *   \"CIC0009 - Organização e Arquitetura de Computadores\"\n        *   \"Prof. Marcus Vinicius Lam\"\n\n*   **Barra Lateral Esquerda (Navegação):**\n    *   **MENSAGENS**\n        *   \"Perguntas\"\n        *   \"Bate-papo público\"\n    *   **NOTAS**\n        *   \"Notas compartilhadas\"\n    *   **USUÁRIOS (30)** (listagem de participantes, alguns visíveis)\n        *   \"Marcus Vinic... (Você)\" (indicando o usuário logado como o professor)\n        *   \"Andre Carvalho de...\"\n        *   \"Arthur Brasa de O...\"\n        *   \"Bruno Berto de Oli...\"\n        *   \"Bruno Vargas de S...\"\n        *   \"Eduardo Ferreira M...\"\n        *   \"Eduardo Perez Lib...\"\n        *   \"Felipe Dantas Borg...\"\n        *   \"Filipe de Sousa Fer...\"\n        *   \"Gabriel Amaro Baix...\"\n        *   \"Gabriel Kenji Andr...\"\n        *   \"Gabriel Pereira e B...\"\n        *   \"Gustavo Lopes De...\"\n        *   \"Gustavo Pierre Sta...\"\n        *   \"Gustavo Rodrigues...\"\n\n*   **Barra Lateral Esquerda (Conteúdo do Bate-papo Público):**\n    *   `João Alberto Travassos Evangelista 14:18: obr prof`\n    *   `Victor Hugo Franca Lisboa 14:28: :D`\n    *   `Eduardo Ferreira Marques Cavalc... 14:31: teste hoje ta difícil, seta doido`\n    *   `Ualiton Ventura Da Silva 14:36: 256`\n    *   `Eduardo Ferreira Marques Cavalc... 14:40: bem loco`\n    *   `luisa`\n    *   `Victor Hugo Franca Lisboa 14:40: kkkkkkkkkk`\n    *   `Rafael Hamu Campos 14:40: kkkkkkkkkk`\n    *   `Gustavo Lopes Dezan 14:42: aqui tá dando o mesmo comportamento no 1.4`\n    *   `Victor Hugo Franca Lisboa 14:45: no 1.5 também`\n    *   `Eduardo Ferreira Marques Cavalc... 14:49: joazinho tá obeso`\n    *   `Rafael Hamu Campos 14:49: 'meio'`\n    *   `13 anos`\n    *   `Ualiton Ventura Da Silva 14:49: sente a transição`\n    *   `Ualiton Ventura Da Silva 14:52: o desempenho não é o inverso do tempo de execução?`\n    *   `Victor Hugo Franca Lisboa 14:52: sim`\n    *   `Ualiton Ventura Da Silva 14:53: tendi, brigadim`\n    *   `os dois kkkk`\n\n**2. Descrição de Diagramas e Fluxo de Dados:**\n\nNenhum diagrama (Datapath, Pipeline, Hierarquia de Memória, etc.) ou fragmento de código (Assembly, C, Verilog) é visível na área principal de apresentação. A tela exibe uma mensagem genérica de \"Fim da apresentação de slides\", indicando que o material visual da aula não está sendo exibido neste momento.\n\n**Análise Semântica Adicional:**\n\nApesar da ausência de slides visíveis, o conteúdo do chat oferece insights importantes sobre os tópicos discutidos na aula de Arquitetura de Computadores (CIC0009). A pergunta de Ualiton Ventura Da Silva, \"o desempenho não é o inverso do tempo de execução?\", seguida pela confirmação \"sim\" de Victor Hugo Franca Lisboa, sugere fortemente que a aula abordou métricas de desempenho em arquitetura de computadores, como tempo de execução (CPU time) e sua relação inversa com o desempenho, um conceito fundamental na avaliação de processadores e sistemas computacionais. As referências a \"1.4\" e \"1.5\" podem indicar seções de material didático ou versões de algum software/exercício utilizado. O número \"256\" mencionado por um aluno pode ser um valor específico relacionado a endereçamento de memória, tamanho de cache, ou outro parâmetro técnico discutido.",
        "transcription": "Beleza, então, isso é o que eu queria mostrar para vocês das capacidades do Hardware.",
        "video_source": "OAC_2022-03-02.mp4"
    },
    {
        "id": 7,
        "timestamp_start": 3063.08,
        "timestamp_end": 3801.91,
        "slide_description": "Como Engenheiro de Computação Sênior, analiso o slide e o conteúdo anotado desta aula de Arquitetura de Computadores. A tela principal exibe um documento do Microsoft Word, presumivelmente o material da aula ou de um laboratório.\n\n**Conteúdo do Documento Word (OAC_LAB1.docx):**\n\n1.  **Título do Documento:** \"OAC_LAB1.docx - Modo de Compatibilidade - Salvo neste PC\"\n2.  **Título da Seção Principal (Implícito):** Jogo Senha (Mastermind)\n3.  **Descrição do Jogo Mastermind:**\n    *   \"O jogo Senha (https://pt.wikipedia.org/wiki/Mastermind) é um jogo de 1971 que consiste em descobrir um código de 4 cores de uma lista de N cores a partir tentativas e de dicas baseadas nas cores da tentativa.\"\n    *   **Feedback:**\n        *   \"Pino Branco: Cor certa no lugar errado\"\n        *   \"Pino Preto: Cor certa no lugar certo\"\n\n4.  **Diagrama/Imagem:**\n    *   Uma imagem clara de um tabuleiro do jogo Mastermind é apresentada. O tabuleiro é de madeira, retangular, com múltiplas linhas de furos para pinos coloridos. Cada linha tem quatro furos maiores para as tentativas de código e, à direita, dois furos menores para os pinos de feedback (pretos e brancos). Há pinos coloridos (azul, vermelho, amarelo, verde, laranja, preto, branco) e pinos de feedback já posicionados em algumas linhas, ilustrando o estado do jogo. Uma mão do cursor do mouse está visível sobre os pinos coloridos. No topo do tabuleiro, uma seção articulada provavelmente oculta o código secreto.\n\n5.  **Tarefas de Laboratório / Requisitos (Pontos Enumerados):**\n    *   **(1.0) 3.1** \"Crie um programa no Rars que emule o jogo com máximo de 10 tentativas e N inicial igual a 5;\" (O Rars é um simulador de MIPS ou RISC-V, indicando que a implementação deve ser em Assembly para uma dessas arquiteturas, provavelmente RISC-V conforme ponto 3.6).\n    *   **(1.0) 3.2** \"Cada cor possui um efeito sonoro único quando colocada no tabuleiro. O preto possui uma pequena música e o branco outra pequena música.\" (Implica a necessidade de manipulação de áudio ou simulação de efeitos sonoros no ambiente Rars).\n    *   **(1.0) 3.3** \"As cores são escolhidas através do teclado, escreva a codificação das teclas em cores na tela.\" (Requer lógica de input/output, mapeamento de teclas para cores e exibição visual no simulador).\n    *   **(1.0) 3.4** \"A cada vitória N=N+1, isto é, o número de cores é incrementado, aumentando a dificuldade do próximo nível.\" (Define a progressão da dificuldade do jogo, aumentando o conjunto de cores disponíveis).\n    *   **(0.5) 3.5** \"Filme vc jogando até o máximo N que seu grupo conseguir. (Não vale usar cheat!!!)\" (Requisito de documentação ou demonstração prática).\n    *   **(0.5) 3.6** \"Faça os gráficos Nxt exec e NxI, onde t exec é o tempo de execução do algoritmo para a análise do pior caso da tentativa do jogador. Sabendo que o Rars simula uma CPU RISC-V com qual a frequência de clock desta CPU?\" (Requisito de análise de desempenho e complexidade. Solicita a medição do tempo de execução (t_exec) e do número de instruções (N_I) em função de N (o número de cores), para caracterizar o algoritmo no pior caso. A menção do Rars simulando uma CPU RISC-V sugere que a análise de ciclo de clock será fundamental).\n\n6.  **Recursos Adicionais (Dicas/Links):**\n    *   \"Dicas:\"\n    *   \"https://www.youtube.com/watch?v=dMHxyulGrEk\"\n    *   \"https://www.youtube.com/watch?v=Z9ijoc7RRK\"\n\n**Contexto Adicional (informações gerais da tela):**\n\n*   A aula ocorre em uma \"Sala de Aula de OAC\" (Organização e Arquitetura de Computadores).\n*   O temporizador da aula indica 57:48 minutos restantes.\n*   Uma sobreposição de texto no canto superior direito do documento Word indica \"Universidade de Brasília\", \"Departamento de Ciência da Computação\" e \"Arquitetura de Computadores\", identificando a instituição e disciplina.\n*   A interface da conferência online mostra um painel de bate-papo à esquerda com interações entre os participantes (Gustavo Lopes Dezan, Victor Hugo Franca Lisboa, Eduardo Ferreira Marques Cavalcante, Rafael Hamu Campos, Uailton Ventura Da Silva, João Alberto Travassos Evangelista, Bruno Vargas de Souza, entre outros), mas estas são conversas paralelas e não parte do conteúdo explícito do slide.\n\nEm resumo, o slide descreve um projeto de laboratório focado na implementação do jogo Mastermind em Assembly (via Rars para RISC-V), com requisitos de interface (teclado, som), progressão de dificuldade e análise de desempenho em termos de tempo de execução e número de instruções. O conteúdo é denso em requisitos técnicos para um projeto de arquitetura de computadores.",
        "transcription": "que a gente vai utilizar para gerar musiquinha de exemplo que a gente vai utilizar nesse laboratório. Então, vamos abrir o nosso roteiro do laboratório. Então, se vocês abrirem lá o lab1.pdf, vocês vão obter esse roteirozinho aqui. Tá pequeno? Tá todo mundo conseguindo ler? Vou tentar aumentar um pouco. Melhorou? Então, vamos lá. O relatório, a equipe de até três pessoas, eu já tinha dito isso antes. Eu já tinha dito isso antes, eu já tinha dito isso antes, eu já tinha dito isso, né? Eu já tinha dito, pessoal, eu já tinha falado que era equipe de três? Olha só, então tá bom, então só reforçando, equipe de até três pessoas. Eu quero que a entrega do relatório em PDF e os fontes que eu vou pedir aqui em um único arquivo zip, pelo Moodle, até os dias 21 de março às 23h55. Então, duas semanas a partir da semana que vem. Não serão aceitos relatórios depois da semana que vem, horários definidos que \"a professora não conseguiu enviar\", \"não, a professora precisa trocar\", não, não dá pra fazer. Então, pelo amor de Deus, não deixem para enviar às 23h54, tá? Porque mesmo que o Moodle esteja com problema, fora do ar, o relatório não vai mais ser aceito. Então, mandem, ah, o Moodle tá no ar? Vamos mandar o relatório. Depois vocês podem atualizar esse relatório quantas vezes vocês quiserem até a hora limite, certo? Então, não deixem pra mandar um relatório na última hora. Sei que vocês gostam de adrenalina, né? Mas então, o objetivo desse laboratório é familiarizar o aluno com o simulador/montador RARS, desenvolver a capacidade de codificação de algoritmos em linguagem Assembly e desenvolver a capacidade de análise de desempenho de algoritmos em Assembly, tá? Então, aqui nós vamos fazer esse, aqui nós vamos fazer esses dois itens juntos, tá? Então, são três itens: item 1, item 2 e item 3. O item 1 nós vamos fazer agora, tá? Então, sempre eu vou ter aqui qual é o item. Então, nesse item 1 vale dois e meio pontos. Então, item 1.1 não vale nada. Olha, se ele não vale nada, então vocês não precisam colocar. Mas aqui ele só tá pedindo pra vocês calcularem isso aqui, porque depois a gente vai precisar dele aqui embaixo, lá embaixo, tá? Então, qual é o tamanho, embaixo, do código? Isso aqui nós vamos fazer, tudo isso aqui juntos, tá? Vocês podem colocar no relatório, mas não vale nada. Esse aqui também a gente vai fazer aqui juntos, né, como é que se faz. Então, também não... na realidade, esse aqui acho que a gente já até fez. É, esse aqui a gente acabou de fazer, que era executar o teste de CAL v21. No caso, é, esse aqui, teste de CAL v21. OK? Depois esse aqui nós vamos fazer na aula que vem, tá? O compilador cruzado GCC. E sempre tem um probleminha mais fácil pra vocês fazerem no laboratório, que é pra vocês começarem a ganhar familiaridade com o RARS, certo? Então, embora os monitores tenham me dado várias dicas, pelo menos duas dicas muito boas, tá? Eu resolvi ser um pouquinho mais bonzinho com vocês. Os monitores me deram sugestões meio complicadas, certo, Vitor? É, de certa forma, é, é uma mistura dos dois, tá? Então, depois que o João Pedro me explicou aquela decodificação, eu até achei mais tranquilo do que quando você bate por esse assunto. Mas acho que esse aqui é mais divertido, tá? Então, o que que é que eu quero que vocês façam nesse laboratório 1, tá? Então, Jogo de Senha ou Mastermind, tá? Então, se vocês nunca jogaram esse joguinho aqui, tá? Vocês podem ir aqui na Wikipédia. E aqui tem dois videozinhos que mostram como é que é que esse jogo é jogado, tá? É um jogo de 1971 que consiste em descobrir um código de quatro cores que tá aqui escondido, certo? De uma lista de N cores. Aí nós vamos começar a inovar, porque aqui a gente não tem N cores, aqui a gente tem, se eu não me engano, seis ou sete cores, tá? Mas já que agora a gente tá fazendo no computador, vamos fazer uma lista de N cores, tá? Então, a partir de tentativas e dicas baseadas nas cores das tentativas. Essa aqui é uma tentativa do usuário, né? E baseado nessa tentativa, né? O computador tem que analisar qual foi a senha e colocar essas dicas aqui, que são esses pininhos brancos e pretos, né? Então, pino branco significa uma cor certa no lugar errado. E pino preto, uma cor certa no lugar certo, tá? Então, a cada tentativa do usuário, o computador tem que colocar aqui... é, seria o termo antigo, só que o claro problema do termo, o termo ele precisava de um dicionário, tá? Ele verifica um dicionário. Eu achei que isso aí ia ser um tanto quanto mais pesado pra vocês, tá? Ter esse dicionário aí. Então, o que que eu quero que vocês façam, tá? Então, isso aqui vale metade do laboratório, tá? Então, criar um programa no RARS que emule esse jogo com no máximo dez tentativas. Dez tentativas significa uma, duas, três, quatro, cinco, seis, sete, oito, nove, dez, que é esse tabuleirozinho aqui, tá? Dez tentativas e um N inicial igual a cinco, tá? Quer dizer, o número de cores no início são cinco cores, tá? Aqui é só vocês definem como que vai ser essa sequência aqui, a sequência de cores, tá? Então, fazer esse aqui: cada cor possui um efeito sonoro único. Quer dizer, quando o usuário coloca um pino branco aqui, ele vai fazer um barulhinho. Coloca um pino azul, vai fazer outro barulhinho. Coloca um pino amarelo, faz outro barulhinho, tá? Colocado no tabuleiro. O preto possui uma pequena musiquinha, tipo um \"trã\". E o branco, outra pequena musiquinha. Sei lá, vocês é que, aqui fica a critério de vocês. Não põe uma música do tipo \"Faroeste Caboclo\", que senão vocês vão encher o saco, tá? É isso que eu disse que são essas musiquinhas. Olha lá, não é apenas um som, é uma sequência de sons, certo? Ou um, entendeu? \"Papapá\" algo assim, pequena musiquinha, tá? Porque cada vez que ele botar um pino branco aqui, ele vai fazer essa musiquinha. Botar um pino preto, ele vai fazer a outra musiquinha. Hum. As cores são escolhidas através do teclado, tá? Então, como que vocês vão dizer qual é a cor que vocês querem colocar aqui? Vocês vão decidir escrevendo a codificação das teclas, hum, em cores na tela. Ah, então tá lá, o azul é o \"A\". Então, se eu aperto a letra \"A\", ele vai botar aqui um pino azul e fazer a musiquinha, fazer o efeito sonoro do azul. Ah, o botar um pino preto é o \"B\" de black. Daí coloca lá, hahaha. É bem por aí, já pensou? Certo? Então, como o número de cores vai aumentar à medida que o usuário vai ganhando, certo? Então, no início ele começa com N igual a 5 cores, que é bem fácil. Depois ele vai, o usuário ganhou essa de 5 cores, ele vai pra 6 cores, depois 7 cores, depois 8 cores, 9 cores, e por aí vai enquanto o usuário estiver ganhando, certo? O usuário perdeu, aí vocês decidem se volta pra N igual a 5 ou se continua naquele mesmo nível, tá? Então, o importante é que a cada vitória eu tenha um aumento da complexidade, tá, do, do problema, tá? Então, a cada vitória N recebe N mais 1. E como vocês vão ter diferentes números de cores na tela, é importante o usuário saber quais são as letras associadas a cada letra e quais são as letras associadas a cada cores. Então, essa associação de letras e cores tem que estar na tela também em algum lugar, tá? Pro usuário saber: \"Ah, essa cor eu vou ter que apertar o X\". Então, beleza. Daí, esses dois aqui, tá? Uma vez que vocês fizeram o programinha, né? Então, com ele funcionando bonitinho, filme você jogando até o máximo N que o seu grupo conseguir. Não vale usar cheat, OK? Então, eu quero saber, OK, vocês fizeram o joguinho, tá? Então, alguém que seja bom, né? Começa a jogar e gravando, né? Gravando jogar. Vamos ver até que N, né, esse jogador consegue ir sem perder. Pois é, Wally. Então, isso que eu disse, o número de erros é certo? A cada novo nível, se o jogador não tiver nenhum erro, ele vai subindo. Ah, se ele errou, aí é uma questão de vocês decidirem se ele volta pro nível 5, que eu diria é um jogo de um FDP muito grande, ou se ele continua no mesmo nível e continua, certo? Então, é uma questão pra vocês decidirem no programa de vocês, tá? Então, aqui eu quero um vídeo vendo vocês jogando. Aí o 3.6, então, é a análise desse programinha de vocês. Então, fazer um gráfico de N pelo tempo de execução e N por I, onde o tempo de execução, onde T_exec, óbvio, é o tempo de execução e o número de instruções requeridas pelo seu algoritmo para análise do pior caso de tentativa do jogador. Já vão entender aqui porque que é preciso do pior caso. Sabendo que o RARS simula uma CPU RISC-V com CPI igual a 1, qual é a frequência de clock dessa CPU que vocês estão usando pra jogar o jogo de vocês? OK? Aqui tem algumas dicas, tá? Então, esse aqui é o trabalhinho que vocês têm duas semanas aí pra fazer. Não precisa ser um tabuleiro muito bonitinho que nem esse aqui, pode ser uma coisa mais tosca, desde que tenha essa mecânica daqui, tá? Vamos ver então o laboratório de hoje, essa primeira parte aqui do simulador MARS, o RARS, tá? Então, depois a gente volta a falar lá do, do joguinho, tá? Se vocês tiverem dúvida, mas aqui vai te dar várias ferramentas pra usar lá. Então, faça o download de zip, o arquivo lab1.zip, e vão ser criados então dois diretórios. Deixa eu abrir eles aqui. Esses dois diretórios aqui, certo? Esse aqui quando você desliza ele cria esse aqui. Então, o `system` e o arquivo C. O arquivo C a gente vai usar na próxima aula. Então, o `system` é o que a gente vai usar agora. O que que é o, o que que é, tá no diretório `system`? Abra o `custom2` e carregue o programa de `ordenamento_sort.s`. Então, vamos fazer isso. Já que ela vale 0 pontos, é pra gente fazer aqui mesmo em aula, tá? Então, vocês podem fazer também. Eita, cadê meu RARS? Fechei meu RARS. É incrível. Ai, meu Deus do céu.",
        "video_source": "OAC_2022-03-02.mp4"
    },
    {
        "id": 8,
        "timestamp_start": 3801.91,
        "timestamp_end": 3807.91,
        "slide_description": "Como Engenheiro de Computação Sênior, analisei o slide e o contexto anotado da aula de Arquitetura de Computadores. A imagem apresenta uma interface de videoconferência, mas o conteúdo principal da apresentação (slides, diagramas, código) está ausente, exibido como uma tela preta. A análise, portanto, foca nos elementos textuais visíveis na interface da plataforma.\n\n**Conteúdo Textual Transcrito:**\n\nA interface da conferência exibe no cabeçalho o título da sala como \"ConferênciaWeb - Sala de Aula de OAC\". No canto superior direito da área de visualização principal, repete-se o título \"Sala de Aula de OAC\", acompanhado de um temporizador indicando \"64:01\", que provavelmente representa o tempo decorrido da sessão.\n\nNo painel lateral esquerdo, há uma barra de navegação com as seguintes categorias:\n*   \"MENSAGENS\"\n    *   \"Perguntas\" (com ícone de mão levantada)\n    *   \"Bate-papo público\" (selecionado, com ícone de balões de fala)\n*   \"NOTAS\"\n    *   \"Notas compartilhadas\"\n*   \"USUÁRIOS (30)\" (indicando 30 participantes na sala)\n\nA área de \"Bate-papo público\" exibe uma série de mensagens trocadas entre os participantes, com seus respectivos nomes e horários:\n*   Marcus Vinicius Lam... (Você) - Indicando que o usuário atual é Marcus Vinicius.\n*   Victor Hugo Franca Lisboa 14:52: sim\n*   Ualiton Ventura Da Silva 14:53: tendi, brigadim\n*   Ualiton Ventura Da Silva 14:53: os dois kkkk\n*   João Alberto Travassos Evangelista 14:55: melhor\n*   João Alberto Travassos Evangelista 14:55: sim\n*   Victor Hugo Franca Lisboa 14:58: Mas essa mistura as duas de certa forma :)\n*   Ualiton Ventura Da Silva 14:59: wordle\n*   Ualiton Ventura Da Silva 14:59: basicamente\n*   Bruno Vargas de Souza 14:59: o term.oo antigo\n*   Gustavo Lopes Dezan 14:59: kkkk\n*   Ualiton Ventura Da Silva 15:00: saquei kkkkk\n*   Eduardo Ferreira Marques Cavalc... 15:01: como que são as musiquinha\n*   Victor Hugo Franca Lisboa 15:01: sonoplastia\n*   Eduardo Ferreira Marques Cavalc... 15:01: digite \"P\" pra amarelo\n*   Victor Hugo Franca Lisboa 15:02: você erra uma cor e tem que ouvir \"não tinha medo, tal joão do santo cristo...\"\n*   Ualiton Ventura Da Silva 15:03: o número de erros reseta a cada novo nível?\n*   Eduardo Ferreira Marques Cavalc... 15:03: todo mundo aqui é gamer\n*   Victor Hugo Franca Lisboa 15:06: eita\n\nAbaixo do histórico do chat, há um campo de entrada com o placeholder \"Enviar mensagem para Bate-papo púb\" e uma indicação de status \"Victor Hugo Franca Lisboa está digitando\".\n\nUma lista parcial de usuários visível inclui: Andre Carvalho de..., Arthur Brasa de C..., Bruno Berto de Oli..., Bruno Vargas de S..., Eduardo Ferreira M..., Eduardo Perez Lib..., Felipe Dantas Borg..., Felipe de Sousa Fer..., Gabriel Amaro Bax..., Gabriel Kenji Andr..., Gabriel Pereira e B..., Gustavo Lopes De..., Gustavo Pierre Sta..., Gustavo Rodrigues....\n\n**Descrição de Diagramas/Código:**\n\nNão há diagramas (Datapath, Pipeline, Hierarquia de Memória) ou blocos de código (Assembly, C, Verilog) visíveis na tela. A área principal de apresentação da aula está preta, indicando que nenhum conteúdo visual instrutivo está sendo exibido neste momento. A informação é predominantemente textual e contextual, proveniente da interação do chat.\n\nEm resumo, o conteúdo extraído é primariamente metadados da sessão (título, tempo, participantes) e um registro textual de conversas informais e referências a termos como \"wordle\", \"sonoplastia\" e aspectos de \"gamer\" no chat, sem qualquer material técnico direto relacionado à Arquitetura de Computadores.",
        "transcription": "Vamos lá, calma, vocês ficaram meio cegos.",
        "video_source": "OAC_2022-03-02.mp4"
    },
    {
        "id": 9,
        "timestamp_start": 3807.91,
        "timestamp_end": 3813.91,
        "slide_description": "Como um Engenheiro de Computação Sênior, analiso o slide apresentado, extraindo seu conteúdo para um sistema de busca semântica (RAG), focando na informação técnica e sua relevância em Arquitetura de Computadores.\n\nO contexto visual indica que se trata de uma aula online (\"ConferênciaWeb - Sala de Aula de OAC\") com duração de aproximadamente 64 minutos no momento da captura. O conteúdo principal é um documento de texto em formato Microsoft Word, intitulado \"OAC_LAB1.docx\", provavelmente referente a um laboratório ou roteiro de exercícios da disciplina de Organização e Arquitetura de Computadores (OAC). O cabeçalho do documento exibe \"Universidade de Brasília, Departamento de Ciência da Computação\".\n\n**Conteúdo Textual do Documento:**\n\nO documento apresenta uma lista de objetivos e duas seções principais de exercícios práticos, detalhando atividades relacionadas a simuladores, montadores e compiladores em Arquitetura de Computadores.\n\n**Objetivos Pedagógicos:**\n*   Familiarizar o aluno com o Simulador/Montador Rars.\n*   Desenvolver a capacidade de codificação de algoritmos em linguagem Assembly.\n*   Desenvolver a capacidade de análise de desempenho de algoritmos em Assembly.\n\n**Seção (2.5) 1) Simulador/Montador Rars:**\nEsta seção instrui o aluno a baixar e descompactar o arquivo \"Lab1.zip\" do Moodle, que criará dois diretórios.\nO exercício detalha as seguintes tarefas:\n*   **(0.0) 1.1)** No diretório \"System\", o aluno deve abrir o `Rars15 Custom2` (provavelmente uma versão personalizada do simulador RARS, um simulador RISC-V) e carregar o programa de ordenamento `sort.s` (um programa em Assembly). O objetivo é ordenar um vetor pré-definido `V[30]={9,2,5,1,8,2,4,3,6,7,10,2,32,54,2,12,6,3,1,78,54,23,1,54,2,65,3,6,55,31}` em ordem crescente. Deve-se também contar o número de instruções por tipo, o número total de instruções exigido pelo procedimento `sort`, e determinar o tamanho em bytes do código executável e da memória de dados utilizada.\n*   **(2.5) 1.2)** Propõe uma análise de desempenho para o algoritmo em um processador RISC-V operando a `50MHz` com `CPI=1` (Cycles Per Instruction = 1). Para vetores de entrada já ordenados de `n` elementos, na forma `V[n] = {n, n-1, n-2, ..., 2, 1}`:\n    *   **(1.5) a)** O aluno deve escrever equações para os tempos de execução `t_p(n)` e `t(n)` para o procedimento `sort`.\n    *   **(1.0) b)** Para `n={10,20,30,40,50,60,70,80,90,100}`, o aluno deve plotar as duas curvas de tempo (`n x t`) em um mesmo gráfico e comentar os resultados obtidos, analisando a complexidade e escalabilidade do algoritmo em função do tamanho da entrada.\n*   **(0.0) 1.3)** O aluno é instruído a executar o programa `testeECALLV21.s`, que utiliza chamadas de sistema padrão do Rars para entrada e saída de dados via console. Menciona-se que essas chamadas utilizam diretamente as ferramentas KDM MIO BITMAP DISPLAY, indicando a manipulação de I/O em baixo nível.\n\n**Seção (2.5) 2) Compilador cruzado GCC:**\nEsta seção define um compilador cruzado (`cross compiler`) como uma ferramenta que compila código fonte para uma arquitetura de máquina diferente daquela em que está sendo executada. Menciona a disponibilidade de compiladores `gcc` gratuitos para diversas arquiteturas (RISC-V, ARM, MIPS, x86, etc.). O código executável gerado por um `cross compiler` só pode ser executado em uma máquina que possua o processador para o qual foi compilado. O documento destaca o uso das diretivas de compilação `-S` (para gerar arquivo Assembly a partir do código fonte) e `-march` (para definir a arquitetura alvo) no `gcc`.\n\n**Diagramas:**\nNão há diagramas explícitos (como Datapath, Pipeline, ou Hierarquia de Memória) visíveis no conteúdo do slide ou do documento. O material é predominantemente textual, descrevendo tarefas e conceitos.\n\n**Outras Informações Contextuais:**\nA interface do navegador mostra uma janela de chat lateral com mensagens de participantes da aula. Essas mensagens são de natureza informal e não contribuem para o conteúdo técnico extraído do slide para um sistema de busca semântica, sendo irrelevantes para a compreensão do material didático.\n\nEm suma, o slide detalha um conjunto de tarefas práticas de Arquitetura de Computadores, focadas no uso de um simulador RISC-V (Rars) para codificação e análise de desempenho de algoritmos em Assembly (especificamente um algoritmo de ordenação), bem como na compreensão e uso de compiladores cruzados como o GCC para diferentes arquiteturas de processadores.",
        "transcription": "Mas já volto. Pronto, tá. Estamos aqui. Agora eu tenho o RARS aberto.",
        "video_source": "OAC_2022-03-02.mp4"
    },
    {
        "id": 10,
        "timestamp_start": 3813.91,
        "timestamp_end": 3843.46,
        "slide_description": "A tela apresentada corresponde a uma sessão de conferência web para uma aula de Arquitetura de Computadores (OAC), focando em aspectos práticos de simulação e compilação para arquiteturas RISC-V.\n\n**Conteúdo do Documento Microsoft Word (OAC_LAB1.docx):**\nO documento, intitulado \"OAC_LAB1.docx\", está no modo de compatibilidade e apresenta o cabeçalho padrão do Microsoft Word. A guia \"Página Inicial\" está selecionada, mostrando opções de formatação, incluindo \"Courier New\" como fonte atual. O conteúdo visível do documento detalha exercícios e objetivos de aprendizado, estruturados em seções:\n\n*   **Objetivos (Parcialmente visíveis):**\n    *   \"Familiarizar o aluno\"\n    *   \"Desenvolver a capa\" (provavelmente \"capacidade\")\n    *   \"Desenvolver a capa\" (provavelmente \"capacidade\")\n\n*   **Seção (2.5) 1) Simulador/Montador:**\n    *   **Instrução:** \"Faça o download e **deszipe** o\" (orientação para descompactar um arquivo).\n    *   **(0.0) 1.1) No diretório Syste\" (provavelmente \"System\"):**\n        *   Menciona uma estrutura de dados ou sequência: \"V[30]={9,2,5,1,8,2,4,3,6,7,10,\".\n        *   Questões relacionadas a desempenho e memória: \"número de instruções por t\" (provavelmente \"tempo\") e \"executável? E da memória de\".\n    *   **(2.5) 1.2) Considere a execu\" (provavelmente \"execução\"):**\n        *   Refere-se a \"1 ciclo de *clock* para a exe\" (provavelmente \"execução\").\n        *   Define uma sequência ou vetor: \"V[n] = {1, 2, 3, 4, ...n} e orde\" (provavelmente \"ordene\").\n        *   Subitens: \"(1.5) a) Para o proce\" (provavelmente \"processo\") e \"(1.0) b) Para n={10\".\n        *   Instrução: \"Comente os resultados obtid\" (provavelmente \"obtidos\").\n    *   **(0.0) 1.3) Sabendo que as c\" (provavelmente \"condições\" ou \"características\"):**\n        *   Instrução: \"dados, execute o programa BITMAP DISPLAY.\" (Implica a manipulação de dados para exibição gráfica).\n\n*   **Seção (2.5) 2) Compilador cruzado:**\n    *   Discute o uso de um \"compilador cruzado (cros\" - provavelmente \"cross-platform\" ou \"cross-architecture\").\n    *   Instruções para instalação: \"está sendo utilizado. Você p\" (provavelmente \"pode\") \"x86, etc.) e instalar na sua n\" (provavelmente \"máquina\").\n    *   Menciona a dependência do processador: \"que possuir o processador p\" (provavelmente \"particular\").\n    *   Refere-se à geração de código: \"geração do arquivo em Asser\" (provavelmente \"Assembly\").\n\n**Conteúdo do Simulador RARS (RISC-V Assembler and Runtime Simulator):**\nSobreposto ao documento Word, há uma janela do software \"RARS 1.5 Custom 2\", um simulador e montador para a arquitetura RISC-V.\n\n*   **Barra de Menus e Ferramentas:** A barra de menus inclui \"File Edit Run Settings Tools Help\". A barra de ferramentas visível contém ícones para operações comuns de edição de arquivo (novo, abrir, salvar, desfazer, refazer, recortar, copiar, colar) e, mais importante para o contexto da aula, ícones para \"Assemble\" (martelo) e \"Run\" (seta verde). Uma *tooltip* \"Run a file for editing\" aparece sobre o ícone do martelo.\n*   **Painel de Registradores (Control and Status):** Este painel exibe o estado atual dos registradores da CPU RISC-V.\n    *   **Título:** \"Registers\".\n    *   **Colunas:** \"Name\", \"Number\", \"Value\".\n    *   **Registradores visíveis:**\n        *   `zero` (0): `0x00000000`\n        *   `ra` (1): `0x00000000`\n        *   `sp` (2): `0x7ffefffc` (Stack Pointer, um valor comum de inicialização)\n        *   `gp` (3): `0x00000000`\n        *   `tp` (4): `0x00000000`\n        *   `t0` a `t6` (5-7, 28-31): `0x00000000` (Temporários)\n        *   `s0/fp` a `s11` (8-9, 18-27): `0x00000000` (Registradores salvos/frame pointer)\n        *   `a0` a `a7` (10-17): `0x00000000` (Argumentos de função)\n        *   `pc` (Program Counter): `0x00000000` (Endereço da próxima instrução a ser executada).\n    *   A maioria dos registradores mostra o valor `0x00000000`, exceto o `sp`, indicando um estado inicial ou pós-reset.\n*   **Painel de Velocidade de Execução:** Uma caixa de texto acima dos registradores indica \"Run speed at max (no interaction)\".\n*   **Abas Inferiores:** Abas \"Messages\" e \"Run I/O\" são visíveis na parte inferior da janela do RARS, sugerindo painéis para logs do simulador e interação de entrada/saída do programa, respectivamente.\n\n**Bate-papo da Conferência Web:**\nÀ esquerda da tela, há um painel de bate-papo com a aba \"Bate-papo público\" selecionada. As mensagens exibem interações entre os alunos e, possivelmente, o professor. Embora muitas sejam informais (\"kkkk\", \"saquei kkkkk\", \"eita\"), algumas sugerem engajamento com o conteúdo da aula ou cultura tecnológica:\n*   \"tendi, brigadim\" (entendido, obrigado)\n*   \"o term.oo antigo\" (possível referência a termos técnicos antigos ou a uma ferramenta específica)\n*   \"como que são as musiquinha\", \"sonoplastia\", \"digite 'P' pra amarelo\", \"você erra uma cor e tem que ouvir 'não tinha medo, tal joão do santo cristo...'\" (estas mensagens podem indicar discussões relacionadas a aplicações gráficas ou multimídia, possivelmente ligadas ao exercício \"BITMAP DISPLAY\" mencionado no documento Word, ou apenas interações sociais).\n*   \"o número de erros reseta a cada novo nível?\" e \"todo mundo aqui é gamer\" (sugere um contexto onde a gamificação ou conceitos de jogos são relevantes, ou simplesmente uma comunidade com interesses em jogos).\n\nEm síntese, a imagem retrata um ambiente de aprendizado prático em Arquitetura de Computadores, onde os alunos são instruídos a utilizar um simulador/montador RISC-V (RARS) e um compilador cruzado para desenvolver e testar programas em Assembly, incluindo um para exibição gráfica via BITMAP DISPLAY. O estado dos registradores do RARS é monitorado, e há uma interação ativa, embora mista, no bate-papo.",
        "transcription": "Então, vamos fazer essa questão 1.1. Está muito grande, então, no diretório System, abra o RARS. Tá aqui aberto. E carregue o programa de ordenamento `sort.s`. Então, vamos carregar o programa de ordenamento `sort.s`. Ah, meu Deus, não, vou fazer diferente. Eu abri o RARS que tem lá no diretório que eu acho que é...",
        "video_source": "OAC_2022-03-02.mp4"
    },
    {
        "id": 11,
        "timestamp_start": 3843.46,
        "timestamp_end": 3870.74,
        "slide_description": "Como um Engenheiro de Computação Sênior, analisei o slide e o conteúdo anotado fornecidos. A imagem apresenta uma interface de webconferência, não um slide técnico de Arquitetura de Computadores no sentido tradicional de diagramas ou código.\n\n**1. Transcrição de Texto Visível:**\n\n*   **Título da Sala/Sessão:** \"Sala de Aula de OAC\" (Arquitetura de Computadores).\n*   **Duração da Sessão:** \"64:54\" (64 minutos e 54 segundos).\n*   **Nome do Usuário Atual (Provável Apresentador/Moderador):** \"Marcus Vinicius Lam...\"\n*   **Menu Lateral - Seções:**\n    *   \"MENSAGENS\"\n        *   \"Perguntas\"\n        *   \"Bate-papo público\" (selecionado)\n    *   \"NOTAS\"\n        *   \"Notas compartilhadas\"\n    *   \"USUÁRIOS (30)\"\n*   **Conteúdo do Bate-papo Público (Chat):**\n    *   **Victor Hugo França Lisboa 14:52:** sim\n    *   **Ualiton Ventura Da Silva 14:53:** tendi, brigadim\n    *   **Ualiton Ventura Da Silva 14:53:** os dois kkkk\n    *   **João Alberto Travassos Evangelista 14:55:** melhor\n    *   **João Alberto Travassos Evangelista 14:55:** sim\n    *   **Victor Hugo França Lisboa 14:58:** Mas essa mistura as duas de certa forma :)\n    *   **Ualiton Ventura Da Silva 14:59:** wordle\n    *   **Ualiton Ventura Da Silva 14:59:** basicamente\n    *   **Bruno Vargas de Souza 14:59:** o term.oo antigo\n    *   **Gustavo Lopes Dezan 14:59:** kkkk\n    *   **Ualiton Ventura Da Silva 15:00:** saquei kkkkk\n    *   **Eduardo Ferreira Marques Cavalc... 15:01:** como que são as musiquinha\n    *   **Victor Hugo França Lisboa 15:01:** sonoplastia\n    *   **Eduardo Ferreira Marques Cavalc... 15:01:** digite \"P\" pra amarelo\n    *   **Victor Hugo França Lisboa 15:02:** você erra uma cor e tem que ouvir \"não tinha medo, tal joão do santo cristo...\"\n    *   **Ualiton Ventura Da Silva 15:03:** o número de erros reseta a cada novo nível?\n    *   **Eduardo Ferreira Marques Cavalc... 15:03:** todo mundo aqui é gamer\n    *   **Victor Hugo França Lisboa 15:06:** eita\n    *   **Campo de entrada de texto:** \"Enviar mensagem para Bate-papo púb...\"\n\n**2. Descrição de Diagramas e Fluxo de Dados:**\n\nNão há diagramas de Arquitetura de Computadores visíveis (como Datapath, Pipeline, Hierarquia de Memória) nem qualquer código (Assembly, C, Verilog) na área principal da tela, que está escura e sem conteúdo de apresentação. A tela exibe apenas a interface de uma plataforma de webconferência, focando em elementos de interação (chat e lista de usuários) e metadados da sessão (título da sala, duração).\n\n**Resumo para Sistema de Busca Semântica (RAG):**\n\nEste recurso visual representa uma interface de webconferência de uma \"Sala de Aula de OAC\" (Arquitetura de Computadores) com duração atual de 64 minutos e 54 segundos. A área de apresentação principal está vazia/escura, indicando que nenhum slide, diagrama técnico (Datapath, Pipeline, Hierarquia de Memória) ou código (Assembly, C, Verilog) está sendo exibido no momento da captura. O conteúdo textual mais relevante é o transcript de um \"Bate-papo público\" entre os participantes da aula, que inclui interações informais e perguntas não diretamente relacionadas a conceitos técnicos de arquitetura, como \"sim\", \"tendi, brigadim\", \"melhor\", \"wordle\", \"basicamente\", \"o term.oo antigo\", \"sonoplastia\", e discussões sobre \"erros\" e \"gamer\", bem como a menção de \"musiquinha\" e \"P pra amarelo\". A lista de 30 usuários participantes também é visível. Este artefato é mais informativo sobre a dinâmica e ambiente de uma aula online do que sobre o conteúdo técnico específico de Arquitetura de Computadores que estaria sendo ministrado.",
        "transcription": "mais tranquilo, então vamos lá.",
        "video_source": "OAC_2022-03-02.mp4"
    },
    {
        "id": 12,
        "timestamp_start": 3870.74,
        "timestamp_end": 4603.77,
        "slide_description": "Como Engenheiro de Computação Sênior, procedo à análise do slide apresentado, extraindo as informações técnicas para um sistema de busca semântica (RAG).\n\nO contexto visual é uma aula online de Arquitetura de Computadores (OAC) da Universidade de Brasília, ministrada pelo Prof. Marcus Vinícius Lammert. A ferramenta central em exibição é o simulador RARS (RISC-V Assembler and Runtime Simulator) versão 1.5 Custom 2, que está carregando o arquivo `sort.s`, um programa em Assembly RISC-V localizado no caminho `C:\\Users\\mvlam\\Dropbox\\Kiko\\Disciplinas\\UnB\\OAC\\2021-2\\Lab1\\System\\Exemplos\\sort.s`.\n\n**Conteúdo do Simulador RARS:**\n\n1.  **Segmento de Texto (Código Assembly):**\n    Uma janela exibe o código assembly e sua representação binária e endereços. Colunas visíveis incluem `Address`, `Code` (código de máquina hexadecimal), `Basic` (instrução assembly básica) e `Source` (código fonte com pseudo-instruções e labels).\n    O programa `sort.s` apresenta labels como `MAIN`, `SWAP`, `SORT`, `exit1`, `exit2`, `SHOW`, `SORT1`, `fim1` e `Vetor`, indicando a implementação de um algoritmo de ordenação e rotinas auxiliares.\n    Alguns trechos de código assembly RISC-V visíveis incluem:\n    *   `0x00400000 0x0f010517 auipc x10, 0x0f010` -> `la a0,Vetor`\n    *   `0x00400004 0x00050513 addi x10, x10, 0x000...`\n    *   `0x00400008 0x00000093 addi x10, x0, 0x00000020` -> `li a0,2`\n    *   `0x0040000c 0x0f010517 auipc x10, 0x0f010` -> `la a0,Vetor`\n    *   `0x00400018 0x00000093 addi x10, x0, 0x00000020` -> `li a0,12`\n    *   `0x0040001c 0x00000017 call 6, x1, x0, 0x0000000C` -> `jal SHOW`\n    *   `0x00400020 0x0f010517 auipc x10, 0x0f010` -> `la a0,Vetor`\n    *   `0x00400028 0x00000093 addi x10, x0, 0x00000020` -> `li a0,24`\n    *   `0x0040002c 0x00000017 call 6, x1, x0, 0x00000004` -> `jal SHOW`\n    *   A linha destacada na execução é `0x00400030 0x00000019 call 6, x1, x0, 0x00000020` que se traduz em `ecall` (chamada de sistema).\n    *   Outras instruções visíveis incluem: `0x00400034 0x00259313 slli x6, x10, x0, 0x00000002` (`SWAP: slli t1,a2,2`) e `0x00400038 0x00650333 add x6, x10, x6` (`add t1,a0,t1`).\n\n2.  **Segmento de Dados:**\n    Uma tabela mostra o conteúdo da memória de dados, com endereços (iniciando em `0x10010000`) e valores em formato hexadecimal, offset por 0, +4, +8, +c, +10, +14, +18. É possível observar alguns valores não nulos como `0x00000002`, `0x00000001`, `0x00000004`, `0xfffffffc` (provavelmente -4 em complemento de dois) e `0x00000037`.\n\n3.  **Console de Mensagens:**\n    Indica o estado da simulação:\n    *   `Assemble: operation completed successfully.` (Montagem concluída com sucesso.)\n    *   `Go: running sort.s` (Execução de `sort.s` iniciada.)\n    *   `Go: execution paused at breakpoint: sort.s` (Execução pausada em um breakpoint.)\n\n**Análise de Desempenho (Contador de Instruções):**\n\nUma janela separada, intitulada \"Instruction Counter, Version 1.0 (Felipe Lessa)\", fornece estatísticas dinâmicas sobre a execução do programa.\n*   **Instruções executadas até o momento:** 335.\n*   **Distribuição por tipo de instrução RISC-V:**\n    *   R-type: 3 (0%)\n    *   R4-type: 0 (0%)\n    *   I-type: 264 (79%)\n    *   S-type: 0 (0%)\n    *   B-type: 33 (9%)\n    *   U-type: 33 (9%)\n    *   J-type: 0 (0%)\n    Esta análise quantifica a frequência de cada formato de instrução, sendo um dado crucial para entender o perfil de execução do código e a demanda sobre diferentes unidades funcionais da arquitetura (e.g., a alta proporção de instruções I-type sugere um uso intensivo de operações com operandos imediatos).\n\n**Conceitos Arquitetônicos Implícitos/Representados:**\n\nEmbora não haja diagramas explícitos de datapath, pipeline ou hierarquia de memória, o simulador e suas informações representam esses conceitos:\n*   **Organização da Memória:** A separação e visualização dos `Text Segment` e `Data Segment` ilustra a organização da memória, fundamental em arquitetura.\n*   **Conjunto de Instruções (ISA) RISC-V:** A lista de instruções assembly e a categorização por tipo (R, I, S, B, U, J) demonstram diretamente a especificação do ISA RISC-V.\n*   **Ciclo de Instrução e Execução:** O \"Instruction Counter\" e o status de \"running\" e \"paused at breakpoint\" refletem os estágios de busca, decodificação, execução e escrita de volta do ciclo de instrução.\n*   **Arquitetura do Processador:** A simulação de registros (visíveis nas abas Registers e Floating Point, embora não detalhadas) e a execução das instruções mapeiam-se diretamente aos componentes de um datapath (ALU, banco de registradores, unidade de controle, etc.). A distribuição de tipos de instrução sugere a complexidade e frequência de uso de diferentes componentes do processador.\n\nEste conjunto de informações é valioso para um sistema RAG, pois descreve detalhadamente o ambiente de simulação, o código executado e a análise de desempenho, conectando-os diretamente a conceitos fundamentais de Arquitetura de Computadores.",
        "transcription": "abri o `sort.s` que está dentro de exemplos. Está aqui `sort.s`. O que que é esse programinha aqui então? Esse programinha é aquele programinha de `sort` que eu deixei para vocês fazerem no final de uma aula que diz: \"compilem esse programinha em C para Assembly\", tá, usando o que a gente já tinha visto, né, de Assembly. Então, é esse aqui, tá? Então aqui eu tenho um vetor, né, de 32 posições, 32, né? 30, aqui, que legal, lá, tá 32. Então, vamos verificar se é de 30 ou 32 mesmo. Aqui vai até que número 4 e -4, também tá errado 4 e -4. 32. Depois eu vou arrumar isso aqui e passo para vocês, tá? Então, dado esse vetor de 32 posições, que é esse aqui, ordená-lo em ordem crescente e contar o número de instruções por tipo e o número total pelo procedimento do `sort`, tá? Qual o tamanho em bytes do código executável e da memória de dados usada? Então, análise do programa de vocês também.\n\nEntão, vamos executar isso aqui. E executar. Ordenar em ordem crescente é o que ele já tá agora, tá? Então, a gente só precisa efetivamente rodar o programa, tá? Então, compilei — quer dizer, compilei não, montei — tem o código de máquina agora. Então, essa aqui é a memória de código e essa aqui é a memória de dados. Então, na memória de dados eu tenho meu vetor aqui: 9, 2, 5, 1, blá blá blá, até o último que é -4. Esse aqui. E vamos executar. Então, o que ele deve fazer aqui? Ele deve primeiro mostrar o vetor. Então, `a0` recebe o endereço desse vetor, quer dizer, o label do vetor que é o endereço dele na memória. E `a1` é a quantidade de elementos que, nesse caso, é 32. E chama `jal SHOW` que ele vai mostrar o vetor na tela. Depois, com esses mesmos argumentos do vetor e do `n`, eu vou chamar `jal SORT` que ele vai ordenar esse vetor. E depois eu vou mostrar de novo esse vetor na tela. Então, se eu ordenei aqui, aqui eu devo mostrar ele ordenado e chamo o `exit`, o `syscall 10`.\n\nEntão, vamos executar. Já foi tudo aqui, certo? Então, ele mostrou aqui o vetor original e aqui embaixo o vetor ordenado. Certo? Então, o que esse programa faz? Ordena o vetor. Até aí, tudo bem. Alguma dúvida em como se faz isso aqui? Não. Todo mundo conseguiu fazer aí, abrir o `sort.s` e executar? Ok, pessoal, então vamos lá. Tá, vamos lá. Agora, o que que é para ordenar em ordem crescente? Fizemos isso. Contar o número de instruções por tipo e o número total exigido pelo procedimento `SORT`. Então, o que que eu quero que, apenas, ah, o procedimento `SORT`, eu quero contar o número de instruções desse procedimento aqui, tá? Então, uma das formas que a gente tem, tá, vamos voltar aqui. Apaguei tudo. Onde é que tá o procedimento `SORT`? Então, o procedimento `SORT` tá aqui, ó. É essa partezinha daqui. Só que eu quero ah contar quantas instruções foram necessárias para esse procedimento `SORT` aqui, `SORT`. Então, o que que nós vamos fazer? Então, o `SORT` ele é chamado aqui, certo? `jal SORT`. Então, nós vamos colocar um breakpoint na linha do `SORT` antes da chamada desse `jal` e um outro breakpoint depois da chamada desse `jal`. Por que que eu preciso fazer isso? Porque eu quero utilizar agora uma ferramentazinha chamada \"Instruction Counter\", esse aqui. Tá aqui. Ele foi desenvolvido por um ex-colega de vocês chamado Felipe Lessa, tá, durante o o nosso curso de OAC, tá? Então, aqui ele vai te mostrar os diferentes tipos de instruções que estão sendo executadas, né, pelo RARS.\n\nEntão, eu vou conectar o programa, certo? Conectei. E agora eu vou executar. Então, o que que vai acontecer? Quando eu mandar ele executar, ele vai executar todo o programa até essa linha aqui. Daí ele vai parar. Então, vamos executar. Ok. Então, ele executou tudo e parou aqui, certo? Então, até esse momento eu tenho essa contagem de instruções: 335 instruções, sendo 3 tipo R, 264 tipo I, 33 tipo B de branch, 2 tipo U, né, `lui` e `auipc`, e 33 de `jal`. Certo? Então, essa aqui seria a nossa contagem de instruções por tipo, certo? Só que desde o início até aqui, mas não é isso que eu quero. Eu quero a contagem de instruções necessárias para a execução desse procedimento. Então, eu vou resetar isso aqui, porque esse número aqui não me interessa. E vou mandar continuar, certo? Então, ele vai continuar a partir daqui. Ok. Ele executou esse `jal SORT` e parou aqui. Por isso que eu tive que colocar dois breakpoints: um antes para eu poder resetar o contador e um depois para eu poder obter esse resultado, certo? Então, nesse caso aqui, para o `SORT`, eu precisei de 4008 instruções, sendo tipo R essa quantidade, tipo I, tipo S, tipo B e tipo J. Ok? Entendido isso? Então, esse aqui é o que eu pedi ali. Como que se mede essas essa quantidade de instruções por tipo aqui que é o que a ferramentazinha nos dá. Então, aqui: ordenar a memória crescente e contar o número de instruções por tipo e o número total exigido pelo `SORT`. Beleza. Fiz isso. Qual é o tamanho em bytes do código executável? Por que que isso é importante? Porque às vezes a gente tem pouca memória RAM e é interessante que o código executável seja pequeno. Então, no nosso caso aqui, como é que eu vou medir quantos bytes precisou esse meu código, esse meu programa em linguagem de máquina? Aceito sugestões. Como que eu vejo a quantidade de bytes que isso aí precisou? Tu tu tu tu tu. Vamos lá, pessoal, aceitando sugestões. Não tem a mínima ideia, né? Exatamente, tá? Então, vou cancelar isso aqui, pode tirar isso aqui. O tamanho em bytes do código. Ele começa nesse endereço aqui, `0x00400000`, e ele vai até esse endereço aqui, `0x00400110`. Significa que ele tem `0x110` — que ele tem `0x110` bytes. Isso significa que meu código tem `0x110` bytes? Ah, não. Porque o tamanho da instrução é de 4 bytes e tem mais um erro aqui que eu fiz. Qual é, qual é o outro erro? Então, o tamanho total é 440 bytes, já que cada instrução são 4. Se tem `0x110` aqui, 440. Tá em hexadecimal esse negócio, tá? Então, esse aqui é meu último endereço. Se eu quero a contagem de instruções, eu tenho que contar também os 4 bytes dessa instrução aqui, tá? Então, vai ser até o endereço `0x00400114` porque eu preciso contar essa instrução, certo? Por isso que eu tenho que botar mais 4 aqui. Então, calcula desse aqui, depois soma 4, tá? Então, quanto é `0x110` em decimal? `0x110` não, né? `0x110`. `0x110` em decimal vale quanto? `1 * 16^2 + 1 * 16^1 + 0 * 16^0`. Ah, `16^2 + 16` deu 272. É isso? Isso. Beleza. Aí esse resultado vocês somam os 4 últimos bytes aqui. Então, 276. Então, 276 bytes é o quanto vocês precisam de memória de programa para poder executar esse programa aqui. Quanto que ele gasta na memória? Não, não é 272 vezes 4. Porque esse endereço aqui já está em bytes. A nossa memória é *byte addressing*. Ele já está andando aqui de 4 em 4, certo? Então, é 272 mais essa última aqui, mais 4. Então, 276, certo, João? Porque se fosse parar aqui no `0x00400004`, quantos bytes tem até o `0x00400004` de instruções? Até aqui isso que é 4 mais 4, né? O 4 que é essa instrução aqui, mais 4 dessa instrução aqui, certo? Então, tem 8 bytes aqui. Então, sempre tem que somar os últimos 4, tá? Esses últimos aqui. Beleza. Então, já sabemos como que a gente, qual o tamanho em bytes do código e a memória de dados usada. Ok. Então, nesse caso aqui a memória de dados.",
        "video_source": "OAC_2022-03-02.mp4"
    },
    {
        "id": 13,
        "timestamp_start": 4603.77,
        "timestamp_end": 5512.62,
        "slide_description": "O slide apresenta o conteúdo de uma aula de Arquitetura de Computadores (OAC), focando em um laboratório intitulado \"OAC_LAB1.docx\". O tópico principal é o exercício \"(5.0) 3) Senha (Mastermind)\", que detalha uma tarefa de programação e análise de desempenho.\n\n**Conteúdo Transcrito:**\n\n**Título do Documento:** OAC_LAB1.docx\n**Seção:** (5.0) 3) Senha (Mastermind)\n\n**Descrição do Jogo Mastermind:**\n\"O jogo Senha (https://pt.wikipedia.org/wiki/Mastermind) é um jogo de 1971 que consiste em descobrir um código de 4 cores de uma lista de N cores a partir tentativas e de dicas baseadas nas cores da tentativa.\"\n\"Pino Branco: Cor certa no lugar errado\"\n\"Pino Preto: Cor certa no lugar certo\"\n\n**Imagem de Diagrama/Objeto:**\nVisivelmente, há uma imagem de um tabuleiro físico do jogo Mastermind. O tabuleiro é de madeira, com múltiplas fileiras de orifícios para pinos coloridos e espaços para pinos de feedback. São visíveis pinos coloridos (vermelho, azul, verde, amarelo, branco, preto, laranja) arranjados em padrões de tentativas, e pinos menores de feedback (brancos e pretos) adjacentes a cada tentativa, ilustrando o mecanismo de dicas do jogo.\n\n**Tarefas e Requisitos do Exercício:**\n\n*   **(1.0) 3.1) Crie um programa no Rars que emule o jogo com máximo de 10 tentativas e N inicial igual a 5;\"**\n    *   Requisito de programação: Desenvolver uma emulação do jogo Mastermind.\n    *   Plataforma de implementação: Simulador Rars (comumente associado a arquiteturas MIPS, mas o item 3.6 especifica RISC-V).\n    *   Parâmetros iniciais: Limite de 10 tentativas e um conjunto inicial de 5 cores disponíveis (N=5).\n\n*   **(1.0) 3.2) Cada cor possui um efeito sonoro único quando colocada no tabuleiro. O preto possui uma pequena música e o branco outra pequena música.\"**\n    *   Requisito de interface/multimídia: Implementação de feedback sonoro diferenciado para cada cor, incluindo sons específicos para os pinos de feedback (preto e branco). Isso implica manipulação de saída de áudio pelo programa.\n\n*   **(1.0) 3.3) As cores são escolhidas através do teclado, escreva a codificação das teclas em cores na tela.\"**\n    *   Requisito de entrada/saída: Entrada de dados via teclado para seleção de cores, com a visualização da codificação das teclas na interface do usuário.\n\n*   **(1.0) 3.4) A cada vitória N=N+1, isto é, o número de cores é incrementado, aumentando a dificuldade do próximo nível.\"**\n    *   Requisito de lógica de jogo: Implementação de progressão de dificuldade, onde o número de cores disponíveis (N) aumenta após cada vitória.\n\n*   **(1.0) 3.5) Filme vc jogando até o máximo N que seu grupo conseguir. (Não vale usar cheat!!!)\"**\n    *   Requisito de entrega: Gravação de um vídeo demonstrando o jogo, com uma advertência contra o uso de \"cheat\".\n\n*   **(1.0) 3.6) Faça os gráficos Nxt_exec e N×I, onde t_exec é o tempo de execução e I o número de instruções requeridas pelo seu algoritmo para a análise do pior caso da tentativa do jogador. Sabendo que o Rars simula uma CPU RISC-V com CPI=1, qual a frequência de clock desta CPU?\"**\n    *   Requisito de Análise de Arquitetura de Computadores e Desempenho:\n        *   Geração de gráficos: Dois gráficos são solicitados: `N` versus `t_exec` (tempo de execução) e `N` versus `I` (número de instruções).\n        *   Foco da análise: O pior caso para uma tentativa do jogador.\n        *   Contexto da CPU: O simulador Rars é especificado para emular uma CPU RISC-V.\n        *   Métrica de desempenho: Cycles Per Instruction (CPI) é dado como 1 (CPI=1).\n        *   **Questão Central:** Determinar a frequência de clock da CPU simulada. Esta questão exige a aplicação da equação fundamental de desempenho `Tempo de Execução = (Número de Instruções * CPI) / Frequência de Clock`, onde o aluno deve inferir a frequência de clock a partir dos dados coletados (`t_exec`, `I`) e o valor de `CPI`.\n\n**Dicas:**\n\"https://www.youtube.com/watch?v=dMHxyulGrEk\" (Link para recurso externo, provavelmente um tutorial ou explicação).",
        "transcription": "usada é a própria memória de dados, né, do `.data`. A gente não usou pilha aqui. Se a gente tivesse usado pilha, né, aí sim a gente teria que contar quanto dessa pilha foi utilizada para saber quanto de memória de dados foi utilizada. Como a gente não utilizou a pilha, então é simplesmente 32 words, né? O vetor tem 32 palavras. Então 32 vezes 4 dá quanto? 32 palavras vezes 4 bytes cada uma: 128, certo? Então 128 bytes é o quanto foi necessário para a execução desse programa, tá? Porque não temos pilha aqui. Se a gente tivesse pilha, aí provavelmente a gente teria utilizado mais, porque a pilha vai crescer, depois a pilha diminui, e a gente tem que ver o valor máximo que a pilha chegou para saber qual é o tamanho de memória que a gente precisaria. Ok? Então cuidem quando vocês têm programas com pilha, que vocês têm que ficar monitorando qual é o máximo valor que vocês colocam na pilha para saber o quanto de memória vocês precisaram. Beleza? Deixa eu ver o que é mais aqui. Opa, não é esse, esse não, não é esse, esse. Então, esse aqui a gente fez, então vocês podem colocar no relatório que foi feito isso: o tamanho em bytes foi de tanto, o tamanho da memória de dados foi de tanto.\n\nA 1.2, essa aqui vale 2.5 pontos, então esse aqui é pra vocês fazerem mesmo, tá? Então, considera a execução do algoritmo em um processador com frequência de clock de 50 MHz. Então agora eu estou usando esse `sort`, quer dizer, desculpe, esse programa `sort.s` nesse processador aqui, que tem frequência de 50 MHz, que necessita um ciclo de clock para cada instrução, quer dizer, `CPI = 1` para os vetores de entrada de N elementos já ordenados. Então esse aqui, ó, então o que que significa um vetor de entrada de N elementos já ordenados? Significa que aqui, ao invés de ter esse valor aqui, por exemplo, eu vou ter 1, 2, 3, 4, 5, 6 até N, tá? Então, vetor de N elementos já ordenado. E o outro vetor ordenado da maneira inversa, certo? Então, começando em N, indo até 1. Por que que a gente está fazendo isso? A gente está calculando aqui, estimando aqui o melhor caso e o pior caso para o algoritmo de ordenação. Qual é o melhor caso? Quando que ele vai ter menos trabalho para um algoritmo de ordenação? Quando ele já estiver ordenado. Então, para esse aqui vai ser o melhor caso. E qual é o pior caso? Principalmente para esse aqui, que é `Bubble Sort`, tá? Esse aqui, que ele está inversamente ordenado por `Bubble Sort`, é aquele que ele vai precisar fazer mais trocas, certo? Então, esse aqui seria o pior caso, certo? Então, para esses vetores de melhor caso e de pior caso para o procedimento `sort`, escreva as equações dos tempos de execução em função de N, tá? Então, dado o tamanho do vetor aqui, eu quero saber qual é a equação do tempo de execução desse vetor ordenado, né, em função de N. E qual é a equação desse vetor não ordenado, quer dizer, o vetor inversamente ordenado, em função de N. Entenderam o que é pra fazer? Quero duas equações aqui: uma para quando eu tenho o melhor caso, e a outra quando eu tenho o pior caso, certo? Em função de N, tá? N valendo 1, 2, 3, 4 e assim por diante.\n\nAhm, para N igual a 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, plotem em escala as duas curvas, essas duas curvas aqui, né, que seriam essas duas equações, em um mesmo gráfico N por t. Quer dizer, eu vou fazer um gráfico onde o eixo horizontal é o N, e ahm, não, desculpe, o eixo horizontal é o N e o eixo vertical é o t. Quer dizer, para N igual a 1 eu vou ter um determinado tempo de execução, para N igual a 2 eu vou ter outro tempo de execução, para N igual a 100 eu vou ter outro tempo de execução, certo? Eu quero que vocês então façam esse gráfico com esses valores de N aqui: 10, 20, 30, 40 até 100. Então vão ser um gráfico com 10 pontinhos, 10 ou 11? 1, 2, 3, 4... 10 pontinhos, tá? Um para essa curva aqui e outro para aquela curva, num mesmo gráfico, certo? Eu quero essas duas curvas sendo plotadas num mesmo gráfico pra gente ver qual é o limite inferior e qual é o limite superior. Assim, qualquer outro vetor, né, vocês vão ter entre esses dois limites, certo? O tempo de execução dele. Entenderam isso aqui? Então, é assim que a gente analisa para algoritmos cuja entrada, né, a gente não conhece. Então, a gente tem que sempre verificar o melhor caso e o pior caso. Os outros vão estar entre esses dois, tá? Por exemplo, esse aqui, esse aqui não é nem melhor caso nem pior caso, então ele vai estar em um ponto entre essas duas curvas limites. Ok? Entendido isso, pessoal? Dúvidas a respeito do que é pra fazer aqui? Ou vocês entenderam tudo ou vocês não entenderam nada. Nenhuma dúvida? Nenhuma dúvida. Ok, vamos continuar.\n\nEsse item 1.3 a gente já fez, né? Que é quando eu executei o teste `iCalv 21`, né? Então, que eu fiz todos aqueles comentários sobre as funções `iCalv` que usam o `KDMIO` e o `bitmap display`, né? A leitura por essa ferramenta do teclado por essa ferramenta e mostrar nessa ferramenta. Então, esse aqui a gente já fez. Beleza? Esse aqui também valia 0 pontos, era só demonstração mesmo, então esse aqui não precisa estar no relatório, tá? Mas esse aqui é bom vocês colocarem, mesmo a gente já tendo feito, e esse aqui vocês vão colocar no relatório. Tranquilo, pessoal? Vocês muito calados, eu acho que beleza. Então, lembrem-se que os monitores estão aí pra ajudar vocês, tá? Esses aqui, monitores, já fizeram esse aqui. Os monitores já fizeram, mas esse aqui os monitores nunca fizeram, tá? Então, esse aqui eles vão ser tão exploradores pra fazer esse jogo quanto vocês, tá? Então, vocês não vão ter tanta ajuda assim, tá? Mas como eles são mais experientes em programação `RISC-V`, eles vão poder dar boas dicas, né, de como fazer isso aqui. Todos os itens são via `RARS`? Sim, todos os itens são via `RARS`. Hum, beleza.\n\nSe por acaso eu não tivesse essa ferramenta de contagem de instruções, certo? Vamos supor que eu esteja trabalhando num processador mesmo e não no `RARS`. O `RARS` me permite fazer um monte de monitoramento e essa contagem de instruções é uma delas, tá? Então, se eu não tivesse, se eu tivesse trabalhando efetivamente num processador `RISC-V`, como é que eu iria calcular tempo de execução, quantidade de instruções pra gente poder estimar frequência, pra gente poder estimar `CPI` ou o que quer que seja? Então, no `RISC-V`, tá, especificamente no `RISC-V`, eu já expliquei pra vocês que ele tem, além do banco de registradores... Deixa eu mostrar ele aqui. O... Está aqui. Ele tem o banco de registradores normais de inteiros, ele tem o banco de registradores de ponto flutuante, que são esses aqui. Pronto, agora sim, de ponto flutuante. E eles têm esses `Control Status Registers` que são 4096 registradores aqui. Por isso que os números começam a 0, 1, 2, 3 e de repente passa pra 3072, 3072, 3202 e por aí vai. Esse banco de registradores tem 4096 posições. Então, na realidade é um pedacinho de memória de 4... 4 vezes 4 kilobytes. 4096 vezes 4, que dá 16 kilobytes. Isso, 4096 vezes 4 dá 16 kilobytes. Então, é um pedacinho de memória de 16 KB isso aqui. E entre as características, pra que serve isso aqui? Pra gente monitorar o que está sendo rodado no processador. Então, a gente já viu aqui, por exemplo, o `FCSR`. Esse aqui dá, então, aquelas definições de ponto flutuante, né? Nessa aula agora, vamos apresentar esses outros 6 registradores aqui, tá? O `mcycle`, `mtime`, `minstret`, o `mcycleh`, `mtimeh`, `minstreth`.\n\nEntão, tá aqui. Então, nesse mesmo roteiro, lá na última página, a gente tem isso aqui. Então, o `RISC-V` possui um banco de 4096 registradores que armazena várias informações úteis e que são lidos por essa instrução aqui, tá, que é `CSRR`, que seria `Control Status Register Read`, certo? A gente tem `CSRRW`, `CSRRS`, `CSRRC`, tem várias outras instruções, mas o que a gente vai usar aqui nesse laboratório é só essa aqui. O que essa instrução faz? Ela lê desse registrador. O número do registrador é um valor de 12 bits. Quer dizer, desculpe, 4096. Eu preciso de quantos bits para escolher um entre 4096 posições? Quantos bits eu preciso para escolher um de 4096 registradores? Quantos bits eu preciso para escolher um de 32? Vamos lá, um de 32. Eu tenho um banco de registradores que tem 32 posições. Quantos bits eu preciso para escolher um de 32? Como é que vocês definiam o `rd`, `rs1`, `rs2`? Isso era 5 bits. Quer dizer que com 5 bits eu escolho entre 0 e 31. Então, para ser entre 0 e 4095, eu vou precisar de 12 bits, certo? Então, esse aqui é um número imediato de 12 bits que corresponde ao número do registrador que vocês querem ler. Então, vocês podem ler qualquer um desses, certo? E `t1` vai ser o conteúdo do registrador que foi lido. Esse registrador lido, então, vai ser escrito em `t1`. Entendido isso, pessoal? Então, eu estou lendo desse banco de registradores e colocando no banco de registradores principal o conteúdo de um desses registradores.\n\nEsses registradores que a gente vai ver hoje, que é o `mtime`, `mtimeh`, `mcycle`, `mcycleh`, eles são registradores de 64 bits. Só que como a gente está trabalhando com um `RV32` aqui, então o nosso processador é de 32 bits. Para eu colocar um número de 64 bits, eu tenho que dividir entre ele e a parte alta dele. Então, a parte baixa `mcycle` e a parte alta `mcycleh`. Então, seriam os 32 bits menos significativos e os 32 bits mais significativos desse registrador, certo? Então, se eu concatenar o `mtime` com `mtimeh`, eu vou ter um contador de tempo do sistema em milissegundos, certo? Então, esse contador, quando vocês ligam a máquina, ele começa com 0. O `h` é o mais significativo. `MSW` (Most Significant Word) é a word mais significativa. Essa aqui é a `LSW` (Less Significant Word), word menos significativa. Beleza? Então, isso aqui vai te dar uma contagem de tempo em milissegundos. Quer dizer, esse registrador `mtime` quando vocês ligam ele começa a contar, simplesmente a cada um milissegundo ele aumenta a contagem. Então, ele é um contador, beleza? De tempo. `minstret`, `minstreth`. 32 bits aqui, 32 bits aqui. Ele te dá um número de instruções executadas. Quer dizer, desde o momento que tu liga o processador, quantas instruções ele executou? Tá? Então, vocês... Ei, eu caí aqui? Espero que não, né? Eu caí, pessoal? Que coisa, pessoal! Eu caí, eu não acredito! Net, santa net!",
        "video_source": "OAC_2022-03-02.mp4"
    },
    {
        "id": 14,
        "timestamp_start": 5512.62,
        "timestamp_end": 5598.04,
        "slide_description": "Como Engenheiro de Computação Sênior, analisei cuidadosamente a imagem fornecida, que representa um slide de uma aula de Arquitetura de Computadores.\n\nApós a análise, verifico que a imagem está completamente em preto. Não há texto, títulos, código (Assembly, C, Verilog) visíveis, nem quaisquer diagramas (Datapath, Pipeline, Hierarquia de Memória) ou outros elementos gráficos discerníveis. Consequentemente, não é possível extrair ou descrever conteúdo para um sistema de busca semântica (RAG), pois não há informação visual presente na imagem fornecida.",
        "transcription": "Calma que eu tô em aula. Puta merda, a internet caiu. Deixa eu dar um pause aqui nessa gravação, senão vai ficar esquisito isso aqui.",
        "video_source": "OAC_2022-03-02.mp4"
    }
]