[
    {
        "id": 1,
        "timestamp_start": 0.0,
        "timestamp_end": 72.1,
        "slide_description": "O slide apresenta o plano de ensino da disciplina de Organização e Arquitetura de Computadores (OAC) da Universidade de Brasília, Departamento de Ciência da Computação, ministrada pelo Professor Marcus Vinicius V. A. O documento é identificado como \"OAC_A_Plano_2021-2_V0.docx\".\n\nO conteúdo principal é uma tabela que detalha a programação semanal, incluindo tópicos teóricos, laboratórios e avaliações. As datas são apresentadas em formato \"dia/mês\".\n\n**Tópicos e Atividades Teóricas e Práticas (Labs):**\n\n*   **Software e Ferramentas:**\n    *   Lab 1A: Software – Rars (referência T₈), focado em simuladores de arquiteturas de conjunto de instruções (ISA), provavelmente MIPS.\n    *   Lab 1B: Software – Compilador C, abordando a cadeia de ferramentas de software.\n    *   Lab 2: Hardware – Verilog – ULA (referência T₇), introduzindo a descrição de hardware em Verilog para Unidades Lógicas Aritméticas (ULA).\n*   **Arquiteturas de Processadores:**\n    *   **Processador Uniciclo:** Inclui o estudo da Unidade de Controle (referência C.4, L₁) e da Unidade Operativa (Datapath) (referência C.4, T₈). O Lab 3 complementa com a prática de Processador Uniciclo (referência T₉, L₂).\n    *   **Processador Multiciclo:** Abrange a Unidade Operativa (Datapath) (referência C.4) e a Unidade de Controle (referência C.4, T₁₀). O Lab 4 é dedicado ao Processador Multiciclo.\n    *   **Processador Pipeline:** Inicia com os Conceitos de Pipeline (referência C.4, T₁₁, L₃), seguido pelo estudo da Unidade Operativa e Controle em Pipeline (referência C.4). O Lab 5 é sobre Processador Pipeline (referência T₁₂).\n*   **Tópicos Avançados de Arquitetura:**\n    *   Exceção e Interrupção (referência C.4, L₄).\n    *   Memória: Hierarquia (referência C.5, T₁₃), explorando os diferentes níveis de memória.\n    *   Memória: Cache (referência C.5), com foco específico em caches.\n\n**Avaliações e Datas Importantes:**\n\n*   **Feriado:** Indicado para o período de 28/2 a 2/3.\n*   **1ª Prova (P1):** Agendada para 14/03/2022.\n*   **2ª Prova (P2):** Agendada para 27/04/2022 (referência T₁₄, L₅).\n*   **Prova Substitutiva:** Previsão de aplicação.\n*   **Apresentação dos Projetos (Pₐ):** (referência T₁₅)\n\nAs referências (Tₓ), (Lₓ) e (C.X) possivelmente indicam capítulos de livros didáticos (como Patterson e Hennessy para C.X) e números de tópicos ou laboratórios internos da disciplina, fornecendo um roteiro detalhado para os alunos. Não há diagramas visuais de datapath, pipeline ou hierarquia de memória no slide, apenas as descrições textuais dos tópicos.",
        "transcription": "Semana, uma atrás da outra, porque, infelizmente, nesse semestre a gente não tem dia disponível para fazer trocas. Porque, geralmente, no semestre presencial, a gente tem uma semana a mais e fica um dia, \"ah, não, vamos adiar essa prova para cá\", \"mudar isso aqui\", daria. Mas aqui não tem, a gente fecha o semestre fechadinho ali. E para o semestre que vem? Ah, para o semestre que vem aí talvez dê, né? Então, conta contigo que o semestre que vem é doido. Eu espero que não. Dá para estar de boa. Então, vamos lá, então, vamos lá para mais uma aulinha de OAC. Hoje é dia 30 de março. Dia 30 de março, nós estamos aqui, então, é para ver a unidade de controle do processador em multiciclo. E hoje tem o testinho 10, tá? Que já deve estar aberto, então, façam lá o testinho. Então, na aula passada, a gente viu a unidade operativa, caminhos de dados (Datapath), e agora vamos ter que ver como é que se faz o controle daquele caminho de dados (Datapath), que eu já dei uma préviazinha na última aula. Vai ser feito, então, com uma máquina de estados.",
        "video_source": "OAC_2022-03-30.mp4"
    },
    {
        "id": 2,
        "timestamp_start": 72.1,
        "timestamp_end": 78.57,
        "slide_description": "A imagem apresenta o slide inicial de uma aula de Arquitetura de Computadores, inserido em uma interface de conferência web. O slide é predominantemente textual e serve como título para a sessão.\n\nNa parte superior esquerda do slide, está o logotipo da \"Universidade de Brasília\", acompanhado do texto \"Universidade de Brasília\" e \"Departamento de Ciência da Computação\". No canto superior direito, em uma fonte menor, as informações institucionais são reiteradas: \"Universidade de Brasília\", \"Departamento de Ciência da Computação\", a identificação da disciplina \"CIC0009 - Organização e Arquitetura de Computadores\", e o nome do docente \"Prof. Marcus Vinicius Lamar\".\n\nO corpo central do slide possui um fundo com um gradiente em tons de laranja e amarelo e exibe o título principal da aula. O número da aula é \"Aula 15\", o tema principal é \"Implementação RISC-V\", e o subtítulo especifica o tópico como \"Multiciclo – Unidade de Controle\".\n\nNa parte inferior central do slide, há uma imagem de um controle de videogame, especificamente um controle DualSense branco do PlayStation 5.\n\nNo canto inferior direito da tela, sobreposto parcialmente ao slide, é visível o feed de vídeo do professor, identificado como Prof. Marcus Vinicius Lamar, que usa óculos e barba.\n\nEste slide não contém diagramas de datapath, pipeline, hierarquia de memória ou qualquer trecho de código (Assembly, C, Verilog). O foco é na apresentação formal do tema da aula e dos envolvidos.",
        "transcription": "só que a implementação dessa máquina de estados é que me interessa aqui.",
        "video_source": "OAC_2022-03-30.mp4"
    },
    {
        "id": 3,
        "timestamp_start": 78.57,
        "timestamp_end": 1170.68,
        "slide_description": "Como Engenheiro de Computação Sênior, procedo à análise e descrição do conteúdo do slide, focando nos aspectos técnicos para um sistema de busca semântica:\n\nO slide apresenta uma visão detalhada da arquitetura de um processador multi-ciclo, compreendendo um datapath, uma máquina de estados finitos (FSM) para controle e uma tabela que resume as micro-operações de cada estágio de execução de instruções.\n\n**1. Título e Afiliação da Aula:**\nNo canto superior direito, o slide é identificado como pertencente à disciplina \"UnB - CIC0099 - Organização e Arquitetura de Computadores\", associada à \"Universidade de Brasília\", \"Departamento de Ciência da Computação\", e ministrada pelo \"Prof. Marcus Vinicius Lam...\".\n\n**2. Diagrama do Datapath Multi-Ciclo:**\nO diagrama principal, localizado na porção central-esquerda do slide, ilustra um datapath simplificado, tipicamente encontrado em implementações de processadores multi-ciclo. Os principais blocos funcionais e seus fluxos de dados e controle são:\n*   **Program Counter (PC):** Registrador de 32 bits que armazena o endereço da instrução a ser buscada. Sua entrada é selecionada por um multiplexador que pode escolher entre o PC+4 (para instruções sequenciais), `PCBack` (um valor de PC salvo, talvez para recuperação de exceções ou desvios complexos), e o resultado da ULA (para endereços de salto/desvio).\n*   **Memória Dados e Instruções:** Uma unidade de memória unificada para armazenar tanto instruções quanto dados. Ela recebe um endereço (do PC ou da ULA) e pode ser lida ou escrita, com dados de saída (`Dado`) e entrada (`Dado Escrita`).\n*   **Registrador de Instrução (IR):** Armazena a instrução de 32 bits lida da memória. Campos específicos da instrução, como `Opcode`, campos de registradores (`rs1` [24:20], `rs2` [19:15], `rd` [11:7]) e campos imediatos, são extraídos e roteados para outras unidades.\n*   **Registrador de Dado da Memória (MDR):** Registrador intermediário que armazena dados lidos da memória antes de serem gravados no Banco de Registradores.\n*   **Banco de Registradores:** Contém um conjunto de registradores de propósito geral. Possui duas portas de leitura (produzindo `Dado A` e `Dado B` a partir dos registradores especificados por `rs1` e `rs2`) e uma porta de escrita (para o registrador especificado por `RegDst`, recebendo `Dado Escrita`).\n*   **Gerador Imediato:** Processa o campo imediato da instrução, realizando extensão de sinal e, em alguns casos, deslocamento (`<<1`), para gerar um operando imediato ou parte de um endereço.\n*   **Unidade Lógica Aritmética (ULA):** Executa operações aritméticas e lógicas nos operandos `A` e `B`. Possui uma saída `SaidaULA` (resultado da operação) e um sinal `zero` (indicando se o resultado é zero, crucial para desvios condicionais).\n*   **Unidade de Controle:** Componente principal de controle, que recebe o `Opcode` da instrução do IR e gera os sinais de controle (`EscrevePCCond`, `EscrevePC`, `JumpO`, `EscreveMem`, `EscreveReg`, `OrigALUA`, `OrigALUB`, `ALUOp`, `Mem2Reg`, `RegDst`, `LdMem`, `OrigPC`, `EscrevePCB`) que controlam os multiplexadores, operações de escrita em registradores e memória, e a Unidade de Controle da ULA.\n*   **Unidade de Controle da ULA (`Controle ULA`):** Recebe sinais da Unidade de Controle principal (um barramento de 7 bits rotulado `[6:0]`) e possivelmente o campo `funct` da instrução (não explicitamente rotulado mas implícito para instruções Tipo-R) para determinar a operação específica a ser executada pela ULA.\n*   **Multiplexadores (MUXes):** Vários MUXes são usados para selecionar dados ou endereços, direcionando-os para os destinos corretos, como as entradas da ULA, a entrada de escrita do Banco de Registradores, ou a entrada do PC. Por exemplo, os operandos da ULA (`A` e `B`) podem vir de registradores, do imediato ou de `PC+4`. O dado a ser escrito no registrador pode ser o resultado da ULA ou o dado lido da memória.\n\n**3. Máquina de Estados Finitos (FSM) de Controle:**\nNo lado direito do slide, um diagrama de FSM ilustra a lógica sequencial para o controle do datapath. Cada estado (círculo numerado de 0 a 9) corresponde a uma fase da execução da instrução, e as transições entre estados são guiadas pelo `Opcode` da instrução.\n*   **Estado 0 (Início/Busca):** Realiza a busca da instrução e o incremento do PC (`IR <- Mem[PC]`, `PC <- PC+4`). Sinais de controle ativos incluem `Loud=0`, `EscreveMem=0`, `OrigALUA=0`, `OrigALUB=0`, `ALUOp=0`, `EscrevePC=1`, `EscrevePCB=1`.\n*   **Estado 1 (Decodificação):** Lê registradores e pré-calcula o endereço de desvio/salto. Sinais ativos incluem `OrigALUA=0`, `OrigALUB=1`, `ALUOp=0`.\n*   **Estado 2 (Execução Endereço de Memória):** Calcula o endereço de memória para `lw` e `sw`. Sinais ativos: `OrigALUA=1`, `OrigALUB=0`, `ALUOp=0`.\n*   **Estado 3 (Leitura da Memória):** Para `lw`, lê o dado da memória para o MDR. Sinais ativos: `Loud=1`, `LeMem`.\n*   **Estado 4 (Escrita Registrador - lw):** Escreve o dado do MDR para o Banco de Registradores. Sinais ativos: `Mem2Reg=1`, `EscreveReg`.\n*   **Estado 5 (Escrita na Memória - sw):** Escreve o dado do registrador para a memória. Sinais ativos: `EscreveMem=1`.\n*   **Estado 6 (Execução Tipo-R):** Executa a operação da ULA para instruções Tipo-R. Sinais ativos: `OrigALUA=1`, `OrigALUB=0`, `ALUOp=1`.\n*   **Estado 7 (Escrita Registrador - Tipo-R):** Escreve o resultado da ULA no Banco de Registradores. Sinais ativos: `Mem2Reg=0`, `EscreveReg`.\n*   **Estado 8 (Desvio Condicional):** Verifica a condição da ULA (`zero`) e, se verdadeira, atualiza o PC com o endereço de desvio. Sinais ativos: `OrigALUA=1`, `OrigALUB=0`, `ALUOp=1`, `EscrevePCCond`.\n*   **Estado 9 (Salto Incondicional):** Atualiza o PC com o endereço de salto para `jal`. Sinais ativos: `OrigPC=1`, `Mem2Reg=1`, `EscreveReg`.\n\n**4. Tabela de Etapas de Execução:**\nA tabela na parte inferior do slide detalha as micro-operações para cada estágio da execução de diferentes tipos de instruções:\n*   **Etapa: Busca da Instrução**\n    *   Micro-operações: `IR <- Mem[PC]`, `PCBack <- PC`, `PC <- PC+4`. (Busca instrução, salva PC para desvios, incrementa PC).\n*   **Etapa: Decodificação, Leitura dos registradores**\n    *   Micro-operações: `A <- Reg[IR[19:15]]`, `B <- Reg[IR[24:20]]`, `SaidaULA <- PCBack + imm << 1`. (Lê operandos de registradores, calcula o endereço alvo de desvio/salto).\n*   **Etapa: Execução, cálculo do endereço**\n    *   **Tipo-R:** `SaidaULA <- A op B`. (ULA executa a operação).\n    *   **Acesso à Memória:** `SaidaULA <- A + imm`. (ULA calcula o endereço de memória).\n    *   **Desvios Condicionais:** `Se (A==B) PC <- SaidaULA`. (Verifica condição e atualiza PC).\n    *   **Desvios Incondicionais:** `PC <- PC + 4`. (Provavelmente para instrução sequencial ou preparação para `jal`).\n*   **Etapa: Acesso à memória, conclusão tipo-R**\n    *   **Tipo-R:** `Reg[IR[11:7]] <- SaidaULA`. (Escreve resultado da ULA no registrador de destino).\n    *   **Acesso à Memória:** `Load: MDR <- Mem[SaidaULA]`, `Store: Mem[SaidaULA] <- B`. (Lê dado para MDR ou escreve dado na memória).\n*   **Etapa: Conclusão lw**\n    *   **Load:** `Reg[IR[11:7]] <- MDR`. (Escreve dado lido da memória no registrador de destino).\n\nEm resumo, o slide oferece uma representação completa da implementação de um processador multi-ciclo, mostrando a interação entre hardware (datapath) e controle (FSM e tabela de micro-operações) para a execução de diferentes classes de instruções.",
        "transcription": "Esse aqui é o caminho de dados, né? A gente viu, aqui está o controle. Onde que tem elementos de estado? Aqui, aqui, aqui, aqui, aqui, aqui, aqui, aqui, aqui e aqui. São todos os elementos que têm algum dado armazenado. Como isso aqui vai ser uma máquina de estados, vai ter registrador dentro dela também. Ok, esse aqui é o resumo do nosso controle. A gente já viu aqui as formas de implementação. A gente já viu e o objetivo é vocês entenderem isso aqui. Que é simplesmente uma forma diferente de a gente montar um diagrama de estados. Então, nós vamos fazer essas duas implementações. O diagrama de estados, que você já viu lá em Sistemas Lógicos, e por microprogramação. Ok, então como é que seria o nosso diagrama de estados do nosso processador? Então, ele está aqui. Esse aqui é o diagrama de estados inteiro. Esse aqui, então, é uma máquina Moore, onde cada estado eu vou definir as saídas. Certo? Então, para cada estado eu tenho que definir todas as saídas. E as entradas, que seria o opcode, a entrada do nosso controle, que é o opcode, vai ser, então, utilizado para definir as transições. Se o opcode for JAL, se o opcode for BEQ, se o opcode for Tipo-R, load-store, e assim vai. Ok? Então, isso aqui é uma máquina Moore. Para a gente fazer a máquina Moore, a gente teria que definir, para cada estado, todos os sinais de saída. Certo? Absolutamente todos. E são quantos sinais de saída? São 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16. Eu espero que eu tenha contado certo. Então, para cada estado, eu tenho que definir. Como é que são esses 16 sinais de saídas aqui? Obviamente que escrever os 16 sinais de saída dentro de uma bolinha é muito complicado. Fica difícil a visualização. Então, o que nós vamos fazer aqui? Nós vamos supor que o que vai estar escrito na bolinha é efetivamente aquilo que necessita ser feito naquele estado. Os outros sinais, nós vamos considerar que eles vão estar sempre em zero. E aqueles sinais que forem diferentes de zero, eu vou colocar aqui dentro da bolinha. Então, com isso, reduz bastante o texto que eu preciso escrever nos estados, que são os sinais de saída. Então, vamos ver o que a gente tem que trabalhar dentro de cada um desses estados. E assim poder entender como que isso aqui vai fazer a etapa 1, que é a etapa de busca da instrução, a etapa 2, que é a etapa de decodificação, a etapa 3, que é a etapa de execução, a etapa 4, que é o acesso à memória e conclusão do Tipo-R, e a etapa 5, que é a conclusão do lw. Então, aqui a gente tem as cinco etapas. Só que para a gente fazer essas cinco etapas, a gente precisou de quantos estados? Quantos estados tem? Pergunta difícil essa, professor. Quantos estados tem nessa máquina de estados? Não? Quantos estados tem aí, pessoal? Contem. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. Começa em zero. 10 estados (de 0 a 9). Isso. Certo? Então, vamos entender como é que a gente tem que controlar a saída para cada estado. Então, aqui eu tenho... Vocês conseguem ler o que está escrito aqui dentro? Acho que dá, com um pouquinho de força, porque eu não consigo aumentar a tela mais do que isso aqui. Se vocês aumentarem, de repente, a janela de vocês, fique mais fácil de ler. Tá? Então, aqui a gente tem o caminho de dados. Para a gente ir identificando quais são os sinais que tem que trabalhar. Aqui, a gente tem o nosso resumo do controle. Quer dizer, o nosso diagrama de estados tem que implementar esse controle aqui. Então, vamos lá. Para o estado zero, que seria a etapa 1. Busca da instrução. O que eu preciso fazer? Eu preciso endereçar a memória com o registrador PC. Ler dessa memória e escrever no registrador IR, certo? Então, para eu fazer o endereçamento da memória no PC, eu tenho que controlar esse sinal IOD aqui. Então, IOD precisa ser zero, para que eu ponha o PC na entrada do endereço da memória. Então, está aqui, IOD igual a zero, o primeiro, lá em cima. Para se você tiver dificuldade de ver aqui, coloque na outra tela. Aqui, todo mundo tem duas telas hoje em dia. Está esse diagrama aqui amplificado. Quer dizer, com zoom. Depois, o que eu quero fazer com essa memória? Eu quero ler. Então, o que eu vou fazer? Eu vou ativar o sinal LdMem. Certo? Então, eu estou dizendo aqui, LdMem significa ativa o sinal LdMem. LdMem igual a 1. Ok? E o EscreveMem? O EscreveMem vai continuar sendo zero. Tá? Todos os sinais que não estiverem escritos aqui, são colocados em zero por padrão. Certo? Então, eu só preciso acionar o sinal LdMem. O EscreveMem está em zero. O que mais que eu preciso fazer? Eu preciso escrever o valor que eu li no registrador IR. Então, o valor que eu li desse endereço, eu preciso escrever aqui. Para eu escrever esse valor aqui, eu preciso acionar o EscreveIR. Então, está aqui. Acione o EscreveIR. Certo? Então, eu simplesmente coloco lá, EscreveIR, que significa EscreveIR igual a 1. Estou acionando o EscreveIR. O que mais que tem que se fazer? Ah, eu preciso escrever o PC no PCBack. Então, eu preciso salvar o valor desse PC nesse registrador PCBack. Então, o que eu tenho que fazer? Eu tenho que acionar o EscrevePCB. Certo? Então, esse último aqui. EscrevePCB. Certo? Então, eu estou fazendo, eu estou salvando o PC no PCBack. Isso tudo acontece na borda, quer dizer, a escrita do EscrevePCB acontece na borda de subida. A escrita no IR também acontece lá na borda de subida. Ok. O que mais que eu preciso fazer? Calcular PC mais 4. Certo? Então, para calcular PC mais 4, eu vou precisar definir a OrigALUA, a OrigALUB e o ALUOp. Então, vamos lá. A OrigALUA, 0, 1 ou 2, para fazer PC mais 4. Então, a OrigALUA, 0, 1 ou 2. Boa tarde, professor. Boa tarde. 2. Certo? Porque é o valor que tiver no PC é que eu tenho que colocar aqui na entrada da ULA, porque é PC mais 4. E OrigALUB, 1. Vou colocar o número 4 aqui. O número 4 significa, o número 4 tem 32 bits, em binário, 32 bits. Ok? Não é o número 4 em decimal, como está aqui. E a operação, que a ULA tem que fazer, ela tem que fazer uma soma. Certo? Então, ALUOp, 00. Por que o meu scroll não está funcionando? Ok. ALUOp, 00. Então, está aqui. OrigALUA, 10. OrigALUB, 01. ALUOp, 00. O que mais que eu preciso fazer? Eu preciso que esse endereço seja escrito no PC. Certo? Então, a ULA calculou esse endereço de PC mais 4. Certo? Está aqui. E eu preciso que, na borda de subida do clock, esse endereço seja escrito no PC. Logo, o OrigPC, que é esse multiplexador aqui, tem que ser 01. Esse é o valor que está aqui, que eu quero colocar disponível na entrada do PC, para quando vir a borda de clock, ele ser armazenado no PC. Então, OrigPC, 01. Ah, eu estou mostrando no... Me avisem que eu estou mostrando na tela errada. Então, vamos de novo. É o valor que está aqui, que eu quero salvar, deixar aqui disponível para o PC. Então, eu tenho que setar esse OrigPC, 01. 01. Acho que é o quê mesmo? Você está apontando a seta do mouse, eu não vejo nada. Agora, a seta do mouse. Eu quero saber, eu tenho aqui o valor de PC mais 4, que eu mandei a ULA calcular. Eu quero que esse valor fique disponível aqui, para quando vir a borda de subida do clock, esse valor seja gravado no PC, que é o que isso aqui está mandando fazer. Calcule PC mais 4 e grave no PC. Então, esse multiplexador, OrigPC, 01. 0, né? Esse valor que eu tenho que botar para lá, não é esse aqui. Então, está aqui, OrigPC igual a 0. E eu quero que esse valor seja escrito no PC, na borda de subida de clock. Eu quero que esse valor que está aqui seja escrito no PC na borda de subida de clock. Quero. Então, eu vou ter que acionar o EscrevePC. Eu preciso que o EscrevePC seja 1, para habilitar que quando vier a borda de subida de clock, esse dado seja escrito no PC. Então, aciono também o EscrevePC. Ok? Então, nessa primeira etapa, eu preciso acionar tudo isso aqui. E os outros sinais que não estão aqui? Por exemplo, o Mem2Reg. Quanto que é o Mem2Reg? Quanto que é o Mem2Reg? Nesse estado, quanto é que é o Mem2Reg? Pessoal, eu não disse que tudo que não estivesse escrito aqui seria em 0? Logo, o Mem2Reg está escrito aqui? Não. Então, quanto é que ele vale? 0. O EscreveReg. O EscreveReg. Quanto é que vale aqui o EscreveReg? Que é esse outro sinal aqui. O João está respondendo tudo certo ali. 0 também. 0 também. Ok? Acho que era só esses sinais que estão em 0. O resto dos sinais estão todos aqui. Entendido, pessoal? Ok. Então, concluímos a primeira etapa. Essa primeira etapa aqui. Então, quando vier a borda de subida de clock, minha máquina de estados vai transicionar para o estado um, que é esse aqui. Nesse estado um, eu vou fazer a segunda etapa. Essa aqui. Vamos lá. O que eu preciso controlar no meu caminho de dados para que os campos de registradores da instrução (rs1 e rs2) sejam mandados para o Banco de Registradores para que eu leia os valores de A e B. O que eu preciso controlar para fazer isso? Bits 15 a 19 está aqui. E o que eu preciso controlar para que o valor desse registrador aqui seja lido e colocado aqui nesse ponto? Tem alguma coisa que eu preciso controlar? Algum sinal que eu preciso setar para que isso aconteça? EscreveReg? Eu não quero escrever o registrador. Eu quero ler do Banco de Registradores, escrever no registrador A, que é esse aqui. EscreveReg e escrever esse dado nesse registrador. Então, eu não quero escrever no Banco de Registradores ainda. Certo? Então, para eu fazer essa tarefinha aqui de ler desse registrador rs1 e disponibilizar o dado aqui na saída, eu não preciso controlar nada. Uma vez que o sinal aqui ficou estável, depois de um tempinho de propagação, eu tenho meu sinal estável de novo, meu sinal estável aqui na saída. Certo? A mesma coisa para rs2. Então, para eu ler o registrador rs2 e disponibilizar o dado lido aqui, eu não preciso fazer nada. O que eu preciso fazer para que esses dados lidos sejam escritos no A e no B? O que é necessário agora para que o dado que eu li aqui seja escrito no registrador A e esse aqui no registrador B? Esses registradores têm algum sinal de habilitação de escrita? Eu acho que eu estou falando grego, porque vocês não estão acompanhando. Isso é grave. A gente já fez isso em uma aula passada, pessoal. De novo. Eu li do Banco de Registradores. Li do Banco de Registradores. Então, o dado lido do Banco de Registradores está aqui e está aqui. O que eu preciso fazer para que ele seja escrito no A e escrito no B? Logo, o que eu preciso controlar para que esse dado que está aqui seja escrito no A? Para que esse dado que está aqui seja escrito no B? Pessoal, façam perguntas. Senão, eu não sei o que vocês não estão entendendo. Não precisa de nada para poder escrever naquele A e no B. Exatamente. O que precisa é só esperar a borda de subida de clock. Então, quando vier a borda de subida de clock, esse dado é escrito aqui e esse dado é escrito aqui. Certo? Então, não precisa controlar nada. O dado está disponível. É só esperar até o final da etapa. E a borda de subida de clock vai escrever os dois. Ok. Enquanto a gente está lendo o Banco de Registradores, escrevendo aqui no A, no final do ciclo, a ULA não está fazendo nada. E a gente viu na aula passada que seria interessante, para acelerar um pouco o processo, que eu nem sei qual é a instrução ainda, que a gente calculasse aqui o endereço do BEQ e do JAL. Então, o endereço do BEQ e do JAL é calculado dessa maneira aqui. Então, eu vou fazer com que a ULA calcule a soma do PCBack, mais o imediato e deslocado de 1. Então, o que eu preciso controlar para fazer isso? OrigALUA, 0, 1 ou 2? Para que faça isso aqui. PCBack mais o imediato e deslocado de 1. OrigALUA, 0, 1 ou 2? Por que a coisa não está indo? Será que eu vou escrever alguma coisa agora? Vamos de novo. Eu quero que a ULA calcule PCBack mais o imediato e deslocado de 1. Logo, o que tem que ter aqui? Meu Deus, por que o meu chat não está indo? Deixa eu tentar escrever alguma coisa aqui para ver se... 0. Isso, é o 0. Para mim, o chat não está fazendo rolagem automática, daí fica difícil. Meu Deus do céu. Depois eu tento arrumar uma coisinha aqui, que a minha carta de tarefa se desconfigurou.",
        "video_source": "OAC_2022-03-30.mp4"
    },
    {
        "id": 4,
        "timestamp_start": 1170.68,
        "timestamp_end": 1173.22,
        "slide_description": "Como um Engenheiro de Computação Sênior, analiso o slide apresentado, que se trata de uma tela de um ambiente de aula online, provavelmente utilizando uma plataforma de videoconferência integrada a um sistema de gerenciamento de aprendizagem (LMS) como o Moodle.\n\n**1. Transcrição de Texto e Conteúdo:**\n\nA tela principal exibe o ambiente virtual da disciplina, hospedado na plataforma \"UnB APRENDER\". O título da disciplina visível é \"CIC0099 - Organizaçã...\", que, pelo contexto de uma aula de Arquitetura de Computadores e o caminho de navegação, pode ser inferido como \"Organização e Arquitetura de Computadores\". O caminho de navegação (breadcrumbs) indica \"Painel > Meus cursos > OAC-A-2021-2\", reforçando a inferência sobre o nome da disciplina (\"OAC\" para Organização e Arquitetura de Computadores, e \"A-2021-2\" indicando o semestre/período letivo).\n\nNo cabeçalho da página do curso, além do código e título, há um campo de busca (\"Search courses\") e botões de controle do LMS como \"Ativar edição\", \"Mostrar blocos\" e \"Tela cheia\". Em uma área mais detalhada no canto superior direito, visível em um dos crops, aparece texto parcial: \"Universidade de Brasília\", \"Departamento de Ciência da Computação\", e \"Engenharia de Arquitetura de Computadores\", indicando a instituição e o departamento que oferece o curso.\n\nO conteúdo programático ou seções do curso visíveis na página incluem:\n*   **Geral**\n*   **Fóruns:**\n    *   Avisos\n    *   Fórum de dúvidas\n*   **Plano de Ensino**\n*   **Definição dos Grupos**\n*   **Trabalho de Extensão**\n\nNa parte inferior da tela, ligeiramente obscurecida e com resolução limitada, há uma linha de texto técnico que parece ser uma expressão de Linguagem de Transferência de Registradores (RTL) ou uma operação de micro-instrução em um datapath. A transcrição mais legível é:\n`Load.Reg[R11] <- IJK <- MUX`\nEsta instrução descreve a operação de carregar um valor em um registrador. Especificamente, o conteúdo proveniente de uma fonte identificada como `IJK` é selecionado por um Multiplexer (MUX) e, em seguida, esse dado é escrito no Registrador `R11`. A interpretação de `IJK` é ambígua devido à baixa resolução, podendo representar um barramento, um endereço de memória calculado a partir de múltiplos valores (I, J, K), ou uma expressão complexa. No entanto, a estrutura `Load.Reg[Dest] <- Source <- MUX` é clássica para descrever a seleção e o carregamento de dados em um registrador dentro de uma UCP.\n\nA interface da conferência (à esquerda) mostra um bate-papo público. As mensagens dos alunos são predominantemente conversacionais, mas uma delas é tecnicamente relevante para a disciplina:\n*   Harisson Freitas Maga... \"EscreveReg?\" (Possivelmente \"Escreve Registrador?\", questionando se uma operação discutida grava em um registrador).\n\n**2. Descrição de Diagramas e Estruturas:**\n\nNão há diagramas explícitos de Datapath, Pipeline ou Hierarquia de Memória visíveis no slide. O conteúdo principal é uma página web de um ambiente de curso online, listando tópicos e recursos da disciplina. No entanto, a presença da instrução `Load.Reg[R11] <- IJK <- MUX` implica diretamente em conceitos de Arquitetura de Computadores como:\n*   **Datapath:** A instrução descreve uma operação fundamental de transferência de dados que ocorreria em um datapath de uma Unidade Central de Processamento (UCP), envolvendo registradores, multiplexadores e fontes de dados.\n*   **Micro-arquitetura:** A granularidade da instrução (`Load.Reg`, MUX) sugere que se está discutindo detalhes em nível de micro-operações, que são a base para a implementação da arquitetura do conjunto de instruções (ISA).\n*   **Controle:** A seleção de `IJK` via MUX implica a existência de sinais de controle que determinam qual fonte de dados será selecionada e quando a operação de carga no registrador R11 será executada.\n\nA pergunta \"EscreveReg?\" do chat também aponta para a discussão de operações que modificam o estado dos registradores, um elemento central na arquitetura de um processador.\n\n**Conclusão para RAG:**\n\nEste slide, embora principalmente uma interface de LMS, contém informações cruciais sobre um curso de Arquitetura de Computadores (CIC0099 / OAC-A-2021-2) da Universidade de Brasília. Os termos técnicos extraídos incluem \"UnB APRENDER\", \"CIC0099\", \"OAC-A-2021-2\", \"Organização e Arquitetura de Computadores\", \"Plano de Ensino\", \"Trabalho de Extensão\". A instrução `Load.Reg[R11] <- IJK <- MUX` é um fragmento de Linguagem de Transferência de Registradores (RTL) que denota uma operação de carregamento de dado em um registrador (R11) através de um multiplexador, essencial para descrever o funcionamento de um datapath em micro-arquitetura. A pergunta \"EscreveReg?\" no chat contextualiza a interação dos alunos com conceitos de manipulação de registradores. Estes elementos permitem indexar este conteúdo sob tópicos como \"Arquitetura de Computadores\", \"Organização de Computadores\", \"Datapath\", \"RTL\", \"Registradores\", \"Multiplexadores\", \"Micro-operações\", \"UnB\", \"Moodle (ou similar LMS)\".",
        "transcription": "Ativado.",
        "video_source": "OAC_2022-03-30.mp4"
    },
    {
        "id": 5,
        "timestamp_start": 1173.22,
        "timestamp_end": 6238.48,
        "slide_description": "Como um Engenheiro de Computação Sênior, analiso o slide apresentado, que faz parte de uma aula de Arquitetura de Computadores na UnB (curso CIC0099, \"Organização e Arquitetura de Computadores\"), ministrada pelo Prof. Marcus Vinicius Lameira. O conteúdo foca no projeto lógico de uma unidade de controle, especificamente na derivação de equações booleanas em formato de Soma de Produtos (SOP) para sinais de controle.\n\nO título principal do slide é: \"Exemplo do projeto lógico para cada saída na forma soma de produtos\". Isso indica que o objetivo é ilustrar como as funções de controle, que determinam o comportamento de um processador em diferentes estados, são implementadas utilizando lógica combinacional, expressa em sua forma canônica SOP.\n\nO slide apresenta dois exemplos de sinais de controle: \"EscrevePC\" e \"NS$_0$\".\n\n1.  **Sinal de Controle \"EscrevePC\"**:\n    *   **Título:** \"EscrevePC: Acionado nos estados 0 ou 9\"\n    *   **Diagrama/Tabela:** Uma tabela de estados (parcial) é fornecida, mostrando as codificações de 4 bits (S3, S2, S1, S0) para os estados em que o sinal \"EscrevePC\" deve ser ativo ('1').\n        *   `S3 S2 S1 S0`\n        *   `0  0  0  0` (Estado 0)\n        *   `1  0  0  1` (Estado 9)\n    *   **Expressão Booleana:** `EscrevePC = $\\overline{S3} \\cdot \\overline{S2} \\cdot \\overline{S1} \\cdot \\overline{S0} + S3 \\cdot \\overline{S2} \\cdot \\overline{S1} \\cdot S0`\n    *   **Descrição:** Este segmento demonstra a lógica para um sinal de controle fundamental, \"EscrevePC\", que provavelmente habilita a escrita no registrador Program Counter (PC). Ele é ativado quando a máquina de estados finita (MEF) da unidade de controle está no estado 0 (representado por S3S2S1S0 = 0000) ou no estado 9 (representado por S3S2S1S0 = 1001). A equação booleana em SOP é uma transcrição direta dos mintermos correspondentes a esses estados, utilizando os bits de estado S3, S2, S1 e S0 como entradas. A notação com barra superior indica negação lógica.\n\n2.  **Sinal de Controle \"NS$_0$\" (Next State Bit 0)**:\n    *   **Título:** \"NS$_0$: Acionado nos estados 0, 2, 6 ou 1 (caso opcode=jal)\"\n    *   **Diagrama/Tabela:** Uma tabela de verdade (parcial) é fornecida, ilustrando as condições (combinações de bits de opcode e bits de estado atual) sob as quais o bit menos significativo do próximo estado, NS$_0$, deve ser ativo. As entradas são 7 bits de opcode (Op6 a Op0) e 4 bits de estado atual (S3 a S0).\n        *   `Op6 Op5 Op4 Op3 Op2 Op1 Op0 | S3 S2 S1 S0`\n        *   `x   x   x   x   x   x   x   | 0  0  0  0` (Estado 0, opcode \"don't care\")\n        *   `x   x   x   x   x   x   x   | 0  0  1  0` (Estado 2, opcode \"don't care\")\n        *   `x   x   x   x   x   x   x   | 0  1  1  0` (Estado 6, opcode \"don't care\")\n        *   `1   1   0   1   1   1   1   | 0  0  0  1` (Estado 1, *e* opcode específico \"jal\")\n    *   **Expressão Booleana:** `NS$_0$ = $\\overline{S3} \\cdot \\overline{S2} \\cdot \\overline{S1} \\cdot \\overline{S0} + \\overline{S3} \\cdot \\overline{S2} \\cdot S1 \\cdot \\overline{S0} + \\overline{S3} \\cdot S2 \\cdot S1 \\cdot \\overline{S0} + Op6 \\cdot Op5 \\cdot \\overline{Op4} \\cdot Op3 \\cdot Op2 \\cdot Op1 \\cdot Op0 \\cdot \\overline{S3} \\cdot \\overline{S2} \\cdot \\overline{S1} \\cdot S0`\n    *   **Descrição:** Este segmento detalha a lógica para o bit NS$_0$, que é o bit menos significativo para determinar o próximo estado da MEF. Ele é ativado em três estados independentemente do opcode (estado 0, 2 e 6). Adicionalmente, ele é ativado no estado 1 *apenas se* o campo de opcode da instrução atual corresponder ao opcode da instrução \"jal\" (Jump and Link), que é codificado como 1101111. A tabela de verdade utiliza 'x' para indicar condições \"don't care\" (não importa o valor) para os bits de opcode quando o estado atual já é suficiente para ativar NS$_0$. A equação booleana em SOP reflete esses mintermos, combinando as condições de estado puro com a condição mista de estado 1 E opcode 'jal'. Isso ilustra a complexidade da lógica de próximo estado, que frequentemente depende tanto do estado atual quanto de entradas externas (como os bits de instrução).\n\nEm resumo, o slide é um exemplo prático de como projetar a lógica combinacional de uma unidade de controle para um processador, usando a forma Soma de Produtos para derivar as equações que controlam os registradores (EscrevePC) e a transição de estados (NS$_0$), com dependência tanto do estado interno quanto de entradas externas como o opcode da instrução.",
        "transcription": "Ativado. Hum... Cadê isso? Mas vamos lá. Um minuto. Estou vendo tudo certinho. Ok. Então, vamos lá. Então, isso aqui eu preciso: Origem A da ULA, 0. São dois bits. Então, 0, 0. Origem B da ULA. Quer que seja imediato e deslocado de 1. Então, está aqui. É o imediato e deslocado de 1. Então, 1, 1 (3). Certo? E qual é a operação que a ULA tem que fazer? A ULA tem que fazer uma soma. Então, `op_ALU` (0, 0). Então, está aqui o que... Opa! Lá estou eu apontando naquele diagrama de número errado. Então, está aqui o que a gente precisa fazer no estado 1. Certo? Já que eu não preciso fazer nada para controlar a escrita do A e do B, eu só preciso, então, Origem A da ULA: 0, 0. Origem B da ULA: 1, 1. E `op_ALU`: 0, 0. Certo? Isso aqui, então, são os únicos sinais que eu preciso controlar para fazer, então, a segunda etapa. Beleza? Todos os outros sinais estão em 0. Entendido, pessoal? Ok? Ok. Então, primeira etapa, segunda etapa, terceira etapa. Então, na terceira etapa, agora, depende qual é o tipo de instrução. Para uma instrução tipo R, o que eu preciso fazer? Eu preciso pegar o A, operar com o B e o resultado salvar no registrador saída da ULA. Então, eu estou aqui no final da segunda etapa. O que eu vou ter que fazer? Eu vou ter que verificar agora qual é o `opcode` que está entrando aqui. Certo? E, de acordo com o `opcode`, eu vou para algum desses estados, desses quatro estados. Então, como a gente está fazendo tipo R, então, o `opcode` que está entrando aqui, a entrada é o `opcode` do tipo R, eu vou vir para cá. Certo? Então, essa aqui é a terceira etapa do tipo R. Beleza. O que eu preciso controlar para fazer isso aqui? Então, para colocar o A aqui na entrada da ULA. Origem A da ULA. 0, 1 ou 2? Para colocar o A aqui. Meu Deus, meu. A coisa não está rolando automático. 1. Para colocar o B aqui. Origem B da ULA. Lembre-se que sempre são dois bits aqui, tá? Dois bits aqui e dois bits aqui. Então, o primeiro é 00 e o segundo... Opa, o primeiro é 01. E o segundo aqui, Origem B da ULA. Ele quer colocar o valor de B aqui. Então, 00. E qual é a operação que a ULA vai fazer? Aí, essa operação aqui, aí depende do campo `funct`. Então, lembrando que o `op_ALU` 00 é uma soma, 01 é uma subtração e 10 é o campo `funct` que decide. Então, eu preciso que o `op_ALU` seja 10. O campo `funct` é que vai me definir o que a ULA vai fazer com esse A e com esse B. Tá? Então, está aqui. Origem A da ULA, 01. Origem B da ULA, 00. E o `op_ALU`, 10. Certo? Então, isso aqui é a única coisa que eu preciso setar na terceira etapa do load. Tá? Então, está aqui. Por que não está indo automático essa rolagem? Vamos lá. Terminei a terceira etapa do load. Vamos fazer a quarta etapa do load. Então, a quarta etapa do load. Ah, outra coisa. Esquece. Eu calculei aqui o registrador saída da ULA. O que eu preciso fazer para que esse valor aqui seja armazenado no registrador saída da ULA? O que eu preciso fazer para que o valor que a ULA calculou seja armazenado aqui? Que é isso que a gente quer, né? Que o resultado da operação seja armazenado no registrador saída da ULA. Preciso fazer alguma coisa? Nada. Essa falta de rolagem aqui é complicada. Exato. Não precisa fazer nada. Porque esse registrador saída da ULA sempre é atualizado na borda de subida de clock. Então, para eu armazenar esse dado no registrador saída da ULA, é só esperar vir a borda de subida de clock. Quer dizer, o final da terceira etapa. Então, no final da terceira etapa, o registrador de saída da ULA recebe esse valor aqui. Ok. E na quarta etapa? Eu preciso, então, que o valor que está armazenado no registrador saída da ULA seja armazenado no banco de registradores. Certo? Então, o que eu preciso fazer para controlar nessa quarta etapa? Seria o estado 7 aqui. Para que esse valor seja disponibilizado aqui na entrada de escrita do banco de registradores. Então, `MemToReg` igual a quanto? Sério, é muito chato. É muito chato eu não conseguir fazer as rolagens automáticas. Atualizar a página. Eu acho que se eu atualizar a página, eu vou cair. Funciona? Dá um F5, não cai, não? Faz assim rapidão. Não rola para baixo. Alt F4. Alt F4. Eu vou colocar mais mensagem aqui de spam. Não dá. Fica lá mais mensagens abaixo. E a minha rolagem não... Clica nesse e não faz mais nada. Clica no quê? Clica nesse e não faz mais nada. No mais mensagens abaixo. Vamos ver se funciona agora. Manda mais mensagens de spam aí. Para mim funcionava antes. Ah, agora funcionou. Beleza. É isso aí. Ah, muito bem agora. Isso aí. Agora está rolando automático aqui. Então, vamos lá. Onde é que eu estava? Eu estava aqui no quarto ciclo, né? Na quarta etapa. Então, para eu disponibilizar esse valor aqui de registradores saídos da ULA para ser escrito no banco de registradores. Então, esse valor tem que estar disponível aqui. Logo, `MemToReg`. Tem esse multiplexador. 0, 1 ou 2. 0. O que tiver aqui é que vai ser disponibilizado aqui. Quando vier a borda de subida de clock. Opa. Ele não vai fazer nada. Porque a gente tem que também acionar o `RegWrite`. Eu quero que esse valor seja escrito no banco de registradores. Então, eu preciso acionar o `RegWrite`. Aí sim. Quando... Quando vier a borda de subida de clock. O `RegWrite` está acionado. Esse dado está ok. Então, ele vai ser escrito. Esse dado vai ser escrito no registrador RD. Certo? E acabou. Ó. Então, está aqui. `MemToReg`: 0, 0. E acionar o `RegWrite`. E acabou o tipo R. Então, o que vai acontecer? Vai voltar aqui para o primeiro estado. Primeiro estágio. Primeira etapa. Né? Que é o estado 0. Então, acabou o tipo R. Então, acabou o tipo R. Ele volta lá para o estado 0. Para pegar a próxima instrução. Ok. Vamos ver o BEQ. Né? Vamos pegar esse aqui. Desvio condicional. Então, para o desvio condicional. Então, ele fez o primeiro. Certinho. Fez a segunda etapa. Certinho. E aqui descobriu que o `opcode` é o BEQ. Então, o que ele tem que fazer? Tem que controlar o caminho de dados para fazer essa tarefa aqui. Então, verificar se A é igual a B. Então, para verificar se A é igual a B. Eu tenho que botar o A aqui. Botar o B aqui. E mandar fazer uma subtração. Né? Então, Origem A da ULA: 1. Origem B da ULA: 0. E eu preciso que o `op_ALU` seja 0, 1. Para que faça uma subtração. Certo? Então, está aqui. Origem A da ULA: 0, 1. Origem B da ULA: 0, 0. O `op_ALU`: 0, 1. Beleza? E agora. Eu vou ter esse resultado de 0 aqui. Então, se o resultado for verdadeiro. Quer dizer, se a subtração for 0. Eu quero que esse valor seja escrito no PC. Que valor? O que tiver na saída da ULA. Certo? Eu quero que a saída da ULA seja escrita no PC. Certo? Se por acaso for 1. Então, eu tenho que disponibilizar a saída da ULA aqui. Então, para eu disponibilizar o conteúdo desse registrador. Aqui na entrada do PC. `PCSrc`: 0, 1. Muito bem, João. 1. E eu quero escrever condicionalmente no PC. Então, lembre-se que originalmente. Agora ele está armazenando o PC mais 4. E eu disponibilizei aqui na entrada. O endereço do BEQ. Certo? Então, eu preciso saber. Se eu devo ou não escrever. Esse endereço. Se o BEQ for verdadeiro. Ou se o BEQ for falso. Então, eu vou. Acionar o `PCWriteCond`. Certo? Certo? Certo? Certo? Certo? Então, `PCWriteCond`. Aqui. Esse. Esse sinal de saída. Então, `PCWriteCond`. Se estiver acionado. E. O BEQ for verdadeiro. Aí ele vai acionar a escrita. No PC. Então, o PC vai ser escrito com esse endereço que tiver aqui. Que é o endereço de desvio do BEQ. Caso. O BEQ seja falso. Então, o resultado aqui vai dar 0. Né? Então, a saída aqui vai dar 0. Uma vez que todos os outros sinais estão em 0. Certo? Incluindo o `PCWrite`. Certo? Então. Se for. Se vier 0 aqui. Na borda de subida do clock. Ele não vai escrever o que está. E vai continuar com o que estava escrito. Que era PC mais 4. Certo? O BEQ falso. Então, tá aqui o que eu preciso fazer. `PCSrc`: 1. E. Acionar o `PCWriteCond`. Acionar esse aqui. Ok? Com isso. Né? Ao final do ciclo. O PC. Vai. Ou não vai. Certo? Certo? Certo? Certo? Certo? Vai. Ou não. Ser escrito no endereço do BEQ. Certo? Dependendo se o BEQ é verdadeiro ou falso. E volto a buscar agora a nova instrução no novo endereço. Seja ele PC mais 4 ou o endereço do BEQ. Ok? Então. O BEQ necessita só 3 ciclos de clock. É. Um ciclo de clock daqui para cá. Outro daqui para cá. Outro daqui para cá. Ok. Vamos fazer o JAL. Então. Para o JAL. Aqui temos o desvio condicional. Então. O `opcode` aqui agora é um JAL. Certo? Nesse caso aqui. Então. O que que eu preciso fazer? Preciso pegar o valor de PC mais 4. E escrever no banco de registradores. Certo? Então. O que que eu preciso controlar. Para fazer isso? Pegar PC mais 4. E escrever no banco de registradores. Então. `MemToReg` igual a quanto? Onde é que eu tenho PC mais 4? Já que eu quero escrever ele no banco de registradores. No banco de registradores. Então eu preciso ter aqui PC mais 4. Então `MemToReg`: 0, 1 ou 2? 1 porque o PC tem escrito PC mais 4 nele. Então 1. E eu quero escrever no banco de registradores? Quero. Então eu preciso acionar o `RegWrite`. Então está aqui. `MemToReg` igual a 1. E aciona o `RegWrite`. Ao vir a borda de subida de clock. O PC mais 4. Vai ser escrito nesse registrador de destino. No final do terceiro ciclo. O que mais? Que eu preciso fazer. Eu preciso que o endereço. Que está aqui no saída da ULA. Seja escrito forçosamente. No PC. Porque é um desvio incondicional. Ele tem que ir para esse endereço. Então o que eu preciso controlar? `PCSrc`: 0 ou 1? O que eu tenho que disponibilizar aqui na entrada? 0 ou 1. Muito bem. 1. O conteúdo desse registrador. É o que eu tenho que disponibilizar aqui na entrada. E agora. Eu quero escrever no PC? Sim, eu quero. Então aciono o `PCWrite`. Forço a escrita no PC. Quando vir a borda de subida de clock. Esse endereço é escrito no PC. Certo? Então `PCSrc`: 1. E aciona o `PCWrite`. 0 ou 1. Depois ele tem que voltar. Para o estado 0. Para buscar a nova instrução. Desse novo endereço. Ok? Para as instruções load store. Para a instrução load store. A terceira etapa é igual. Tanto para load quanto para store. O que eu tenho que fazer. É fazer a ULA. Calcular o endereço. Que eu vou acessar a memória. Que é dado por A mais o imediato. Ok? Então eu vou acessar. Então o que eu vou ter que fazer. Aqui para a ULA calcular A mais o imediato? Vamos lá. Origem A da ULA: 0, 1, 2. Ou Origem B da ULA. Aqui que foi o que eu perguntei. Origem B da ULA. Eu preciso que ele grave. Que ele calcule A mais o imediato. Não A mais o imediato. E deslocado de 1. Então é 2. Tá? A geração do. Do imediato. Do load do store. Ok? Então que pega aqueles bits. De 12 bits. E expande para 32. Então é esse aqui 2. Então tá aqui. Origem A da ULA: 1. Origem B da ULA. Tá aqui. Origem A da ULA: 0, 1. Origem B da ULA: 1, 0 (2). E qual a operação que a ULA tem que fazer? Tem que fazer uma soma, né? Essa soma. Então 0, 0. Então isso serve. Tanto para o `opcode` do load. Quanto para o `opcode` do store. Se o `opcode` for do load ele vai vir para cá. Se o `opcode` for do store ele também vai vir para cá. Ok? A quinta etapa. Não, quarta etapa. A quarta etapa é diferente para o load e para o store. Então vamos fazer o store primeiro. Então para o store eu preciso. Meu registrador B. E gravar ele. Quer dizer eu preciso gravar o conteúdo do registrador B. Nesse intervalo. No endereço da memória. No endereço dado. Pelo registrador saída da ULA. Que é esse aqui. Na etapa anterior. Então para fazer isso. Então primeiro. Da onde que tem que vir o endereço? Então `IorD` (Instruction or Data). `IorD` é 0 ou 1. O endereço tem que vir do PC. Ou do registrador saída da ULA. Então `IorD` é 0 ou 1. 2. Eu quero endereçar a memória em qual endereço? Isso. Então eu quero que o conteúdo desse registrador. É que seja disponibilizado aqui no endereço. Certo? O que eu vou querer fazer com essa memória? Eu vou querer ler ou escrever? É um store. Eu quero escrever nessa memória. Certo? Então eu aciono e escrevo em MEM. Aciono e escrevo em MEM. O `MemWrite` está em 0. `MemWrite` mexe em `MemWrite`. Então eu aciono e escrevo em MEM. E o que eu vou escrever? Já vem direto aqui. Sempre vai ser o registrador B. Que eu vou escrever na memória. Certo? Então a ligação do B é direta aqui. Para o dado que vai ser escrito na memória. Então. No store eu preciso fazer `IorD` igual a 1. Controlar esse multiplexador. E acionar o `MemWrite`. Para que na subida do clock. Esse dado seja escrito nesse endereço. Ok? Acabou o store. Então o store vai ser escrito nesse endereço. Então o store vai ser escrito nesse endereço. Então o store vai ser escrito nesse endereço. Então o store acabou aqui. Ele volta para o primeiro ciclo. Lá para a primeira etapa. O load. Então note aqui. Eu saí daqui. Se for o store. Ele tem que vir para cá. Fiz esse aqui. Que era da etapa comum. Daí na quarta etapa. Se for o store. Ele vem para cá. E faz isso. Se for um load. Ele vai ter que vir para cá. Então se for um load. O que tem que ser feito na quarta etapa? Eu tenho que ler. Da memória do registrador saída da ULA. E eu tenho que ler. E escrever no registrador MDR (Memory Data Register). Então vamos lá. Então eu preciso endereçar a memória. Com o registrador saída da ULA. Então `IorD` 0, 1. Isso, 1. Faz conta que vocês digitaram ali 1. Então eu vou pegar o conteúdo desse registrador. E colocar aqui como endereço. O que eu quero fazer com a memória? Eu quero ler. Logo, aciono o `MemRead`. Certo? Acionei o `MemRead`. E vou ler. Então passado um tempinho de propagação. Tempinho de propagação não. Tempinho de leitura da memória. Que depois lá no final do curso. Nós vamos ver que esse tempinho de leitura da memória. É grande para a CPU. Eu tenho aqui o dado lido. A partir do endereço. Que estava aqui no saída da ULA. O que eu preciso controlar. Para que esse dado seja escrito no MDR? Preciso controlar alguma coisa? Para que o dado que está aqui. Seja escrito no MDR? Então é só esperar. A borda de subida do clock vir. Que o dado que eu li da memória. Vai ser escrito nesse registrador MDR. Certo? Que é esse aqui. Beleza, finalizamos a quarta etapa. Então, `IorD` igual a 1. E aciono o `MemRead`. E agora eu preciso continuar o load. Então, na quinta etapa. Eu vou ler do registrador MDR. E gravar no banco de registradores. Então, o que eu preciso fazer. Para controlar. Para fazer isso? Então, `MemToReg`. O dado que eu quero aqui. É o que está no MDR. Eu quero esse dado que vai ser escrito no banco de registradores. Então, `MemToReg`: 0, 1 ou 2? `MemToReg`, 0, 1 ou 2. 2, certo? E eu quero escrever no banco de registradores? Eu quero escrever no banco de registradores? Sim. Então, aciono o `RegWrite`. Então, está aqui. `MemToReg` igual a 1 e 0. E aciono o `RegWrite`. Ao vir a borda de subida de clock. Esse dado é escrito no banco de registradores. E volta para buscar a próxima instrução. Certo? Então, com isso a gente definiu. Todos os sinais que deveriam ser controlados. Em cada um dos estados. Beleza? Entendido isso aqui? Então, essa aqui é a nossa máquina de estados. Que vai aqui no controle. Ótimo. Dúvidas, pessoal? Agora nós vamos implementar essa máquina de estados. Ah, você já sabe implementar a máquina de estados, né? Por que eu vou repetir aqui? Pode pular. De novo? Pronto. Vamos pular, vamos pular, vamos pular. Vamos pular. Ok. Então, vamos ver a implementação de máquina de estados. Porque a gente vai fazer duas implementações. Essa implementação é a implementação clássica que vocês viram. E depois nós vamos fazer uma implementação de microprogramação. Ok, então como é que se implementa uma máquina de estados? Certo? Então, a gente tem aqui um registrador. Que vai conter qual é o estado atual. Na minha máquina de estados eu tenho entradas. E tenho saídas. Então, as entradas. Vão influenciar. Aqui é uma função combinacional. Que é a função de próximo estado. Que dado o estado atual. E dado as entradas. Eu calculo qual é o próximo estado. Ao vir a borda de subida de clock. Esse estado é gravado aqui. Ok? Então, aqui eu tenho uma função de próximo estado. Uma lógica combinacional. E. Se tiver do jeito que está escrito aqui. As entradas. E o estado atual. Colocados em uma lógica combinacional. Que seria a função de saída. Vai me dar quais são as saídas. Então, isso aqui é uma máquina de Moore. Ou uma máquina de Mealy. Mealy ou Moore? Esse que está aqui. Desenhado aí. Mealy ou Moore, pessoal? Vocês queriam pular? Não. O que caracteriza uma máquina de Mealy. E uma máquina de Moore? A máquina de Moore. A saída só depende do estado. Na máquina de Mealy, a saída depende do estado. E da entrada. Aqui, a saída não está dependendo do estado. E da entrada? Tá? Então, é uma máquina de Mealy. Certo? Se eu quero construir uma máquina de Moore. Basta tirar essa conexão aqui. Aí as entradas não interferem diretamente nas saídas. Somente o estado atual. Certo? Entendido isso? Beleza. O Aprender caiu? Ainda bem que a gente está fora do Aprender. Mas vocês têm que acessar o Aprender. Para responder o testinho, tá? Então, vamos lá. Ué, mas ainda... Ainda, gente. Não, pois é. Mas tem que ver se o Aprender volta até lá. Beleza. Mas. Isso aqui que a gente fez. É uma máquina de Mealy ou uma máquina de Moore? Isso que a gente acabou de fazer aqui. Responde o contrário que tu pensou. Simples. Isso é uma máquina de Moore. Porque. A saída só depende do estado. A saída só depende do estado. As transições. Aí sim. Dependem do `opcode` que é a entrada. Porque a nossa entrada aqui vai ser o `opcode`. Então, o próximo estado depende do `opcode` do estado atual. A saída não. Depende só do estado atual. Viva Eduardo, funciona? Ok, então como é que nós vamos implementar isso de maneira fácil? Então a gente tem que ter uma lógica de saída e uma lógica de transição. Certo? Essa lógica de saída. Uma lógica de saída. E essa lógica de transição. Vou ter que fazer. Vou ter que ter um registrador de estado. E as entradas. As entradas. Vão ser o `opcode`. Então 7 bits do `opcode`. Certo? Tranquilo? Quantos estados tem aqui? Vou fazer de novo a pergunta. Quantos estados tem aqui? 10. Para eu codificar 10 estados. Quantos bits eu preciso? Beleza, mas quantos bits eu preciso? Para codificar os 10 estados. Não, para codificar os 10 estados. Para eu escolher 1 de 10 estados. Quantos bits eu preciso? Não Eduardo, 2 na 32 é 4 giga. 4 giga estados. Não. Vamos lá. Para eu representar os números de 0 a 9. Quantos bits eu preciso? Em binário, tá? Binário. Certo? Porque 4 bits eu consigo representar de 0 a 9. Até 15. Então eu consigo representar de 0 a 9. Então tá aqui. O nosso registrador de estado vai ter 4 bits. O bit menos significativo. Até o bit mais significativo do estado. Beleza? Então o nosso registrador aqui é de 4 bits. E a entrada de 7 bits. Então isso aqui seria. O que eu preciso fazer aqui? Nessa lógica de controle. Eu preciso calcular qual é o próximo estado. Next State. Então NS0, NS1, NS2, NS3. Que vai vir aqui. Que seria esses aqui. Qual é o próximo estado? Aqui tem 4 bits. Que eu vou ter que escrever. No registrador. Quando vier a borda de subida de clock. Então aqui vai estar. Tem que estar a lógica. De cálculo do próximo estado. E eu preciso também. Então a lógica de próximo estado está aqui. Dos sinais de saída. De todos eles. Então todos os sinais de saída. Tem que estar aqui. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17. Eu sabia que a contagem. Lá estava faltando algum. E eu não estava me lembrando qual. São 17 sinais de saída. Ok? Todos esses aqui. E agora eu preciso aqui. É só definir qual é a minha lógica de controle. Como é que eu implemento essa lógica de controle aqui? Poderia implementar. Através de equações lógicas? Não, vamos começar a ver uma coisa aqui. Vamos lá. Vocês poderiam fazer um circuito que tenha. No nosso caso aqui. É Moore, né? Então a gente não tem. Esse carinha aqui. O que isso significa? Que esses sinais aqui, esses 0 e 1, 0 e 2. Não influenciam. Nesses sinais aqui. Não influenciam. Mas esses sinais. Influenciam nesses 4 aqui. E o `opcode` influencia. Tanto nesse aqui. Não, influencia só. Desculpe, pessoal. Ao contrário. O `opcode` que é a entrada. Influencia só nesses sinais de próximo estado. Já o estado. Influencia tanto no próximo estado. O estado influencia tanto no próximo estado. Quanto na saída. Então esses 4 bits aqui vão. Definir esses sinais de saída. Uma forma simples. De se implementar isso. Uma ROM ali. Certo? Onde aqui eu tenho o endereço da ROM. E aqui eu tenho o que está armazenado. Nesse endereço da ROM. Vocês viram que implementar. Funções combinacionais com ROM, né? Vocês estudaram isso em CL, né? Viram? Se não viram em CL. Eu tenho certeza que viram em ISC. Viram ou não viram? Implementação de circuitos combinacionais. Com ROM. Então aqui eu tenho. Quantos bits? Quantas posições de memória. Eu tenho dentro dessa minha ROM? Se o endereço é de 7, 8, 9, 10, 11. Se o endereço é de 11 bits. Quantas posições de memória. Tem essa minha ROM? 2048 posições de memória. E cada posição de memória. Tem que armazenar tudo isso aqui. Então 17. 18, 19, 20, 21 bits. Então cada posição de memória da minha memória ROM. Tem 21 bits. São justamente esses bits aqui. Então dependendo. Do que seja a entrada. Simplesmente obtendo essa saída. Então a gente precisa. De uma ROM de 42 Kbits. Bom. Mas. Desses 2048 posições. Todas elas são utilizadas? O que vocês acham? Dessas 2048 posições. Será que todas elas são utilizadas? Não, né? Quantas. São utilizadas? Sim. Então cada posição de memória. Tem 22, 21 bits. Agora estou falando dessas 2048 posições de memória. Quantas são. Realmente utilizadas? Aí tem que pensar um pouquinho. 21 não. Por que seria 21 só porque é o número de saídas? Não. O que a nossa máquina de estados tem que saber? O estado 0 tem que ter 21 saídas. O estado 1 tem que ter 21 saídas. O estado 2 tem que ter 21 saídas. O estado 3 tem que ter 21 saídas. E assim por diante. Certo? Quantas posições de memória. Eu vou utilizar daquela 2048? Não é uma pergunta trivial não. Pessoal. A partir do diagrama de estados. Saber isso. Quer dizer, conseguir visualizar. Quantas posições vão ser utilizadas. Então vamos lá. Se eu estou no estado 0 eu vou só no estado 1. Então isso aqui é uma posição de memória. No estado 1. Agora depende do meu `opcode`. Então eu tenho 2 posições. 3 posições. 4 posições. 5 posições. Aqui vai sempre para o 1. 6 posições. Aqui vai sempre para o 0. 7 posições. Daqui vai ser sempre para cá. 8. Eu tenho 10. 11. E daqui 12 posições. 14. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 39, 40, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 63, 64, 65, 67, 67, 68, 68, 69, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 78, 79, 80, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 92, 93, 93, 94, 95, 96, 97, 98, 98, 99, 100, 100, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 53, 54, 55, 56, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 93, 94, 95, 96, 97, 98, 99, 100, 100, 101, 102, 103, 104, 105, 105, 106, 106, 107, 108, 109, 109, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1033, 1034, 1035, 1036, 1037, 1039, 1040, 1040, 1041, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1056, 1057, 1058, 1059, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1078, 1078, 1079, 1080, 1071, 1082, 1083, 1074, 1079, 1078, 1078, 1089, 1090, 1090, 1090, 1091, 1091, 1012, 1014, 1015, 1026, 1026, 1027, 1028, 1026. Não. O NS0 é o bit menos significativo do próximo estado. Então, se o próximo estado é 1, quanto é que vale o NS0 aqui? Vale 1, certo? Tranquilo? Quanto é que vale o NS0, por exemplo, do 3 para o 4? Eu estou no estado 3. Qual é o NS0, se ele vai para o estado 4? Zero. Ok, se eu estou no 4, qual é o próximo estado depois do 4? É o zero. Quanto é que vale o NS0? Zero. Certo? Então, esse aqui, o NS0 vale zero, esse NS0 vale zero, esse NS0 vale zero, esse NS0 vale zero, esse também, esse também, porque todos voltam para o estado zero. Ok. Se eu estou no estado 1, qual é o NS0? Bom, aí o NS0... Depende do `opcode`, certo? O próximo estado, se aqui é uma máquina de Mealy, o próximo estado depende da entrada, certo? Então, para eu saber o NS0 desse estado, eu preciso saber qual é a entrada. Então, se a entrada for um JAL, quanto é que vale o NS0 aqui para a entrada JAL? Ele não vai para o estado 9, então é 1. Se eu estou nesse estado e for um BEQ, quanto é que vale o NS0? NS0. Se eu estou nesse estado e tem um BEQ, quanto é que vale o NS0? Zero. Se eu estou nesse estado e vem um tipo R, quanto é que vale o NS0? Zero. Se eu estou nesse estado e vem um LOAD ou um STORE, quanto é que vale o NS0? Zero. Se eu estou nesse estado e vem um LOAD, qual é o NS0? Se eu estou nesse estado, 2. Ah, aqui vale 1. Se eu estou nesse estado e vem um STORE, quanto é que vale o NS0? 1 também. Então, quais são as condições que o NS0 vale 1? Quando o estado for o 0. Quando o estado for 1 e for o `opcode` de um JAL. Ou quando o estado for o 2 e se vocês notarem seria o NS0 no 2 sempre seria 1, mas o Patterson na resolução dele de livro, ele coloca no estado 2 e for um load e no estado 2 se for um store. Então, teria 4 condições: se eu estou no estado 0, o NS0 vale 1. Se eu estou no estado 1 e o `opcode` for um JAL, o NS0 vale 1 aqui. Se eu estou no estado 2 e for um load, o NS0 aqui vale 1. Se eu estou no estado 2 e for um store, o NS0 vale 1, certo? Ah, e se eu estou no estado 6 e vier, se eu estou no estado 6, qual é o NS0? Não depende da entrada, né? Então também vale 1. Se eu estou no 6 ele vai para o 7. Beleza? Então assim eu posso montar a equação do NS0. Daqui se eu estou no estado 0, independente do que tem o `opcode`, eu vou NS0 vale 1. Se eu estou no estado 2, esse aqui eu simplifiquei. Se eu estou no estado 2, estou no estado 2, independente do `opcode`, ele é o NS0 vale 1 também. Se eu estou no estado 6, independente do `opcode`, o NS0 também vale 1. E se eu estou no estado 1 e o `opcode` for de um JAL, esse aqui é o `opcode` do JAL, aí o NS0 vale 1 também, certo? Então tem essa equação lógica aqui. Beleza? Todo mundo entendeu a montagem? Repete quando você... Ah, estou no estado 0, eu vou para o 1, porque eu não consegui enxergar isso na tabelinha ainda. Na tabela? É. Aqui? Essa de agora. Pois é, isso aqui é o que eu estou dizendo, se eu estou no estado 0, independente do `opcode`, o NS0 vale 1. Eu não estou colocando aqui a tabelinha da saída, eu estou gerando a equação da saída. Gerando a equação da saída. Ah, não, eu quero dizer cada linha, cada, cada, quer dizer, tipo, você usou o 0, 2, 6 e 1, agora que eu entendi. É, 0, o 2 e o 6, o próximo estado é sempre ímpar. Se eu estou no 0 ele vai para o 1. Se eu estou no 2 ou ele vai para o 3, ele vai para o 5. É igual ou se eu estou no 6 ele vai para o 7. Então, nesses 3 estados, opa, esses 3 estados aqui, o NS0 vale 1. E no estado 1, o NS0 vai valer 1 se o `opcode` for de um JAL, porque o próximo estado é o 9, entendeu? Todos os outros casos, o NS0 vale 0. Entendi. Então, a partir das equações lógicas vocês podem botar o circuitinho que faz isso, né? Que está fácil, e como aqui já está em soma de produtos, uma forma que vocês devem ter visto lá em CL seria usando o PLA. Vocês viram a implementação do PLA? Seria isso aqui? O que é isso? O que é isso? Não, para mim parece aquele tabuleiro de campo minado. Tá, então isso aqui é o seguinte. Aqui eu tenho as entradas, todas as entradas, que é os `opcodes` e o estado. Eu tenho a entrada e a entrada negada. A entrada e a entrada negada. A entrada e a entrada negada. Todos eles aqui. E aqui eu tenho todos os sinais de saída. Certo? Então, todos eles estão aqui. O que significa esse diagraminha aqui? Deixa eu ver. Esse diagraminha significa: na vertical, as bolinhas verdes correspondem a portas AND. E na horizontal aqui, as bolinhas são portas OR. Então, por exemplo, o que seria o `PCWriteCond`? Então, o `PCWriteCond` vai ser dado como? Vai ser dado pelo S3 barrado, S2 barrado, então é um AND do S3 barrado, S2 barrado, S1 barrado, S0 barrado. São esses aqui. Esse, esse, esse e esse. Fazem um AND. Beleza? Entenderam isso? Esse aqui seria o circuito equivalente a esse aqui. Equivalente a essa representação. Então eu estou usando um AND na vertical de 4 entradas, onde todas elas são barradas. O S0, S1, S2, S3, S4. O S0, S1, S2, S3. S1, S2 e S3. Ok? Quando mais, isso aqui vai entrar numa porta OR que vai dar a saída `PCWriteCond`. Por isso que eu disse que na horizontal são OR. Então o `PCWriteCond` é composto por um OR dessa coluna com essa coluna aqui. E o que é essa segunda coluna? É um AND do que? É um AND de S3 com S0, S2 barrado, S1 barrado e S0. S3, S2 barrado, S1 barrado e S0. Entendeu? Então aqui eu defino que o `PCWriteCond` é dado por um OR dessas duas colunas. E essa coluna aqui é um AND desses 4 pontinhos verdes aqui. Então assim, e essa coluna aqui é um AND desses 4 pontinhos verdes: esse, esse, esse e esse. S3, S2 barrado, S1 barrado e S0. Cada coluna é uma função. Cada coluna são as entradas de uma porta AND. Então aqui eu poderia ter 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 portas AND que depende dos minitermos. E as saídas são os nossos 21 sinais. Então isso aqui existem chips que a gente simplesmente diz o que eu quero ligar com o que eu quero ligar e ele gera, já tem aqui esse mar de portas AND. Então é uma porta AND aqui de 14 entradas. Não, 14 não, isso aqui são 11, 22 entradas onde somente essas aqui estão ligadas. Certo, nessa segunda coluna outra porta AND de 22 entradas onde somente essas 4 aqui estão ligadas e assim sucessivamente até a última aqui onde eu tenho uma AND de 22 entradas onde somente essa, essa, essa, essa, essa estão ligadas. Tá, as saídas dessas portas AND eu posso fazer um OR com elas, já que é soma de produtos, né? Então no caso de `PCWriteCond` é um OR desse com esse. No caso do NS0 é um OR desse com esse, com esse, com esse, com esse. Precisa refazer a colocação das bolinhas, tá? Então se vocês forem verificar esse aqui, muito provavelmente vai ter algumas coisinhas erradas aqui, algumas bolinhas colocadas erradas, tá? Por isso que eu coloquei essa observação aqui. Isso aqui é só pra mostrar pra vocês a técnica, tá? Então a gente pode programar. O programa é igual que array, PLA, é isso. Certo? Que é mais eficiente de se montar do que montar uma ROM de 2048 posições. Ok. Então isso aqui, esse aqui por exemplo, essas aqui são as entradas e essas aqui são as saídas. Pode ser isso aqui. Aqui estão as entradas e aqui estão as saídas. Certo, então aquela PLA eu posso colocar diretamente aqui virada, né? Que as saídas aqui, as entradas estão de lado assim. Certo, entradas e saídas. A ROM eu poderia colocar direto também. Entradas e saídas. Beleza. É um tipo de protoboard? Não, não é um tipo de protoboard porque essas portas AND de 21 entradas já estão feitas no chip. O que eu vou fazer é só a conexão com os pinos de entrada. Então não é um protoboard que eu consigo montar coisas qualquer aqui. Não, eu tenho portas AND e eu tenho portas OR que eu só seleciono quais são que eu quero ligar com o que. Entendeu, Marcelo? Beleza. Então isso aqui é como se faz o nosso, a nossa máquina de estados, utilizando então esse modelinho clássico aqui. Vocês fizeram isso lá em CL, só que não era tão grande assim. Vocês montaram qual era a função? A função de próximo estado a partir das entradas e o estado atual. E montaram qual era a função da saída a partir da entrada e do estado atual. Vocês fizeram isso, não fizeram? Funções de transição e funções de saída. Tranquilo. Isso aqui eu só estou mostrando que para um problema um pouco maior, a gente usa soluções mais padronizadas. A gente não tenta fazer um circuito com as portas lógicas diretas. Mas que daria para fazer também. Ok. Mas o objetivo disso aqui é, o que que acontece? Eu falei para vocês que o x86 funciona desse jeito assim, onde cada instrução passa por diversos estágios para ser executada. Então instruções mais curtas ele passa por menos estágios, instruções mais longas ele passa por mais estágios. Vocês conseguem, pelo menos tentar imaginar qual seria o tamanho do diagrama de estados no x86? Esse diagrama de estados foi para quantas instruções? Quantas instruções esse nosso RISC-V executa? Vamos lá. AND, OR, ADD, SUB. Set on less than, Branch, JAL, Load, Store. Então esse diagrama de estado aqui é para um RISC-V de 9 instruções. Beleza? Gerou esse diagrama de estados. Pense num processador que tem mais de 2 mil instruções. Qual seria o tamanho desse diagrama de estados? Pegaram o nível de complexidade que seria se eu quisesse desenhar um diagrama de estados para esse problema? Uma máquina de estados capaz de executar mais de 2 mil instruções. O tamanho de uma pizza. Eu te diria o tamanho de um andar inteiro. x86 aqui é de 6 estados. Muito bem. Seria impossível para a gente conseguir desenhar esses estados da máquina de estados para o x86. Ora, então como é que eles fazem se não é por diagrama de estados? Eles bolaram. Tem uma técnica de implementação de máquinas de estados mais eficiente que é o que a gente chama de microprogramação. Então a ideia aqui é que a gente faça o nosso diagrama de estados virar um microprograma. Onde cada estágio, cada estado é uma microinstrução. E a gente vai ver que a gente pode gerar essa micro-ISA. Já que eu tenho microinstruções que têm micro-ISA que vão ser determinadas. Então eu tenho uma micro-ISA e eu posso escrever então a minha máquina de estados como se fosse um programa. Certo? Que é muito mais fácil de se ver do que de se ler um programa do que tentar entender um diagrama de estados muito grande. Então vamos ver como é que isso se faz, tá? Tá aqui. Ok. Então essa é a motivação. Se eu tenho uma máquina de estados muito grande, a gente vai ao invés de representar o nosso problema por uma máquina de estados. O problema vai ser representado por um microprograma. Nós vamos ver que os dois são a mesma coisa, só que um é uma visualização de bolinhas e setinhas e o outro é uma visualização de programa. Então vamos lá. O que seria microprogramação? Então o meu processador quando ele quer executar uma instrução, ele executa um microprograma que executa aquela instrução. Certo? Que daí a manutenção fica muito mais fácil. Ok. Então uma microinstrução é definida pelos valores dos sinais de controle que atuam na unidade operativa durante um estado da máquina de estados finita. Então uma microinstrução é dado pelas saídas de cada estado. Opa, agora vamos começar a ligar as coisas. Cada estado tem uma saída, tem uma saída, não tem 21 saídas? 21 saídas em cada estado. Então uma microinstrução teria 22 bits. Entenderam? A execução de uma instrução do processador pode então ser realizada através de uma sequência de microinstruções. Se cada estado define uma saída e a saída é uma microinstrução, eu sequenciar essas microinstruções vai te dar então as transições do diagrama de estados, as flechinhas. Certo? Então eu vou definir sequências de microinstruções que vão ser as transições e o conjunto que seria o diagrama de estados completo, a figura do diagrama de estados completo, é um microprograma que a gente vai ver como um microprograma. Ok. Então vamos ver como é que se faz isso. Bom, no caso aqui do RISC-V, como ele é um processador RISC, a maquinazinha aqui vai ficar bem pequena, o nosso programa aqui vai ficar pequeno. Então vamos lá. Primeira mudança que nós vamos fazer no nosso modelo. No nosso modelo a gente tinha, vamos voltar aqui. A gente tinha aqui um registrador de estado e aqui eu tinha os bits de próximo estado que definiam qual era o próximo estado. Eu vou trocar essa ideia aqui. Eu defini explicitamente qual é o próximo estado. Eu não vou mais definir explicitamente qual é o próximo estado. Eu vou definir como que eu chego ao próximo estado. Entendeu? Dado o estado atual, o que que eu tenho que fazer para chegar no próximo estado? Então ao invés de eu definir, ah, o estado 0, o próximo estado é o estado 1. Estou no estado 0, o próximo estado é o estado 1. Não, eu vou dizer eu estou no estado 0 e eu vou fazer isso para chegar no próximo estado. Ok. E o que que seria o isso? Então vamos lá. Vamos lá. Então só para voltar aqui, a gente continua tendo o nosso registrador de estados. Só que ao invés de agora eu definir qual é o próximo estado, eu vou definir aqui um controle de endereçamento que é como que eu chego ao próximo estado. Aqui vai estar o próximo estado. Então a nossa máquina de estados não vai mais dizer quem é o próximo estado, mas sim como que eu chego no próximo estado. Então ok, vamos lá. Então eu vou fazer vocês deduzirem para mim como é que é essa regrinha. Se eu estou no estado 0, qual é o próximo estado? Escrevam aí. Se eu estou no estado 0, qual é o próximo estado? Se eu estou no estado 6, qual é o próximo estado? Ah não, vamos fazer o seguinte, esquece, esquece, vamos começar pelo lado contrário. Se eu estou no estado 4, qual é o próximo estado? Estou no estado 4, qual é o próximo? 0. Se eu estou no 5, qual é o próximo estado? 5. Qual é o próximo estado? 0. Se eu estou no 7, qual é o próximo estado? 0. Se eu estou no 8, qual é o próximo estado? 0. Se eu estou no 9, qual é o próximo estado? 0. Quer dizer, se eu tiver em um desses estados, 4, 5, 7, 8 ou 9, o próximo estado é o 0. Certo? Então, essa vai ser uma forma que eu vou definir, ok, meu próximo estado é o estado de Fetch, de volta ao início. Certo? Então, se eu estou no estado 4, eu vou voltar ao início. Se eu estou no estado 5, eu vou voltar ao início. 7 também, 8 também, 9 também. Então, essa é uma primeira forma de se atingir o próximo estado. Ok, se eu estou no estado 0, qual é o próximo estado? 1. Se eu estou no estado 6, qual é o próximo estado? 7. O que tem esses dois em comum? Se eu estou no estado 3, qual é o próximo estado? 4. O que essas três transições têm em comum? Estou no 0, vou para o 1. Estou no 6, vou para o 7. Estou no 3 e vou para o 4. Não, o que tem em comum? Como é que eu chego no próximo estado? Qual é a regra de formação para chegar no próximo estado? Estou no 0, vou para o 1. Estou no 6, vou para o 7. Estou no 3 e vou para o 4. Eu quero saber, se eu estou no estado 3, no estado 6 ou no estado 0, qual é a regra de formação para eu atingir o próximo estado? Qual é a regra de formação? Por que você está só chutando aí? Certo que vocês não entenderam o que eu quis dizer. Eu estou definindo regras de como se chega no próximo estado. A primeira regra é, volte ao início, que serve para esse estado, para esse, para esse, para esse e para esse. A segunda regra. A segunda regra, eu vou mostrar quais são os estados que atendem essa regra. Se eu estou no estado 0, eu vou para o estado 1. Se eu estou no estado 6, eu vou para o estado 7. Se eu estou no estado 3, eu vou para o estado 4. Qual é essa regra de formação que, dado o estado atual, eu chego no próximo estado? Tu está chegando perto, Marcelo, mas eu preciso de uma formalização matemática. Ah, sei lá, 1 mais 1 é o 2, 1 mais 5 é o 6. Tu está chegando perto também, Eduardo. A ideia é, como é que eu... Como é que eu calculo o próximo estado se eu estou no estado 0? Como é que eu calculo o próximo estado se eu estou no estado 6? E qual é o próximo estado se eu estou no estado 3? O que eu tenho que fazer com o estado atual para chegar no próximo, nesses três casos? Somar mais 1? Exato! A regra de formação é, incremente de 1. Você soma 1, o estado atual. Se eu somar 1, eu chego no próximo. O estado atual. Se eu incrementar 1, eu chego no próximo. O estado atual. Se eu incrementar 1, eu chego no próximo. Essa é a regra de formação. Certo? Tranquilo? Ok. Então, a gente fez a regra de transição do estado 0, do estado 6, do estado 8, do estado 9, do estado 7, do estado 5, do estado 3, do estado 4. Ficaram faltando dois estados aqui. Ok. Se eu estou no estado 1, qual é o próximo estado? Como é que eu chego? Qual é o próximo estado? Se eu estou no estado 1? Eu vou ter que verificar qual é o `opcode`. Certo? Então, através do `opcode`, é que eu vou ter que saber que o próximo estado é o 2, que o próximo estado é o 6, que o próximo estado é o 8, e que o próximo estado é o 9. Certo? Então, se eu estou no estado 1, eu vou precisar analisar o `opcode` para decidir qual é o próximo estado. E a mesma coisa acontece aqui no estado 2. Para eu definir qual é o próximo estado. Se eu estou no estado 2, eu vou precisar analisar o `opcode`. Certo? Se o `opcode` for de load, vem para cá. Se o `opcode` for de store, vem para cá. Tranquilo? Então, como que nós vamos implementar essas regras de formação? Está aqui. Então, o meu controle de endereçamento, ele vai selecionar um MUX. E esse MUX é que vai me dizer quem é o próximo estado que vai ser armazenado aqui no registro. Então, se o controle de endereçamento for 0, qual é o próximo estado? Se o controle de endereçamento for 0, 0. Sim, vai receber. É isso que a gente está fazendo agora. Então, se o controle de endereçamento, que é aquilo que sai da máquina de estados, é esse aqui. Quer dizer, é aquilo que sai da minha lógica. For 0, qual vai ser o próximo estado? 0, porque ele vai selecionar essa entrada e essa entrada está dizendo, olha, o próximo estado é o 0. Certo? Se for 1, 1 aqui. 3, qual vai ser o próximo estado? Se for 3. Não, o próximo estado vai ser o estado atual mais 1. Certo? Então, se for 3, o próximo estado, eu vou selecionar essa entrada aqui, vai ser o estado atual mais 1. Ok, se for 1. Se for 1, nós vamos fazer... 1, 0. 1, 0. 1, 0. 1, 0. 1, 0. 1, 0. 1, 0. Esse processamento das entradas eu vou precisar saber as entradas, tá? Então, o jeito mais fácil de fazer isso em termos de programação, a gente chama de ROM de despacho, tá? Dispatch, tá? Dispatch. Mas traduzido como despacho, não é despacho de encruzilhada, mas é uma ROM de despacho. O que vai ter nessa ROM? Ele vai ter como entrada aqui o `opcode`. Certo? E vai ter como saída o estado. Ok. Então, vai ter como entrada o `opcode` e a saída com o estado. Beleza. Então, no nosso caso aqui, se o `opcode` nesse caso aqui, essa aqui é a ROM de despacho. Vai trabalhar no estado 1. Então, se o `opcode` for de um JAL, ele tem que ir para o 9. Se o `opcode` for de um BEQ, ele tem que ir para o 8. Se o `opcode` for de um tipo R, ele tem que ir para o 6. E se o `opcode` for de um load ou de um store, ele tem que ir para o 2. Então, o que vai ter nessa nossa ROM aqui? Aqui, essa nossa ROM vai ser isso aqui. Esse aqui é o endereço e esse aqui a saída dessa nossa ROM. Então, eu vou implementar isso como uma ROM. Quer dizer, se o `opcode` for do tipo R, a saída é o 6. Se o `opcode` for de um JAL, a saída é 9. Não, aí que está o problema. Não é uma ROM bem pequena, não. Ele pode se tornar uma ROM bem pequena se eu simplificar. Não, pior que não dá, porque a saída é 9. Não vai dar para simplificar muito essa ROM. Se eu tenho aqui o `opcode` do BEQ, então a saída é 8. Se for um load ou se for um store, a saída é 2. Certo? Então, dessa maneira, se eu selecionar aqui controle de endereçamento 1, eu estou usando essa ROM de despacho 1, que é essa aqui, para calcular qual é o próximo endereço e eu vou colocar aqui. Certo? Isso aqui é uma ROM pequena. Quantos endereços tem aqui? Quantos bits de endereçamento tem? 7. 7 são quantos endereços? Não! Meu Deus do céu. 7 são quantos endereços? Eu sei que tu sabe escrever bonitinho, vai lá. Vamos lá que a gente não termina essa aula hoje. Tem bastante coisa linda pela frente. Quanto é que é 2 na 7, pessoal? Pega o calculador e calcula. Ah, vão 128. Certo? Então essa ROM aqui vai ter 128. 128 posições. Dessas 128 posições, uma só me interessa. Essa 1, 2, 3, 4, 5 posições. O resto tudo não me interessa, tá? A implementação toca. Mas é bom se isso aqui for programável. Se isso aqui for programável, eu posso programar isso aqui, né? Para se eu precisar mudar alguma coisa, daí fica fácil se for uma ROM, tá? Então essa aqui seria a ROM de despacho 1, tá? Então eu tive que mudar isso aqui. Utilizada para o controle de endereçamento do estado 1, né? Aqui eu vou ter que escolher a partir do `opcode` qual é o estado que eu vou. A partir do `opcode`. No estado 2 nós vamos utilizar então o controle de endereçamento 2 que a gente vai escolher o próximo estado a partir de uma ROM de despacho 2, tá? Que entra também o `opcode`. Só que nesse caso aqui, se o `opcode` for de um load, o próximo estado é o 3. Se o `opcode` for de um load, o próximo estado é o 5. Tá certo isso? Vamos ver aqui no estado 2. Eu vou usar uma ROM de despacho. Se o `opcode` for de um load, eu tenho que ir para o 3. Se o `opcode` for de um store, eu tenho que ir para o 5. Certo? Então nessa ROM de despacho 2 aqui, das 128 posições eu vou usar só duas. Se por acaso a gente não vai mexer mais no processador, óbvio que eu posso simplificar isso aqui, colocar uma ROM de duas posições apenas, porque é só esse bit aqui que interessa que é 0 e aqui é 1. O resto é tudo igual. Então se eu não for mais mexer no processador, colocar mais coisas nele, uma ROM de despacho de 2 bits, de 1 bit já é o suficiente. Daí esse aqui teria que analisar, acho que seria uma ROM de despacho de 1 tirando os 3 aqui de 4 bits, porque esses 3 nem, esses 3 aí, esse aqui a gente pode desprezar. É, deve dar uma simplificada aí. Isso, baixar a atualização do processador. Exatamente. Que o processador seja atualizável. A gente não faz isso ainda, não coloca, mas é possível. Não, porque essas ROM de despacho seriam colocadas internamente ao processador. Logo, não seria acessável pela memória. Elas são internas ao processador e é essa memória interna ao processador que poderia ser atualizável, entendeu? Ela não está fora. Não é uma memória. Poderia ser uma memória Flash aqui, por exemplo. Ok. Então, desse modo eu tenho 4 modos de endereçamento. O modo de endereçamento Fetch, que ele volta para o início, volta para o zero. O modo de endereçamento Fetch. O modo de endereçamento NEXT, que é o estado é o estado atual mais 1. E o modo de endereçamento ROM de despacho 1 e o ROM de despacho 2. E com isso então, para cada um dos estados eu tenho qual é a ação que eu preciso tomar para a próxima endereçamento. Isso aqui a gente acabou de fazer. Quer dizer, se for o estado 0, eu preciso que ele incremente. Então o controle de endereçamento é o 3. Se eu estou no estado 1, eu preciso que a ROM de despacho 1, né, diga qual é o próximo. Então esse aqui seria o controle de endereçamento 1. Se eu estou no estado 2, a ROM de despacho 2 é que tem que dizer. Então controle de endereçamento 2. Se eu estou no estado 3, o próximo estado é o incrementa. Então o controle de endereçamento 3. Se eu estou no 4, no 5, no 6, no 7, no 8 é o 0. Quer dizer, volta o estado inicial. E se for o 7 também incrementa. Certo? Então é isso aqui que a gente vai precisar armazenar agora para cada estado, não mais o número do estado para onde ele deveria ir, mas sim como que eu chego no próximo estado. Entendido, pessoal? Uma mudança de filosofia. Eu não estou definindo qual é o próximo estado. Eu estou definindo como que eu chego no próximo estado. Beleza. Ok. Então está aqui. Então está aqui. Então está aqui. Então agora a gente pode, então agora a gente pode fazer um paralelo, né? Se esse aqui é um registrador de estado e aqui eu tenho a ROM e aqui a lógica de seleção de endereço, se acaba a energia, o processador é resetado, né? Tu não pode continuar de onde tu parou, porque a tua memória RAM apagou toda. Então, entendido, Marcelo? Não, o controlador não sabe. Como é que, se tu não está alimentando o teu chip, como assim, com o que que tu vai trabalhar? Ok. Então agora vamos fazer o paralelo. Se aqui eu tinha a nossa lógica combinacional, agora eu tenho aqui a memória de microcódigo. Aqui, o que era o estado, agora vai virar um contador de microprograma, como se fosse o PC, né? Que indica qual é a microinstrução que eu estou sendo, que eu estou, que eu estou executando naquela hora, certo? Então, eu vou `microPC` isso aqui, tá? E aqui eu tenho as instruções. Cada instrução agora vai ter 17 mais 2 bits. Então, 19 bits. Não mais 21, certo? Porque eu preciso aqui somente 2 bits. Então, agora cada microinstrução vai ter 19 bits. E aqui está a lógica de seleção, onde entra o `opcode`, está o mais 1, e aqui eu seleciono qual vai ser o próximo, a próxima microinstrução a ser executada. Ok? Entendido isso aqui, pessoal? Então, estamos passando do diagrama de estados para microprograma. E aqui, então, eu tenho o `microPC`. Ok. Então, como é que a gente faz uma microinstrução? É da mesma forma que a gente fez a instrução do RISC-V, a gente pode fazer as microinstruções. A instrução do RISC-V é dividida em campos, né? E cada campo tem um significado. As microinstruções nós vamos fazer da mesma maneira. Vamos definir em campos, e cada campo tem um significado. Vou fazer uma coisinha rápida aqui. Ixi! Eu apaguei. Sem graça. Vou ter que fazer tudo de novo. É. Tá, o meu programa é usualmente apresentado em ROM, PLA, EEPROM, Flash, tá? Onde tu podes, então, atualizar o teu processador. Tá? Então, vamos fazer essa, essa, a nossa micro-ISA. Tá? Então, a nossa micro-ISA, eu vou te pegar a instrução, a instrução tem quantos bits, pessoal? A instrução tem quantos bits? Dezenove. São esses dezessete aqui, mais esses dois. E vou dividir em campos. Então, esses aqui vão ser os campos que a gente vai dividir, tá? Controle da ULA, controle do banco de registradores, controle da memória, controle do PC, Origem A da ULA, Origem B da ULA, e sequenciação. Então, a gente vai dividir a instrução nesses campos. Cada campo, então, vai ser responsável por definir alguma dessas coisas aqui. Então, vamos lá. Controle da ULA. O nosso controle da ULA é feito por quem? Vamos lá. Quem é que controla a ULA? Quem é que controla a ULA? Quem é que controla a ULA? O controle da ULA, certo? Mas do controle principal, quem é que diz o que a ULA vai fazer? É o `op_ALU`. Certo? Então, o nosso controle da ULA vai ter dois bits, e são justamente os dois bits do `op_ALU`. Cadê? Aqui. Tá? Então, o controle da ULA vai ser o `op_ALU` zero e o `op_ALU` um. São esses dois sinais que controlam a ULA. Vai ficar feio isso aqui, tá, pessoal? E que... Que... E esse controle pode assumir que valores? Eu posso querer que a ULA faça uma soma, né? Posso? Querer que a ULA faça uma soma? Sim. Qual seria o código para isso? Zero, zero. Posso querer que a ULA faça uma subtração. Qual é o código para isso? Zero, um. Quero que a ULA faça o que o `funct` mande ela fazer. Que é o um, zero. Beleza? Então, note o que que eu estou escrevendo aqui. Eu estou escrevendo qual deve ser o valor do campo e qual a linguagem de máquina correspondente. Ok? Então, se eu quero o ADD, isso aqui tem que ser compilado para linguagem de máquina como sendo zero, zero. SUB, zero, um. Funct, um, zero. Ok? Origem da ULA. Quem é que comanda a origem da ULA? Quer dizer, a origem... A origem não é a Origem A da ULA, tá? Então, é a Origem A da ULA bit zero e a Origem B da ULA bit um. Quer dizer, desculpa, esse aqui é a Origem A da ULA bit um que eu estou fazendo aqui. Tá? Porque esse aqui é a origem um. Tá? Então, quem que controla o que que a ULA vai ter na sua entrada? Então, é o bit... É o sinal Origem A da ULA, tá? Que pode... Que tem dois bits, o zero e o um. Então, o que que eu posso fazer com esses dois bits? Quais são as alternativas? A Origem A da ULA pode ser o quê? Ela pode ser `PC_BEQ`, pode ser PC, pode ser A. Certo? Relembrando aqui pra gente não errar. Tá? Então, aqui, ó. O zero é o `PC_BEQ`, um é o A e o dois é o PC. Então, PC seria código dois, `PC_BEQ` é o código zero e o A é o código um. Certo? Origem dois da ULA. É a nossa Origem B da ULA. Origem B da ULA. E tem também dois bits. Bit zero e o bit um. E aí, vamos ver. Se for o código zero zero, o que que vai ser a origem da ULA? Se for o código zero um, se for o código um zero e se for o código um um. É que utiliza todos. Então, zero zero é o B. Zero um é o 4. Eu estou seguindo o que o Marcelo está colocando ali. Um zero é o imediato. E o um um é o imediato deslocado. Então, vou chamar de imediato B, tá? Imediato deslocado. Ok? Então, B, 4, imediato, imediato deslocado. Que, passando para código de máquina, seria zero zero, zero um, um zero e um um. Controle do banco de registradores. O banco de registradores. O que que a gente precisa de controle dele? Deixa eu dar uma olhadinha aqui, ver se eu estou fazendo tudo certo aqui. Beleza. Então tá. Para esse controle de B, com esses registradores, quais são os sinais de controle do banco de registradores? Então, vamos voltar aqui para o streaming e a gente analisar. Ok. O que que controla o banco de registradores? Então, de cara, o `RegWrite` controla o banco de registradores. Certo? E o `MemToReg` controla também o que que vai ser escrito no banco de registradores. Então, a gente vai ter três bits aqui. O `MemToReg` e o `RegWrite`. Então, três bits para pro campo controle, que é o `RegWrite`, o `MemToReg` bit 1 e o `MemToReg` bit 0. Ok? Então, vamos lá. Agora eu preciso definir quais são os comandos que eu posso dar, né, nesse campo. Quais são os comandos que eu posso fazer aqui? Eu posso querer escrever no banco de registradores aquilo que vem da ULA. Né, então, um `Write_ALU`. Então, aquilo que vem da ULA eu quero escrever no banco de registradores. Qual seria o código? Qual seria o código? Repete rapidão, por favor. Hã? Repete rapidão. Tá bom, eu estou vendo aqui o que que eu posso fazer com o banco de registradores. Então, a primeira coisa que eu posso fazer com o banco de registradores, é escrever o que vem da ULA aqui. Certo? Escrever no banco de registradores. Logo, eu tenho que acionar o `RegWrite` e o `MemToReg` tem que ser 0, 0. Então, para função `Write_ALU`, que é escrever o que vem da ULA, eu preciso `RegWrite` igual a 1, `MemToReg` 1, 0 e `MemToReg` 2, 0. 0, 0. Que mais que eu posso escrever? Escrever o valor de PC mais 4. Certo? Para escrever o valor de PC mais 4 no banco de registradores, o que eu preciso fazer? Aciona, `RegWrite` e o valor que está aqui no PC é que eu tenho que escrever no banco de registradores. Certo? Então, `RegWrite` igual a 1 e `MemToReg`, 0, 1. `RegWrite` 1, 0, 1. Outra coisa que eu posso escrever é escrever no banco de registradores aquilo que vem da memória. Certo? Então, `Write_Mem`. Então, isso aqui deve ser 1, 1, 0. Suponho eu.",
        "video_source": "OAC_2022-03-30.mp4"
    },
    {
        "id": 6,
        "timestamp_start": 6238.48,
        "timestamp_end": 6240.48,
        "slide_description": "Como Engenheiro de Computação Sênior, analisei o slide e o contexto da aula de Arquitetura de Computadores. A seguir, apresento a extração e descrição do conteúdo para um sistema de busca semântica (RAG):\n\n**1. Identificação da Aula e Contexto:**\nA imagem corresponde ao ambiente de uma conferência web, intitulada \"Sala de Aula de OAC\" (Organização e Arquitetura de Computadores), com duração total de 1 hora e 4 minutos e 9 segundos (\"104:09\"). No canto superior direito da área de apresentação, é visível um logotipo que identifica a origem do material e do curso:\n*   **Instituição:** Universidade de Brasília\n*   **Departamento:** Departamento de Ciência da Computação\n*   **Disciplina:** OAC/OS – Organização e Arquitetura de Computadores\n*   **Professor:** Prof. Marcos Vinicius Lima\n\n**2. Status da Apresentação:**\nA área principal de conteúdo da tela está escura, exibindo a mensagem: \"Fim da apresentação de slides. Clique para sair.\" Isso indica que a fase de exibição dos slides da aula foi concluída. Sobreposto a essa área, há uma caixa de diálogo do \"Microsoft PowerPoint\" questionando: \"Quer manter suas anotações à tinta?\", com as opções \"Manter\" e \"Descartar\". Isso sugere que o professor ou apresentador utilizou anotações à tinta digital durante a exposição dos slides, prática comum em aulas online para enfatizar pontos ou detalhar diagramas.\n\n**3. Conteúdo do Bate-papo Público:**\nO painel lateral esquerdo exibe um \"Bate-papo público\" com várias mensagens, predominantemente do usuário \"Marcello Brandao Sca...\", que parecem ser respostas rápidas ou perguntas relacionadas a conceitos técnicos. As mensagens transcritas fielmente são:\n*   \"00\" (15:37)\n*   \"01\" (15:38)\n*   \"sim\" (15:39)\n*   \"B\" (15:40)\n*   \"4\" (15:40)\n*   \"Imm\" (15:40)\n*   \"<<1\" (15:40)\n*   \"a escrita\" (15:41)\n*   \"101\" (15:42)\n*   \"100 na verdade\" (15:43)\n*   \"111\" (15:44)\n\n**Análise Técnica do Bate-papo:**\nAs mensagens são densas em termos potenciais de Arquitetura de Computadores:\n*   **Números binários/hexadecimais/base-10:** \"00\", \"01\", \"10\", \"4\", \"101\", \"100\", \"111\" podem representar valores de registradores, endereços de memória, dados binários ou resultados de operações lógicas/aritméticas.\n*   **\"Imm\":** Provavelmente se refere a \"Immediate\", um valor constante em instruções de assembly, utilizado diretamente na instrução em vez de ser carregado de um registrador ou memória.\n*   **\"<<1\":** Indica uma operação de \"left shift\" (deslocamento para a esquerda) por 1 bit. Esta é uma operação fundamental em processadores para multiplicação por potências de dois, manipulação de bits ou alinhamento de dados.\n*   **\"a escrita\":** Pode se referir à operação de escrita (write) em memória, registradores ou em um barramento de dados, um conceito central na fase de \"Write-back\" de pipelines ou em operações de acesso à memória.\n\n**4. Diagramas e Código:**\nNão há diagramas explícitos de Datapath, Pipeline, Hierarquia de Memória ou blocos de código (Assembly, C, Verilog) visíveis diretamente na área principal do slide. O conteúdo do bate-papo, no entanto, oferece fragmentos que sugerem a discussão de conceitos relacionados a operações em nível de máquina ou assembly, como valores imediatos e deslocamentos de bits.\n\n**Resumo para RAG:**\nEsta sessão de \"Organização e Arquitetura de Computadores\" (OAC/OS) da Universidade de Brasília, ministrada pelo Prof. Marcos Vinicius Lima, utilizou o Microsoft PowerPoint (com anotações à tinta). A apresentação formal dos slides foi concluída. O bate-papo interativo evidencia discussões técnicas sobre valores numéricos (possivelmente binários ou hexadecimais), constantes imediatas (\"Imm\"), operações bitwise como deslocamento para a esquerda (\"<<1\"), e operações de escrita (\"a escrita\"), indicando um engajamento com detalhes de baixo nível da arquitetura de processadores ou memória.",
        "transcription": "Ah, caramba, o que que eu fiz aqui?",
        "video_source": "OAC_2022-03-30.mp4"
    },
    {
        "id": 7,
        "timestamp_start": 6240.48,
        "timestamp_end": 6245.48,
        "slide_description": "Como Engenheiro de Computação Sênior, analisei o slide e o contexto fornecido. A imagem não apresenta um slide tradicional de apresentação com diagramas de arquitetura de hardware ou código-fonte. Em vez disso, ela exibe a interface de uma plataforma de ensino a distância (LMS) durante uma aula síncrona online, focando na página de uma disciplina de Arquitetura de Computadores.\n\nAqui está a descrição detalhada do conteúdo visual, extraída para um sistema de busca semântica (RAG):\n\n**1. Conteúdo Textual Transcrito Fielmente:**\n\n*   **Título da Janela do Navegador:** \"ConferênciaWeb - Sala de Au...\" (Inferido como \"Sala de Aula de OAC\").\n*   **URL principal:** `aprender3.unb.br/course/view.php?id=11880#section-0` (Aponta para o sistema Moodle da UnB).\n*   **Título da Sala de Aula:** \"Sala de Aula de OAC\" com um cronômetro indicando \"104:13\".\n*   **Identificação do Participante/Professor:** \"Marcus Vinicius Lam...\" (parte do nome \"Marcus Vinicius Lamar\" é visível na tela da conferência e na lista de usuários).\n*   **Título do LMS:** \"UnB APRENDER\".\n*   **Código e Nome da Disciplina:** \"CIC0099 - Organizaçã...\" (O título completo da disciplina é \"Organização e Arquitetura de Computadores\", inferido pelo código \"OAC\" e o contexto).\n*   **Menus de Navegação do LMS (Aba superior):** \"Início\", \"Painel\", \"Eventos\", \"Meus Cursos\", \"Este curso\".\n*   **Barra de Navegação (Breadcrumbs):** \"> Painel > Meus cursos > OAC-A-2021-2\" (Indica o caminho até a turma OAC-A-2021-2).\n*   **Seções da Página da Disciplina:**\n    *   \"Geral\"\n    *   \"Fóruns\"\n        *   \"Avisos\"\n        *   \"Fórum de dúvidas\"\n    *   \"Plano de Ensino\"\n    *   \"Definição dos Grupos\"\n    *   \"Trabalho de Extensão\"\n*   **Campo de Busca do LMS:** \"Search courses\"\n*   **Botões de Ação do LMS:** \"Ativar edição\", \"Mostrar blocos\", \"Tela cheia\".\n*   **Interface da Conferência (Painel esquerdo):**\n    *   **Título:** \"ConferênciaWeb\"\n    *   **Seções:** \"MENSAGENS\", \"NOTAS\", \"USUÁRIOS (9)\".\n    *   **Subseções de MENSAGENS:** \"Perguntas\", \"Bate-papo público\".\n    *   **Conteúdo do Bate-papo público (mensagens de Marcello Brandao Sca...):**\n        *   \"00\"\n        *   \"01\"\n        *   \"10\"\n        *   \"sim\"\n        *   \"B\"\n        *   \"4\"\n        *   \"Imm\" (ou \"lmm\")\n        *   \"<<1\"\n        *   \"a escrita\"\n        *   \"101\"\n        *   \"100 na verdade\"\n        *   \"111\"\n        *   \"110\"\n    *   **Campo de entrada de texto do chat:** \"Enviar mensagem para Bat...\"\n    *   **Lista de Usuários (parcialmente visível):** Marcus Vinicius Lam... (Você), Eduardo Ferreira ..., Gustavo Rodrigu..., João Alberto Trav..., Marcello Brandao..., Maycon Vinnycu..., Michel Luis Duwe, Victor Hugo Fran..., Victor Hugo Rodr...\n\n**2. Descrição de Diagramas e Fluxo de Dados:**\n\nA imagem **não contém diagramas técnicos de Arquitetura de Computadores** como datapath, pipeline, ou hierarquia de memória. O que está visível é a interface de um sistema de gerenciamento de aprendizagem (LMS) e uma plataforma de videoconferência. Portanto, não há estruturas ou fluxo de dados de hardware/software para descrever neste contexto.\n\n**3. Elementos Adicionais e Contexto Técnico:**\n\nA imagem documenta um ambiente de ensino remoto da disciplina de \"Organização e Arquitetura de Computadores\" (CIC0099) na Universidade de Brasília (UnB). O professor, Marcus Vinicius Lamar, está em transmissão ao vivo. O chat público, com mensagens como \"01\", \"10\", \"<<1\", \"101\", \"100 na verdade\", \"111\", \"110\", sugere uma discussão ou exercício em tempo real envolvendo representações binárias, operações de bitwise (como `<<1` para shift left), ou contagem, temas centrais em arquitetura de computadores para entender aritmética de baixo nível e representação de dados. A página do curso no LMS lista recursos padrão de disciplina como fóruns para avisos e dúvidas, plano de ensino, definição de grupos e trabalho de extensão.\n\nEm resumo, a imagem serve como um registro do ambiente de uma aula online sobre Arquitetura de Computadores, focando na organização do material didático na plataforma e na interação síncrona, mas não apresenta conteúdo direto de diagramas ou código-fonte da disciplina.",
        "transcription": "Volta. Tá bom, vamos ver se é 1, 1.",
        "video_source": "OAC_2022-03-30.mp4"
    },
    {
        "id": 8,
        "timestamp_start": 6245.48,
        "timestamp_end": 6251.0,
        "slide_description": "Atuando como um Engenheiro de Computação Sênior, procedo à análise do slide e conteúdo anotado apresentado.\n\n**Descrição para Sistema de Busca Semântica (RAG):**\n\nO slide principal, que deveria conter o material didático da aula de Arquitetura de Computadores (OAC), encontra-se atualmente em branco ou não visível, apresentando apenas um fundo escuro. Portanto, não há diagramas de datapath, pipeline, hierarquia de memória, ou quaisquer trechos de código (Assembly, C, Verilog) diretamente exibidos na área central da apresentação.\n\nNo entanto, a barra lateral da interface da ConferênciaWeb, intitulada \"Bate-papo público\", contém interações textuais que sugerem o tema e a natureza do conteúdo discutido. A sala de aula é identificada como \"Sala de Aula de OAC\", e a duração da sessão visível é de \"104:16\".\n\nA transcrição do conteúdo textual relevante da sessão de chat, especialmente as mensagens do participante \"Marcello Brandao Sca...\", revela tópicos técnicos primários:\n\n*   **Representação Numérica/Binária:** Várias mensagens indicam a discussão de números em bases que parecem ser binárias ou que exploram conceitos de bits e bytes. Exemplos incluem: \"00\", \"01\", \"10\", \"101\", \"100 na verdade\", \"111\", \"110\". Estes podem estar relacionados a valores de registradores, endereços de memória, operandos de instruções ou resultados de operações lógicas/aritméticas.\n*   **Operações Bitwise/Deslocamento (Shift):** A entrada \"<<1\" é uma representação explícita de uma operação de deslocamento à esquerda (left-shift) de um bit. Esta operação é fundamental em Arquitetura de Computadores para realizar multiplicação por potências de 2, manipulação de bits em campos de instruções, ou ajuste de endereços.\n*   **Valores Imediatos (Immediate Values):** A mensagem \"Imm\" provavelmente se refere a \"valores imediatos\", que são constantes numéricas codificadas diretamente dentro de uma instrução em um Instruction Set Architecture (ISA). Isso é um conceito chave na codificação de instruções e no design de CPUs.\n*   **Tipos de Dados/Representação:** As mensagens \"B\" e \"4\" podem indicar discussões sobre diferentes bases numéricas (e.g., hexadecimal para 'B', ou decimal para '4'), ou o tamanho em bytes/bits de determinados dados.\n*   **Conceitos de Escrita/Dados:** A frase \"a escrita\" pode estar ligada a operações de escrita em memória (Store), registradores, ou mesmo ao processo de codificação/decodificação de instruções.\n\nEm suma, embora o conteúdo visual do slide esteja ausente, o contexto fornecido pelo título da sala (\"Arquitetura de Computadores\") e as interações no chat apontam fortemente para uma aula que aborda fundamentos de representação de dados (binária), operações lógicas/aritméticas de baixo nível (deslocamento de bits), e aspectos do formato de instruções (valores imediatos), todos elementos centrais para a disciplina de Arquitetura de Computadores.",
        "transcription": "Um, zero.",
        "video_source": "OAC_2022-03-30.mp4"
    },
    {
        "id": 9,
        "timestamp_start": 6251.0,
        "timestamp_end": 7400.74,
        "slide_description": "Como Engenheiro de Computação Sênior, procedo com a análise do slide apresentado, extraindo e descrevendo seu conteúdo visual para um sistema de busca semântica, com foco em informação técnica densa.\n\nO slide faz parte de uma aula de \"UnB - CIC0099 - Organização e Arquitetura de Computadores\", ministrada pelo Prof. Marcus Vinicius (nome parcial visível), do Departamento de Ciência da Computação da Universidade de Brasília. O conteúdo principal é uma tabela que detalha sinais de controle para diferentes componentes de uma arquitetura de computador, provavelmente para uma unidade de controle microprogramada ou de controle rígido.\n\nA tabela é estruturada com as seguintes categorias principais de controle, cada uma com seus respectivos sub-sinais e valores binários/mnemônicos:\n\n**1. ALU Ctrl (Controle da Unidade Lógico-Aritmética)**\n   *   Sub-sinais: `ALU 1`, `ALU 0` (dois bits de controle).\n   *   Operações e seus códigos de controle:\n       *   `APD`: `00` (provavelmente uma operação de adição ou similar)\n       *   `SUB`: `01` (subtração)\n       *   `FUCS`: `10` (Função de Comparação/Subtração ou unidade de ponto flutuante, dadas as letras \"FU\")\n\n**2. ORIG 1 (Origem/Operando 1)**\n   *   Sub-sinais: `OR1A 1`, `OR1A 0`, `OR1D 1`, `OR1D 0` (provavelmente seleção da origem A e origem D para o operando 1, cada uma com 2 bits).\n   *   Seleções de origem e seus códigos de controle para `OR1A 1`/`OR1A 0`:\n       *   `R3K`: `00` (referência a um registrador, possivelmente R3 com algum flag 'K')\n       *   `PC`: `10` (Program Counter)\n       *   `A`: `01` (Registro A)\n\n**3. ORIG 2 (Origem/Operando 2)**\n   *   Sub-sinais: `OR2B 1`, `OR2B 0`, `OR2D 1`, `OR2D 0` (provavelmente seleção da origem B e origem D para o operando 2, cada uma com 2 bits).\n   *   Seleções de origem e seus códigos de controle para `OR2B 1`/`OR2B 0`:\n       *   `B`: `00` (Registro B)\n       *   `Y`: `01` (Registro Y)\n       *   `IMM`: `10` (Valor Imediato)\n       *   `IMD`: `11` (Valor Imediato Direto ou Diferente)\n\n**4. BR Ctrl (Controle de Branch/Salto)**\n   *   Sub-sinais: `SSC 1`, `SSC 0`, `DEX 1`, `DEX 0` (quatro bits de controle, possivelmente para Source Select Control e Destination Extend ou Branch Extended).\n   *   Sinais de controle e seus valores binários (notados como 3 bits, sugerindo que `DEX 0` pode ser sempre '0' ou implícito):\n       *   `WRNA`: `100` (Write Register N A, ou sinal de escrita específico)\n       *   `WPCN`: `101` (Write Program Counter N)\n       *   `WMEM`: `110` (Write MEMory)\n       *   `Read`: `000` (Sinal de leitura geral, possivelmente relacionado a dados ou condição)\n\n**5. MEM Ctrl (Controle de Memória)**\n   *   Sub-sinais: `ESU IR`, `Le`, `mg`, `mby`, `Pib` (sinais de controle para acesso à memória, como Enable/Select Unit Instruction Register, Load Enable, Memory Gate, Memory Byte Write Enable, e Program In Buffer).\n   *   Operações de memória e seus códigos de controle (notados como 4 bits):\n       *   `RINST`: `1010` (Read Instruction)\n       *   `RAADO`: `0110` (Read Address Out Data Out, ou Read Address Data Operation)\n       *   `WDADO`: `0101` (Write Data Out Data Out, ou Write Data Address Data Operation)\n\n**6. PC Ctrl (Controle do Program Counter)**\n   *   Sub-sinais: `BSC`, `PCE`, `ORIG`, `PC`, `CIUCIC`, `QC` (sinais de controle para a atualização e manipulação do Program Counter, como Branch Source Control, Program Counter Enable, Origin, PC atual, e outros sinais específicos de condição/controle de fluxo).\n   *   Operações do PC e seus códigos de controle:\n       *   `WPC S4`: `1001` (Write Program Counter com Source 4 ou condição S4)\n       *   `WINCOND`: `A` (Write if IN Condition 'A' is true, ou 'A' como valor/estado de condição)\n       *   `WCOND`: `0` (Write if Condition '0' is true/false, ou '0' como valor/estado de condição)\n\n**7. Seq (Sequenciador)**\n   *   Esta coluna está presente na tabela, mas não possui sub-sinais ou entradas de controle explícitas preenchidas no slide, indicando que a lógica do sequenciador pode ser abordada separadamente ou é implícita nas outras definições de controle.\n\nNão há diagramas explícitos de Datapath, Pipeline ou Hierarquia de Memória. O conteúdo é focado unicamente na especificação de sinais de controle e seus valores binários para micro-operações e seleções de unidades funcionais dentro de uma CPU. O slide serve como uma folha de referência para a implementação do controle de um processador em nível de microcódigo ou hardware. A presença do professor na parte inferior direita da imagem indica que esta é uma gravação ou transmissão de uma aula.",
        "transcription": "Ó, aquilo que vem do banco de registradores, certo? Desculpe, aquilo que vem da memória eu quero escrever no banco de registradores. Então, aciono `escreve reg` e seleciono aqui 1, 0, certo? O que que eu tinha escrito? 0, 1, não. Não, 1, 0. Tá certo? O que mais que eu posso querer fazer com o banco de registradores? Eu já tenho todas as possíveis escritas. Eu posso querer ler do banco de registradores. O que que eu preciso controlar pra ler do banco de registradores? `Write Enable` (WE)? Eu não preciso controlar nada. Então, o código é 0, 0, 0. Eu vou ler no banco de registradores. Certo? Não, eu preciso definir. Eu preciso dar `X` (don't care) aí agora, tá, Marcelo? Eu tenho que definir mesmo. Tá? Então, o nosso `WE` do banco de registradores é esse aqui. Se eu quero escrever no banco de registradores aquilo que eu li da memória, o código seria esse. Se eu escrever no banco de registradores o valor de `PC` mais 4, é esse. Aquilo que eu escrevi o conteúdo da ULA no banco de registradores é esse aqui.\n\nControle da memória. Controle da memória, a gente tem quantos sinais? Já vamos mostrar aqui logo. A gente tem o `Escreve IR`. Já vamos explicar. `Escreve IR`, o `I/D`, e o `ReadMem` e o `WriteMem`. Certo? Então, são esses sinais aqui. `I/D`, `ReadMem`, `WriteMem` que fazem o controle da memória. Mas por que que eu botei aqui o `Escreve IR`? Porque o que que eu vou querer fazer aqui? Quais são as funções que eu posso querer fazer com a memória? Eu posso querer ler a memória. Então, ler uma instrução. `Read instruction`. Então, `Read` uma instrução. Quero ler uma instrução da memória. Então, `I/D`. Bom, `ReadMem` é 1, `WriteMem` é 0. `I/D`? 0 ou 1? Se eu quero ler uma instrução na memória, eu quero, porque eu tenho que botar o `PC` no endereço da memória. E se eu li uma instrução da memória, eu não quero escrever essa instrução no registrador `IR`? O mais significativo é o que tem menos instruções? Ah, não entendi outra coisa. Então, se eu li uma instrução da memória, com certeza eu vou querer escrever essa memória no registrador `IR`. Então, esse é o único caso que eu vou querer escrever no registrador `IR`: é quando eu leio uma instrução da memória.\n\nO que mais que eu posso fazer? `Read` um dado. Certo? Se eu quero ler um dado, eu não vou escrever no `IR`. `I/D` vai ser 1, que agora a saída da ULA é que tem que ir para o endereço. E eu vou querer ler da memória. Ler é 1 e 0. Eu posso querer escrever um dado. `Write` um dado. Então, `Escreve IR` vai ser 0. Porque eu não quero escrever no registrador `IR`. `I/D` vai ser 1, para eu selecionar. Eu estou fazendo tudo de cabeça, porque eu tenho essa coisa na cabeça. Eu deveria estar voltando aqui para vocês. Eu estou falando desse aqui. `I/D` igual a 1, porque agora é esse endereço que eu tenho que endereçar a memória, tanto para a escrita quanto para a leitura. Então, `I/D` igual a 1. E se eu quero `Write`, eu tenho que acionar o `WriteMem`, desculpa. `ReadMem` e `WriteMem`. Então, é isso que eu posso fazer: ler uma instrução, ler um dado ou escrever um dado na memória. Tranquilo? Deixa eu ver se tem mais alguma coisa que eu tenha esquecido. Não. Exato. Ok? Por exemplo, no `Branch Control`, o mais significativo é o `Write Register N A`, porque ele tem 3 funções. Ah! O que isso está fazendo? O mais significativo é que ativa mais funções? Não, não necessariamente. A ordem desses códigos aí é que vai definir a tua linguagem de máquina. A tua micro linguagem de máquina. Se a gente mudar a ordem, a instrução muda, mas ela vai continuar funcionando do mesmo jeito. Ah, eu poderia colocar o `Write Register N A` aqui. Então, começar com `ReadMem`, desculpe. `Mem para Reg1`, `Mem para Reg2` e `Write Register N A` aqui. Poderia, o código aqui iria mudar só. Certo? Mas as operações iriam ser as mesmas. O código em binário quem daria? Se eu mudar a ordem aqui. Certo?\n\nAh, `Controle do PC`. Quer dizer, controle do `PC`. Então, o que nós temos que controlar o `PC`? Só para me lembrar. Então, vamos lá. Quais são os sinais que controlam o `PC`? Então, aqui eu tenho o `Escreve PC`, `Escreve PC Condicional`, `Origem PC`. Certo? Então, eu tenho 3 bits aqui para controlar diretamente o `PC`. E, eu já posso colocar nesse campo também, porque eu só vou querer gravar o `PC_back` quando eu estiver gravando aqui o `PC` mais 4. Então, o meu `PC_back` pode entrar nesse campo também de controle do `PC`. Então, a gente vai ter 4 sinais para o controle do `PC`: `Escreve PC Condicional`, `Escreve PC`, o `Origem PC` e o `PC_back`. Não, é porque a gente só vai acionar o `PC_back` em uma condição, que é aquela quando eu quero escrever o valor de `PC` mais 4. Então, vai lá. O que eu posso querer fazer com o `PC`? Eu posso querer `Write PC` mais 4. O que mais? `Write Incondicional`, `Write Condicional`. Só, né? São só essas 3 coisas que a gente pode querer fazer com o `PC`: `PC` mais 4, `Write Incondicional` e `Write Condicional`.\n\nEntão, quais são os sinais? Vai ser o... `Escreve PC_back`, `PC_back`, o... `Origem PC`, `Escreve PC Condicional`, o índice... o índice... o que é o índice? `Mind`? Quer dizer, ele está ali no `PC`, comprou `WIND`? Ah, tá. `Escreve PC Condicional` e `Escreve PC Incondicional`. Então, são esses 4 aí. Certo? Então, eu posso querer gravar `PC` mais 4 em `PC`, escrever o `PC` condicionalmente, né, que seria o `back`, e escrever o `PC`... Opa, esse aqui. Escreve o `PC` condicionalmente, não é índice, tá? É `incondicionalmente` e `condicionalmente`. Acho que por isso que eu tinha botado `incondicional`. Isso. Tá? Então, vamos lá. `PC` mais 4. Esse aqui é o único caso que eu quero salvar o valor de `PC_back`. Então, o primeiro bit aqui vai ser 1, 0 e 0. Porque o `PC_back` só vai poder ser gravado quando eu for gravar `PC` mais 4 no `PC`. Certo? Aí eu salvo o valor anterior dele no `PC_back`. `Escreve PC` mais 4. Então, quem é a `Origem PC`? Se eu quero gravar `PC` mais 4. É 1? Vou acreditar em... Não, é 0? É 0? `Escreve PC Condicional`. Não. `Escreve PC Incondicional`. Sim. Certo? É 0 ali, né? Que é o... aquele multiplexador de origem da ULA. `Origem PC`. Então, a `Origem PC` 0 ele pega diretamente da saída da ULA. A `Origem PC` 1 ele sai da saída do... do registrador saída da ULA. `Escreve PC Incondicional`. Aqui sim, é 1. `Escreve PC Condicional` 0. `Escreve PC` 1. `Escreve PC Condicional`. Então, é 1. `Escreve PC Condicional` 1. `Escreve PC Incondicional` 0. Certo? Então, tem esses códigos aqui pra essas operações, pra essas funções: `Escreve PC` mais 4, `Escreve PC Incondicional`. Quem tem prova, pode ir, pessoal, tá? Eu vou gravar aqui. Eu já estou vendo que eu vou ter que precisar de um tempinho a mais só pra concluir essa aula. Tá? Então, quem tiver compromisso agora, pode ir. Eu vou fazer só pra deixar a aula gravada. Beleza? Então, no campo controle do `PC`, eu posso ter essas três funcionalidades.\n\nOk. E a sequenciação? Sequenciação é como tu atinge o próximo estado. Né? Então, a gente viu que eu posso ter `Fetch`. Significa... Opa! Aqui é o... `Controle Seq 1` e `Controle Seq 0`. Tá? Esses `Controles Seq` são... Esse aqui, ó. É com controle de endereçamento. Então, é o controle de endereçamento. Aqui a gente tem 0, é o `Fetch`. 1 é o `Space 1` e 2 é o `Space 2` e 3 é o `Next`. Ok? Então, é controle de endereçamento. Então, é controle e aqui. Controle de endereçamento, controle de endereçamento. Então, o `Fetch` seria 00. O `Next` seria 11. A `ROM 1` é 01 e a `ROM 2` é 10. Certo? Então, aqui eu digo como que eu devo atingir o próximo... A próxima microinstrução. Se a próxima instrução volta pro início, se a próxima instrução é a seguinte ou se a `ROM 1` e a `ROM 2` vão dizer qual é a próxima instrução. Certo? Então, controle de endereçamento. Então, essa aqui que a gente acabou de criar agora é a nossa `Micro-ISA`. Porque agora, ao invés de eu precisar colocar esses sinais aqui nas bolinhas, que é o que a gente fez no diagrama de estados, a gente teve que definir todos esses sinais aqui nas bolinhas, eu vou poder escrever na forma de uma instrução. Já que eu tenho aqui as possíveis... as possíveis instruções. Eu posso adicionar o `PC_Back` com o `B`, por exemplo. Posso adicionar o `PC` com 4. Posso adicionar o `A` com o `B`. Eu posso subtrair o `A` do `B`. Posso subtrair o `PC_Back` do imediato. Entendeu? Então, selecionando uma dessas funções pra esse campo, uma dessas funções pra esse, esse pra esse, esses pra esse e assim por diante, eu tenho a minha `Micro-ISA` inteira. Então, quantas instruções é possível gerar aqui? Aí, se você mudar qualquer controle, só dar `Ctrl+F` na sua tabela de instruções... Talvez, eu não entendi direito o que é o `Ctrl+F` que faz. ... Então, vamos lá. ... A minha microinstrução tem 19 bits. 19 bits. Codificaria quantas microinstruções? Com 19 bits, eu consigo codificar quantas microinstruções? ... ... Com 19 bits, que é o que eu tenho aí. 19 bits do tamanho da microinstrução. Seria quantos? Se você mudar seu processador... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... Mas quantas efetivamente a gente tem? Quantas instruções efetivamente a gente tem? Se a gente considerar essas funcionalidades aqui. 24? Não, vai ser... Vou escrever aqui. 3 vezes 3 vezes 4 vezes 4 vezes 3 vezes 3 vezes 4. É, tu somou tudo, né? A gente tem que multiplicar. Porque eu posso `ADD` com esse, `ADD` com esse, `ADD` com esse, `SUB` com esse, `SUB` com esse, `SUB` com esse. `Func` com esse, `Func` com esse, `Func` com esse. Então, isso aqui te dá quanto? Alguém me calcula aí quanto é que é 3 na quarta vezes 4 na terceira. Ou então, 12 ao cubo vezes 9. 5018. Ótimo. Dá isso aí? Beleza. Então, com essas definições que a gente fez, aqui, a gente teria uma `Micro-ISA` com 5184 instruções, certo? Que a gente poderia usar. Bom, que a gente poderia usar. Quais que a gente vai usar? Aquelas que necessitam para funcionar o nosso processador. Então, vamos escrever elas aqui, né? Aqui está só o quadro resumo, tá? Do que tem cada sinal e qual é a funcionalidade. A função de cada um, tá? Exatamente isso que a gente fez. Só que os nomes aqui, eu sempre dou nomes diferentes disso aqui. Nunca consigo dar os mesmos nomes. Embora o `Write 1`, o `Write PC4`, o `WriteMem` tenha sido o mesmo. Esse aqui foram os mesmos, pelo menos. O imediato é `Shift Imediato`, que ele se chama aqui, o imediato é `Shift Imediato`, mas tudo bem.\n\nEntão, aqui estaria o nosso microprograma. Então, o nosso microprograma vai ter 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 linhas. Até agora. Por que 10 linhas? Por que 10 linhas? Porque eu tenho só 10 estados, né? Cada estado é uma microinstrução. Se eu tenho 10 estados, vai ter que dar 10 linhas, né? Então, geralmente a gente coloca isso aqui numa `ROM`, né? Ou numa `Flash`, se vocês quiserem fazer um processamento, quer dizer, um processador, né, que seja atualizável. Então, por exemplo, o endereço 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. Uma `ROM`, tá? O que vai ser a nossa primeira instrução? Vou chamar esse label aqui de `FETCH`. Por quê? Porque é para onde ele tem que pular, se por acaso for um `FETCH`. Então, o que a primeira microinstrução tem que fazer? Tem que somar `PC` mais 4, certo? Ler uma instrução. E gravar no `PC` o valor de `PC` mais 4. Qual é a próxima instrução? A próxima instrução é a seguinte, o `increment`. Então, ele vai para cá. Ok, o que eu tenho que fazer na segunda etapa? Eu vou somar o `PC_back` com o `Shift`, com o imediato deslocado. O banco de registradores eu vou ler. Esses aqui eu não vou fazer nada. Se eu não estou fazendo nada, eu coloco tudo zero. Tá? E qual é o próximo? A `ROM` de despacho 1 é que vai me dizer quem é o próximo. A `ROM` de despacho 1 está aqui. Então, se o `opcode` da instrução for esse, tem que ir para esse endereço. Se for esse, tem que ir para esse endereço. Esse para esse endereço e assim por diante. Por acaso, os endereços aqui eu coloquei exatamente igual aos estados. Então, esse aqui é o estado 0, estado 1, estado 2, estado 3, 4 e assim por diante. Está o estado 9. Ok? Então, esse aqui é o estado 1. Esse aqui é a `ROM` de despacho 1, é que vai me dizer. Beleza. Então, a `ROM` de despacho 1, ele vai aqui.",
        "video_source": "OAC_2022-03-30.mp4"
    },
    {
        "id": 10,
        "timestamp_start": 7405.78,
        "timestamp_end": 7952.37,
        "slide_description": "O slide, intitulado \"Microprograma para a Unidade de Controle RISC-V\", detalha a implementação de uma unidade de controle microprogramada para um processador RISC-V. O conteúdo é dominado por três tabelas e uma observação.\n\n**1. Tabela Principal: Definição do Microprograma**\nEsta tabela descreve as microinstruções que compõem o microprograma. Cada linha representa uma microinstrução, com colunas que especificam os sinais de controle e o fluxo de execução:\n\n*   **Label:** Um rótulo mnemônico para a microinstrução (ex: Fetch, Mem1, R-Type1).\n*   **Ctrl ULA:** Sinais de controle para a Unidade Lógica e Aritmética (ULA). Exemplos incluem `Add`, `Sub` e `Funct` (indicando que a função da ULA é determinada pelo campo `funct` da instrução).\n*   **Orig1, Orig2:** Fontes dos operandos para a ULA. Podem ser o `PC` (Program Counter), um valor imediato (`4`), registradores (`A`, `B`), um valor de retorno do PC (`PCBack`), ou um imediato deslocado (`ShiftImm`).\n*   **Ctrl BR:** Sinais de controle para a unidade de desvio (Branch). `WriteALU` pode indicar que o resultado da ULA será usado para uma condição de desvio ou escrito em algum lugar.\n*   **Mem:** Sinais de controle para operações de memória. `ReadInstr` para buscar a instrução, `ReadData` para ler dados da memória, e `WriteMem` para escrever dados na memória.\n*   **Ctrl PC:** Sinais de controle para a atualização do Program Counter. `PC+4` para avanço sequencial, `BranchAddress` para o endereço de um desvio condicional, e `JumpAddress` para o endereço de um salto incondicional.\n*   **Seq:** Lógica de sequência para determinar a próxima microinstrução. `Incr` (incrementa o contador de microprograma), `Disp1` e `Disp2` (despacho, ou seja, desvio para um endereço baseado em campos da instrução), e `Fetch` (salta para o início da rotina de Fetch).\n*   **Endereço:** O endereço hexadecimal da microinstrução na memória de microprograma.\n*   **microcódigo:** A representação binária dos sinais de controle para a microinstrução. Apenas o microcódigo para `Fetch` (`0x00`) é mostrado: `0000101000101011`.\n\n**Detalhes das Microinstruções Chave:**\n\n*   **Fetch (0x00):** Realiza a busca da instrução. A ULA calcula `PC + 4`, a memória lê uma instrução (`ReadInstr`), e o PC é atualizado para `PC+4`. A próxima microinstrução é `Mem1` (`Seq: Incr`).\n*   **Mem1 (0x01):** Prepara para acesso à memória. A ULA calcula `A + Imm` (provavelmente endereço base + deslocamento). A próxima etapa é um despacho (`Disp1`), que usará o opcode da instrução para determinar a rotina específica (ex: Load, Store, Branch, Jump, R-Type).\n*   **Lw2 (0x02):** Uma etapa intermediária para operações de memória (inferido como Load Word step 2). O sequenciamento é `Disp2`, indicando um despacho adicional, provavelmente para diferenciar Load de Store.\n*   **ReadData (0x03):** Realiza a leitura de dados da memória (`Mem: ReadData`). Próxima microinstrução é `Incr`.\n*   **Sw2 (0x04):** Etapa para Store Word (inferido). Não há operações explícitas aqui, mas o sequenciamento é `Fetch`, indicando o fim da micro-rotina e retorno para o ciclo de busca.\n*   **R-Type1 (0x05):** Primeira etapa para instruções do tipo R (aritméticas/lógicas de registro para registro). A ULA executa a função (`Funct`) com operandos `A` e `B`. O sequenciamento é `Fetch`.\n*   **Beq1 (0x07):** Primeira etapa para instruções de desvio condicional (Branch Equal). A ULA calcula `A - B` (para comparação de igualdade, resultado zero significa igual). `Ctrl BR` ativa `WriteALU`. `Ctrl PC` é definido como `BranchAddress`. O sequenciamento é `Fetch`.\n*   **Jal1 (0x08):** Primeira etapa para instrução de salto e link (Jump and Link). `Ctrl PC` é definido como `JumpAddress`. O sequenciamento é `Fetch`.\n\n**2. Tabelas de ROM de Despacho (Dispatch ROMs)**\nEstas tabelas implementam a lógica de despacho, mapeando partes do código da instrução para endereços de microprograma:\n\n*   **ROM de despacho 1:**\n    *   Mapeia o opcode da instrução (o `Endereço` binário) para um `Conteúdo` (o endereço inicial da rotina de microprograma correspondente).\n    *   Exemplos: `1101111` (opcode JAL) -> `1001` (microendereço 0x09, correspondente a `Jal1`); `1100011` (opcode Branch) -> `1000` (microendereço 0x08, correspondente a `Beq1`); `0000011` (opcode Load) e `0100011` (opcode Store) -> `0010` (microendereço 0x02, correspondente à etapa genérica de acesso à memória `Lw2`). Esta ROM é utilizada pelo `Seq: Disp1` da microinstrução `Mem1`.\n\n*   **ROM de despacho 2:**\n    *   Mapeia outro campo da instrução (provavelmente `funct3` para operações de memória) para endereços de microprograma mais específicos.\n    *   Exemplos: `0000011` (provavelmente `funct3` para Load) -> `0011` (microendereço 0x03, correspondente à etapa `ReadData`); `0100011` (provavelmente `funct3` para Store) -> `0101` (microendereço 0x05, correspondente à etapa `Sw2`). Esta ROM é utilizada pelo `Seq: Disp2` da microinstrução genérica de memória (no endereço 0x02).\n\n**3. Observação Adicional:**\n\"Obs.: O microcódigo depende da posição dos sinais nos campos!\"\nEsta nota salienta que a representação binária do microcódigo (os bits) é sensível à alocação e ordem dos campos de controle (Ctrl ULA, Orig1, etc.) dentro da palavra de microinstrução, o que é crucial no projeto de unidades de controle microprogramadas.\n\nO slide demonstra um projeto detalhado de microcódigo e suas tabelas de despacho para controlar as operações de um processador RISC-V, cobrindo o ciclo de instrução (Fetch) e exemplos de execução para diferentes tipos de instruções (Load, Store, R-Type, Branch, Jump).",
        "transcription": "Então, vamos lá. Vamos dar labels a esses aqui. Então, o endereço `0x03` tem qual label? Load2, né? É o label que eu estou usando aqui. Load2. Load2. O `0x05`, que é o 5, é o R-Type1. O `0x06`, que é o 6, é o tipo R. `0x09` é o JA1. Nossa, o JA só tem 1. `0x08` é o BEC. Ah, lembrei. Esse 1 aqui é porque está dizendo que é a ROM de despacho 1. Só para identificar que esses labels estão nessa. Essa ROM de despacho 1 aqui. Certo? E LoadStore2 é porque está na ROM de despacho 2. Tá? Então, isso que significa esses aqui. Então, esses meus labels aqui são relacionados com os endereços, né? Dessa maneira. Minha tabela de labels. Digamos assim. Tá? Tabela de labels. Tranquilo? Vocês lembram que o microassembler também gera uma tabela de labels, né? Então, agora, vamos continuar. Beleza. Então, a ROM de despacho 1 vai me dizer. E a ROM de despacho 1 vai mandar ou para a memória, ou para BEC, ou para JA1, ou para tipo R. Então, vamos começar pela memória. Então, memória. O que que eu... Quando for coisa de memória, eu vou precisar calcular o endereço. Então, ADD A com o imediato. Calculei o endereço. Nos outros, não precisa nada. Zero. O que que eu vou fazer agora? Agora, eu vou ter que definir. A ROM de despacho 2. A ROM de despacho 2 vai me dizer para qual que eu vou. Se é um Load ou se é um Store. Tá? Vamos supor que seja um Store. Então, se for um Store, ele vai vir para cá. O que que ele vai fazer? Vai escrever na memória o dado. E Fetch. Acabou. Próximo, ele volta para o início do programa novamente. Aqui. Então, vai para o label Fetch. Que é esse aqui. É 0x00. Ok. E aí, se a ROM de despacho 2 mandou para o Load. Vai vir para cá. A ROM de despacho 2 mandou para o Load. O Load é o `0x03`. Então, ele vai vir para cá. O que que ele vai fazer nessa microinstrução? Ele vai ler o dado da memória. E depois, a próxima instrução é a seguinte. O que que ele vai fazer nessa próxima microinstrução? Ele vai escrever o dado da memória no banco de registradores. E volta para o início. Certo? Vocês conseguem visualizar que aqui está o diagrama de estados? Isso aqui é o diagrama de estados tal e qual. Só que agora está escrito na forma de um programa. Então, fica fácil de eu fazer manutenção nisso aqui. Ok. Vamos fazer um tipo R. Tipo R. Então, a ROM de despacho 1 mandou. Viu que o opcode era de um tipo R. Que é esse aqui. Então, vai mandar para cá. O tipo R. O que que ele vai fazer? Ele vai... O campo Funct vai dizer o que tem que fazer com A e com B. E vai incrementar. Vai incrementar. O que que a próxima microinstrução tem que fazer? Tem que escrever o resultado da ULA no banco de registradores. Próxima instrução. Fetch. Volta para o início. Se for um BEC. Se for um BEC, ele vai vir para cá. O que que essa microinstrução manda fazer? Manda subtrair A de B. E no controle do PC é o PC condicional. Que aqui ele está chamando de ingresso de... Branch Address. A gente chamou aqui de Escrever condicionalmente ao PC. Se for um JAL e depois Fetch. Volta para o início. Se for um JAL, simplesmente escreve incondicionalmente. Que foi o nome que a gente deu aqui. Escreve incondicionalmente. Escreveu, volta para o início. Entenderam isso aqui, pessoal? É nada mais é do que uma máquina de estados. Isso aqui é uma outra representação do diagrama de estados. Que me permite eu escrever outras funções de maneira fácil. Então eu posso fazer aqui um A. Vamos voltar aqui. Quer dizer, eu posso fazer qualquer combinação desses campos. Claro que vários deles não vai ter sentido. Pode não ter sentido. Do tipo... Escreve PC + 4. No banco de registradores. E pula incondicionalmente. Faz um salto incondicional. Quer dizer... Não. Obviamente isso aí funciona. Mas faz um salto condicional, por exemplo. Porque escrever PC + 4 é o JAL. Não. É o JAL que escreve PC + 4 no banco de registradores. Adianta ele fazer um salto condicional depois? Ou adianta ele ir para a próxima instrução? Certo? Quer dizer, pode ter instruções aqui que não façam sentido. Dessas 5.200 ela vai quebrar. Um contador de JAL? Provável. Tá? Mas tem que ver onde que tu vai armazenar esse contador. Porque quando tu fala no contador, tu tá considerando um registrador. Qual registrador vai conter isso aí? Tá. Tu vai usar um dos registradores... Não. Não tem como. Tá? Esse microprograma, o objetivo dele é... Dada uma instrução, ele vai executar esse microprograma para executar aquela instrução. Daí passa para a próxima instrução. Executa o microprograma para a próxima instrução. Executa o microprograma para a próxima instrução. Não dá para fazer muito processamento aqui dentro. Tá? Uma vez que isso aí é uma forma de tu executar uma instrução. Entendido? Certo? Então, daria para fazer outras instruções? Fazer outras coisas? Daria. Tá? Mas no nosso caso, esse aqui é o microprograma que corresponde àquele diagrama de estados. Dá para fazer bastante coisa. Tá? Então, é isso aqui que a Intel usa para fazer o controle dos processadores dela. Tá? Então, isso aqui é escrito em Verilog, obviamente. Melhor, escrito em Verilog, não. Significa, tu tens esse microprograma. Certo? Cada microinstrução dessa aqui vai ter que ser montada para um microcódigo. Esse aqui. Certo? Então, essa instrução possui esse microcódigo. Essa outra instrução vai ter outro microcódigo. Outro, outro, outro. Certo? E essa aqui é a linguagem de máquina. A microlinguagem de máquina. Certo? Vai definir então a instrução. O que o processador tem que fazer naquela hora. Então, uma microlinguagem de máquina. Sim, deixa. Porque não é complicado. Tá? Não é complicado fazer isso aqui. Tá? Mas as equipes que fizeram, sempre fizeram pelo diagrama de estados. No Quartus. Mas daria para implementar isso aqui sim. Descreveria isso aqui na ROM. Tá? Você vai ter dois endereços com esses microcódigos. Certo? Ok. Então, desse modo, a Intel consegue visualizar o programa de controle. Daí cada um pode mexer no seu pedacinho do programa. Na máquina de estados do processador. Então, o microcódigo depende da posição dos sinais nos campos. Ó. Ah, vamos fazer um exercíciozinho só para completar esse...",
        "video_source": "OAC_2022-03-30.mp4"
    },
    {
        "id": 11,
        "timestamp_start": 7952.37,
        "timestamp_end": 7987.24,
        "slide_description": "Como Engenheiro de Computação Sênior, analiso o slide apresentado no contexto de uma aula de Arquitetura de Computadores. O conteúdo é focado na avaliação de desempenho de um processador RISC-V multiciclo, especificamente no cálculo do CPI (Cycles Per Instruction) médio, e inclui discussões técnicas em um chat lateral que complementam o tópico.\n\n**Conteúdo do Slide:**\n\nO slide é intitulado \"Exercício\" e faz parte de uma aula da disciplina \"UnB – CIC0099 – Organização e Arquitetura de Computadores\", ministrada pelo Prof. Marcus Vinícius Lamar, do Departamento de Ciência da Computação da Universidade de Brasília.\n\nO exercício propõe a seguinte questão:\n\"Considerando o workload do compilador gcc, qual a CPI média do RISC-V multiciclo implementado?\"\n\nPara resolver a questão, são fornecidos os seguintes dados de workload e ciclos por tipo de instrução para um processador RISC-V multiciclo:\n\n*   **Load**: 22% do workload, requerendo 5 ciclos por instrução.\n*   **Store**: 11% do workload, requerendo 4 ciclos por instrução.\n*   **Operações lógico-aritméticas**: 49% do workload, requerendo 4 ciclos por instrução.\n*   **Desvios Condicionais**: 16% do workload, requerendo 3 ciclos por instrução.\n*   **Desvios Incondicionais**: 2% do workload, requerendo 3 ciclos por instrução.\n\nAbaixo da descrição do problema, é apresentada a fórmula e o resultado do cálculo do CPI médio, que é uma média ponderada dos ciclos de cada tipo de instrução pela sua frequência no workload:\n\n`CPI = 0.22 × 5 + 0.11 × 4 + 0.49 × 4 + 0.16 × 3 + 0.02 × 3 = 4.04`\n\nEste cálculo demonstra a aplicação direta da métrica de desempenho de CPI, fundamental para avaliar a eficiência de uma arquitetura de processador. A escolha de um RISC-V multiciclo implica que diferentes estágios do pipeline ou diferentes operações podem levar um número variável de ciclos, justificando a média ponderada.\n\n**Conteúdo Anotado (Chat Lateral):**\n\nNo painel lateral, observa-se uma discussão em tempo real entre o professor e os alunos, destacando os seguintes pontos técnicos relevantes:\n\n*   **Identificação de Instruções**: Um aluno (Marcello Brandao Sca...) menciona \"Lw2\" e \"Sw2\", que podem ser referências a variantes das instruções `lw` (load word) e `sw` (store word) ou erros de digitação, possivelmente em discussão sobre implementações específicas ou microcódigo.\n*   **Microcódigo**: O aluno comenta \"o microcódigo é a sequencia daquela tabela anterior\", indicando que a aula anterior ou um material de referência tratou da implementação de instruções via microcódigo, um conceito chave em arquiteturas multiciclo para controlar a sequência de operações elementares.\n*   **Instrução JAL (Jump and Link)**: Há uma série de perguntas e respostas sobre o uso da instrução `jal` (Jump and Link), que é usada para chamadas de subrotina em RISC-V (e MIPS, por exemplo).\n    *   \"Se eu quisesse um jal com contador de jal dava para fazer\": Isso sugere uma discussão sobre a possibilidade de adicionar um contador para chamadas de `jal`, talvez para monitoramento ou otimização.\n    *   \"seria mem1 com jal\": Reforça a discussão sobre a interação de `jal` com operações de memória ou um ponto específico do projeto (`mem1`).\n    *   \"o quartus deixa fazer isso?\": Questionamento sobre a viabilidade de implementar tais funcionalidades usando a ferramenta Quartus (software da Intel FPGA para desenvolvimento com FPGAs), o que indica que a aula pode ter um componente prático de projeto de hardware ou simulação.\n\nEm suma, o slide apresenta um problema prático de cálculo de CPI para um processador RISC-V multiciclo, enquanto o chat lateral revela discussões sobre detalhes de implementação de instruções (como `jal`), o papel do microcódigo e a aplicabilidade de ferramentas de design de hardware como o Quartus, fornecendo um contexto rico para busca semântica em Arquitetura de Computadores.",
        "transcription": "O multiciclo. Ah, tudo bem. Esse aqui a gente já fez um exercício desses. Não faz muito sentido a gente fazer outro. Ah, a gente já fez isso. Já fizemos um exercício desses que a gente analisou. A gente analisou aqui. A gente fez, não fez? Load, 22% x 5; Store, 11% x 4; Operações lógico-aritméticas, 49% x 4; Desvios Condicionais, 16% x 3; Desvios Incondicionais, 2% x 3. É, foi na aula passada do multiciclo que a gente fez isso aqui. A gente fez essa análise. Então, isso aqui ficou ótimo.",
        "video_source": "OAC_2022-03-30.mp4"
    },
    {
        "id": 12,
        "timestamp_start": 7987.24,
        "timestamp_end": 7992.24,
        "slide_description": "Como Engenheiro de Computação Sênior, analisei o slide de Arquitetura de Computadores e extraio o seguinte conteúdo técnico para um sistema de busca semântica (RAG):\n\nO slide apresenta o conceito de **Microprograma para a Unidade de Controle RISC-V**, detalhando uma implementação de controle microprogramado para um processador RISC-V. No canto superior direito, identifica-se a afiliação acadêmica: \"UnB – CIC0099 – Organização e Arquitetura de Computadores\", \"Universidade de Brasília\", \"Departamento de Ciência da Computação\", e o professor \"Marcus Vinicius Lamar\".\n\n**Tabela Principal: Microprograma**\nA parte central do slide exibe uma tabela que descreve as microinstruções que compõem o microprograma. Cada linha representa um estado ou passo na execução de uma instrução. As colunas são:\n*   **Label**: Um rótulo simbólico para a microinstrução (e.g., `Fetch`, `Mem1`, `Lw2`, `Sw2`, `R-Type1`, `Beq1`, `Jal1`).\n*   **Ctrl ULA**: Controle da Unidade Lógica e Aritmética, especificando a operação (e.g., `Add`, `Funct` para funções derivadas do código, `Sub`).\n*   **Orig1 / Orig2**: Origem dos operandos para a ULA (e.g., `PC`, `4`, `A`, `Imm`, `PCBack`, `ShiftImm`, `B`).\n*   **Ctrl BR**: Controle de Branch. Contém `WriteALU` para operações que escrevem na ULA, e `Read` no contexto de `ReadInstr`.\n*   **Mem**: Controle de memória (e.g., `ReadInstr` para leitura de instrução, `ReadData` para leitura de dados, `WriteMem` para escrita em memória, `WriteData` para dados a serem escritos).\n*   **Ctrl PC**: Controle do Program Counter (PC), definindo como o PC é atualizado (e.g., `PC+4` para avanço sequencial, `BranchAddress` para endereço de desvio condicional, `JumpAddress` para endereço de salto incondicional).\n*   **Seq**: Sequenciamento, indicando a próxima microinstrução (e.g., `Incr` para incremento do endereço de microcódigo, `Disp1`, `Disp2` para despacho, `Fetch` para retornar ao ciclo de busca de instrução).\n*   **Endereço**: Endereço hexadecimal da microinstrução na memória de controle (e.g., `0x00` a `0x09`).\n*   **microcódigo**: Representação binária da microinstrução. Apenas a microinstrução de `Fetch` é codificada como `0000101000101011`.\n\nExemplos de linhas de microcódigo transcritas:\n*   `Fetch`: `Add`, `PC`, `4`, (vazio), `ReadInstr`, `PC+4`, `Incr`, `0x00`, `0000101000101011`\n*   `Mem1`: `Add`, `A`, `Imm`, (vazio), (vazio), (vazio), `Disp1`, `0x01`, (vazio)\n*   Linha de `Lw2` (manual): (vazio), (vazio), (vazio), (vazio), `ReadData`, (vazio), `Disp2`, `0x02`, (vazio)\n*   Linha subsequente a `Lw2`: (vazio), (vazio), (vazio), `WriteMem`, (vazio), (vazio), `Incr`, `0x03`, (vazio)\n*   `Sw2`: (vazio), (vazio), (vazio), `WriteData`, (vazio), (vazio), `Fetch`, `0x04`, (vazio)\n*   `R-Type1`: `Funct`, `A`, `B`, `WriteALU`, (vazio), (vazio), `Fetch`, `0x05`, (vazio)\n*   `Beq1`: `Sub`, `A`, `B`, (vazio), `BranchAddress`, `Fetch`, `0x08`, (vazio)\n*   `Jal1`: (vazio), (vazio), (vazio), (vazio), `JumpAddress`, `Fetch`, `0x09`, (vazio)\n\n**Tabelas de ROM de Despacho**\nNa parte inferior do slide, são mostradas duas tabelas intituladas \"ROM de despacho 1\" e \"ROM de despacho 2\", que servem para mapear códigos de instrução (ou partes deles) para endereços de microcódigo. Isso é crucial para o sequenciador de microcódigo determinar o ponto de entrada correto no microprograma para cada instrução.\n*   **ROM de despacho 1**:\n    *   Endereço: `0110011`, Conteúdo: `0110` (associado a `Lw2` por anotação manual)\n    *   Endereço: `1101111`, Conteúdo: `1001` (associado a `Sw2` por anotação manual)\n    *   Endereço: `1100011`, Conteúdo: `1000` (associado a `Beq1` por anotação manual)\n    *   Endereço: `0000011`, Conteúdo: `0010` (associado a `Mem1` por anotação manual)\n    *   Endereço: `0100011`, Conteúdo: `0010` (associado a `Jal1` por anotação manual)\n*   **ROM de despacho 2**:\n    *   Endereço: `0000011`, Conteúdo: `0011` (associado a `Lw2` por anotação manual)\n    *   Endereço: `0100011`, Conteúdo: `0101` (associado a `Sw2` por anotação manual)\n\n**Observação Adicional:**\nA anotação \"Obs.: O microcódigo depende da posição dos sinais nos campos!\" reforça que a geração do microcódigo binário e o despacho de instruções são sensíveis à posição e interpretação dos bits dentro do formato da instrução, um conceito fundamental em arquiteturas microprogramadas.\n\n**Discussões Relacionadas (do chat):**\nAs mensagens do chat indicam discussões complementares sobre a implementação e performance de controle microprogramado:\n*   \"o microcódigo é a sequencia daquela tabela anterior\": Confirma a interpretação da tabela principal.\n*   \"Se eu quisesse um jal com contador de jal dava para fazer\", \"sim\", \"seria mem1 com jal\": Debate a flexibilidade do microcódigo para implementar instruções complexas como `jal` (jump and link) e a possibilidade de reuso de microinstruções (e.g., `mem1`).\n*   \"o quartus deixa fazer isso?\": Questiona sobre a viabilidade de implementar tal lógica em ferramentas de síntese de hardware (como o Quartus da Intel/Altera).\n*   \"foi o multicilco tbm\", \"aí dava 1.21x mais rápido\": Referência à natureza multiciclo do controle microprogramado e uma análise de desempenho comparativa, indicando potenciais ganhos de velocidade dependendo da implementação.\n\nEste slide detalha a estrutura de um controlador microprogramado para RISC-V, mostrando como instruções são decompostas em sequências de microinstruções e como ROMs de despacho são usadas para decodificação e sequenciamento.",
        "transcription": "Ficou ótimo. Encerramos por aqui. Ok, pessoal. Então, encerramos por aqui.",
        "video_source": "OAC_2022-03-30.mp4"
    },
    {
        "id": 13,
        "timestamp_start": 7992.24,
        "timestamp_end": 7995.24,
        "slide_description": "Como Engenheiro de Computação Sênior, analisei o conteúdo visual fornecido. O slide principal está na tela preta, indicando o fim da apresentação, mas o contexto da aula de Arquitetura de Computadores é fortemente inferível através dos elementos auxiliares e da transcrição do bate-papo.\n\n**Conteúdo Visual para Sistema de Busca Semântica (RAG):**\n\n1.  **Título e Contexto da Aula:**\n    *   O nome da sala da conferência é \"Sala de Aula de OAC\", sugerindo \"Organização e Arquitetura de Computadores\".\n    *   A tela da apresentação exibe, no canto inferior direito, o logo da \"Universidade de Brasília\" e \"Departamento de Ciência da Computação\". Abaixo, especifica a disciplina como \"CBC0346: Organização e Arquitetura de Computadores\" e o professor como \"Prof. Marcus Vinicius Lamar\".\n    *   No canto superior direito da tela de slides, há a mensagem \"Fim da apresentação de slides. Clique para sair.\"\n\n2.  **Discussão Técnica Relevante (Bate-papo Público):**\n    O bate-papo contém uma sequência de mensagens do usuário \"Marcello Brandao Sca...\" que discute conceitos avançados de arquitetura, possivelmente relacionados a microprogramação, conjuntos de instruções e desempenho. As mensagens foram timestampadas entre 16:04 e 16:13 e podem ser transcritas como:\n    *   \"ok\" (16:04)\n    *   \"o microcódigo é a sequencia daquela tabela anterior\" (16:06)\n    *   \"Se eu quisesse um jal com contador de jal dava para fazer\" (16:09)\n    *   \"sim\" (16:10)\n    *   \"seria mem1 com jal\" (16:10)\n    *   \"o quartus deixa fazer isso?\" (16:11)\n    *   \"certo\" (16:12)\n    *   \"foi o multicilco tbm\" (16:13)\n    *   \"aí dava 1.21x mais rápido\" (16:13)\n\n    Esta discussão abrange tópicos como:\n    *   **Microcódigo:** A menção de \"microcódigo\" como \"sequência daquela tabela anterior\" indica um tópico sobre controle microprogramado de unidades de processamento, onde operações complexas são decompostas em sequências de micro-operações.\n    *   **Instrução `JAL` (Jump And Link):** A discussão sobre \"jal com contador de jal\" e \"mem1 com jal\" sugere a exploração da funcionalidade e implementação de instruções de salto com salvamento de endereço de retorno, comum em arquiteturas RISC (como MIPS) para chamadas de subrotinas. A pergunta se o \"Quartus deixa fazer isso\" implica uma discussão sobre implementação em hardware (FPGA, por exemplo) usando ferramentas de design eletrônico.\n    *   **Multiciclo:** A frase \"foi o multicilco tbm\" provavelmente se refere a uma arquitetura de processador de múltiplos ciclos, em contraste com pipelined ou single-cycle, onde uma instrução pode levar múltiplos ciclos de clock para ser concluída.\n    *   **Desempenho:** A observação \"aí dava 1.21x mais rápido\" é uma métrica de desempenho, comparando a velocidade de execução de alguma implementação ou abordagem arquitetônica com outra, um tema central em otimização de processadores.\n\n3.  **Diagramas/Estruturas Visuais:**\n    Não há diagramas de datapath, pipeline ou hierarquia de memória visíveis neste slide específico, pois a tela está predominantemente preta, indicando o encerramento da apresentação. O conteúdo técnico é derivado principalmente do bate-papo.\n\n**Sumário para RAG:**\nEste slide, embora visualmente vazio no conteúdo principal, é contextualizado como parte da disciplina \"Organização e Arquitetura de Computadores\" (CBC0346) da Universidade de Brasília, lecionada pelo Prof. Marcus Vinicius Lamar. O bate-papo associado revela uma discussão técnica focada em microprogramação, a implementação da instrução `JAL` (Jump And Link) em hardware (mencionando a ferramenta Quartus), arquiteturas multiciclo e métricas de desempenho comparativas, como uma melhoria de velocidade de 1.21x. Estes termos são cruciais para a compreensão do controle de unidade central de processamento (CPU) e da performance de processadores.",
        "transcription": "Isso, dava 1.21x mais rápido para aquele workload.",
        "video_source": "OAC_2022-03-30.mp4"
    },
    {
        "id": 14,
        "timestamp_start": 7995.24,
        "timestamp_end": 8010.24,
        "slide_description": "Como Engenheiro de Computação Sênior, procedo com a análise do slide e do conteúdo anotado, extraindo as informações para um sistema de busca semântica (RAG):\n\n**Conteúdo do Slide Principal (Material Didático):**\n\nO slide é intitulado \"Exercício\" e faz parte da disciplina \"UnB – CIC0099 – Organização e Arquitetura de Computadores\", ministrada pelo \"Prof. Marcus Vinícius Lamar\" do \"Departamento de Ciência da Computação\" da \"Universidade de Brasília\".\n\nO problema apresentado é: \"Considerando o workload do compilador gcc, qual a CPI média do RISC-V multiciclo implementado?\". Esta questão visa calcular o Cycles Per Instruction (CPI) médio para um processador RISC-V com uma arquitetura multiciclo, dada uma distribuição específica de tipos de instruções (instruction mix) e seus respectivos custos em ciclos.\n\nOs dados fornecidos para o cálculo são:\n*   **Load:** 22% da frequência de instruções, com um custo de 5 ciclos por instrução.\n*   **Store:** 11% da frequência de instruções, com um custo de 4 ciclos por instrução.\n*   **Operações logico-aritméticas:** 49% da frequência de instruções, com um custo de 4 ciclos por instrução.\n*   **Desvios Condicionais:** 16% da frequência de instruções, com um custo de 3 ciclos por instrução.\n*   **Desvios Incondicionais:** 2% da frequência de instruções, com um custo de 3 ciclos por instrução.\n\nA resolução do exercício é apresentada como a soma ponderada do custo de ciclos de cada tipo de instrução pela sua frequência:\n**CPI = 0.22 × 5 + 0.11 × 4 + 0.49 × 4 + 0.16 × 3 + 0.02 × 3 = 4.04**\n\nNão há diagramas de datapath, pipeline ou hierarquia de memória visíveis neste slide. O conteúdo é puramente textual e matemático, focando em métricas de desempenho arquitetural.\n\n**Conteúdo Anotado (Bate-papo / Discussão Paralela):**\n\nA coluna de bate-papo, com interações principalmente de \"Marcello Brandao Sca...\" e menção de \"Marcus Vinicius Lam...\" (o professor), revela discussões técnicas complementares:\n\n*   **Microcódigo:** Uma mensagem de 16:06 (\"o microcódigo é a sequencia daquela tabela anterior\") indica que o tópico de microprogramação e sequências de controle para unidades de controle foi abordado em slides ou aulas anteriores, conectando-se à implementação de processadores multiciclo.\n*   **Instrução `jal` e Contadores:** Às 16:09, há uma indagação sobre a possibilidade de implementar uma instrução `jal` (Jump And Link) com um \"contador de jal\", que poderia ser uma questão sobre o gerenciamento de chamadas de sub-rotinas aninhadas ou um mecanismo para limitar profundidade de chamadas. A sugestão posterior (\"seria mem1 com jal\" às 16:10) parece se referir a uma etapa específica do pipeline (e.g., fase de acesso à memória) onde a instrução `jal` poderia ser combinada para tal funcionalidade.\n*   **Ferramentas de Design (FPGA):** A pergunta \"o quartus deixa fazer isso?\" (16:11) demonstra interesse na viabilidade prática de implementar tais arquiteturas ou características de instruções em plataformas de hardware reconfigurável, como FPGAs, utilizando ferramentas como o Altera Quartus.\n*   **Performance Multiciclo:** Por fim, Marcello Brandao Sca... comenta às 16:13 \"foi o multiciclo tbm\" e \"aí dava 1.21x mais rápido\", sugerindo uma discussão prévia sobre otimizações ou comparações de desempenho onde uma implementação multiciclo (ou uma variação dela) resultou em um speedup de 1.21 vezes em relação a alguma outra configuração ou baseline. Isso reforça o contexto de análise de desempenho de arquiteturas multiciclo.\n\nEm resumo, o slide foca no cálculo prático do CPI para uma arquitetura RISC-V multiciclo sob um workload específico, enquanto as anotações do bate-papo enriquecem o contexto com discussões sobre microcódigo, controle de fluxo complexo (JAL), implementação em hardware (Quartus) e análise de performance (speedup em multiciclo).",
        "transcription": "Para esse workload aqui, vai ter que ter 5 dividido por 4.04 dá quanto? Né? Ok. Então, encerramos por aqui. Vou parar a gravação. Agradeço a audiência de todos.",
        "video_source": "OAC_2022-03-30.mp4"
    },
    {
        "id": 15,
        "timestamp_start": 8010.24,
        "timestamp_end": 8013.24,
        "slide_description": "Como Engenheiro de Computação Sênior, procedo à análise do slide e conteúdo anotado da aula de Arquitetura de Computadores para extração de informação relevante para um sistema de busca semântica (RAG).\n\n**Conteúdo Principal do Slide (Painel Central):**\n\nO slide apresenta um problema ou exercício da disciplina \"UnB – CIC0009 – Organização e Arquitetura de Computadores\", da Universidade de Brasília. O título visível do slide é \"Exercício\".\n\nA questão em pauta, parcialmente visível, inicia-se com: \"■ Considerando o workload do compilador gcc, qual a CPI\". O restante da formulação da pergunta está cortado, mas o contexto indica que se trata de um cálculo do CPI (Cycles Per Instruction), uma métrica fundamental em arquitetura de computadores para avaliar o desempenho de um processador.\n\nA resolução ou parte dela é apresentada na forma de uma equação de cálculo do CPI:\n`CPI = 0.22 × 5 + 0.11 × 4 + 0.49 × 4 + 0.16 × 3 + 0.02 × 3 = 4.04`\nEsta equação sugere que diferentes classes de instruções têm diferentes frequências (os coeficientes 0.22, 0.11, 0.49, 0.16, 0.02) e diferentes latências ou custos em ciclos (os multiplicadores 5, 4, 4, 3, 3). A soma ponderada desses custos resulta no CPI médio de 4.04 para o workload do compilador GCC.\n\nNão há diagramas explícitos de Datapath, Pipeline ou Hierarquia de Memória visíveis neste segmento do slide.\n\n**Conteúdo do Bate-papo Público (Painel Lateral Esquerdo):**\n\nO bate-papo contém uma discussão técnica entre os participantes, majoritariamente por \"Marcello Brandao Sca...\":\n\n*   16:06: \"o microcódigo é a sequencia daquela tabela anterior\" - Sugere uma discussão prévia sobre microcódigo, que é uma camada de software de baixo nível para implementar o conjunto de instruções de um processador.\n*   16:09: \"Se eu quisesse um jal com contador de jal dava para fazer\" - Aborda a instrução JAL (Jump And Link), comum em arquiteturas RISC como MIPS, e a possibilidade de estender sua funcionalidade com um contador.\n*   16:10: \"sim\"\n*   16:10: \"seria mem1 com jal\" - Pode referir-se a uma arquitetura específica ou a um estágio de pipeline (memória) associado à execução do JAL.\n*   16:11: \"o quartus deixa fazer isso?\" - Pergunta sobre a ferramenta Quartus, um ambiente de design para FPGAs da Intel/Altera, indicando que a aula pode envolver implementação de arquiteturas em hardware reconfigurável.\n*   16:13: \"foi o multicilco tbm\" - Refere-se possivelmente a uma arquitetura de CPU de múltiplos ciclos, em contraste com uma arquitetura de ciclo único ou pipelined, na qual a execução de instruções leva múltiplos ciclos de clock.\n*   16:13: \"aí dava 1.21x mais rápido\" - Menciona um ganho de desempenho de 1.21 vezes, provavelmente comparando duas implementações ou otimizações.\n*   16:13: \"= 1.237623762\" - Um valor numérico que pode ser o resultado de um cálculo de desempenho ou uma razão de aceleração mais precisa.\n\n**Pop-up de Sistema (Sobrepondo o Slide):**\n\nUma caixa de diálogo intitulada \"Pausar gravação\" está sobreposta ao conteúdo do slide. A mensagem interna é: \"Tem certeza de que deseja pausar a gravação? Você pode retomar a qualquer momento pressionando o botão de gravação novamente.\" São apresentadas as opções \"Sim\" e \"Não\", com a opção \"Sim\" destacada e selecionada pelo cursor. Este elemento é puramente de UI da plataforma de conferência e não contribui para o conteúdo técnico da aula.",
        "transcription": "Eu sei que o pessoal vai assistir à gravação no final. Certo?",
        "video_source": "OAC_2022-03-30.mp4"
    },
    {
        "id": 16,
        "timestamp_start": 8013.24,
        "timestamp_end": 8024.29,
        "slide_description": "Como um Engenheiro de Computação Sênior, analiso o slide apresentado no contexto de uma aula de Arquitetura de Computadores e extraio as seguintes informações para um sistema de busca semântica (RAG):\n\n**1. Conteúdo do Slide Principal:**\n\n*   **Título do Curso e Instituição:** No canto superior direito, identifica-se a disciplina como \"UnB - CIC0099 - Organização e Arquitetura de Computadores\", pertencente à \"Universidade de Brasília\", \"Departamento de Ciência da Computação\", e ministrada pelo \"Prof. Marcus Vinicius Lamar\".\n*   **Título da Seção:** \"Exercício\".\n*   **Enunciado do Problema:**\n    \"Considerando o workload do compilador gcc, qual a CPI média do RISC-V multiciclo implementado?\"\n*   **Dados do Workload e Latência:**\n    São fornecidas as seguintes distribuições de frequência e custos em ciclos para diferentes tipos de instruções:\n    *   Load: 22% (5 ciclos)\n    *   Store: 11% (4 ciclos)\n    *   Operações logico-aritméticas: 49% (4 ciclos)\n    *   Desvios Condicionais: 16% (3 ciclos)\n    *   Desvios Incondicionais: 2% (3 ciclos)\n*   **Cálculo e Resultado do CPI:**\n    A fórmula para o cálculo do CPI (Cycles Per Instruction) médio é apresentada e resolvida:\n    `CPI = 0.22 × 5 + 0.11 × 4 + 0.49 × 4 + 0.16 × 3 + 0.02 × 3 = 4.04`\n*   **Ausência de Diagramas/Código:** Não há diagramas visíveis (como datapath, pipeline, hierarquia de memória) ou blocos de código (Assembly, C, Verilog) diretamente no slide.\n\n**2. Conteúdo do Chat Lateral (Contexto Adicional da Aula):**\n\nO chat lateral, embora não faça parte do slide em si, fornece contexto e palavras-chave adicionais relevantes para a aula de Arquitetura de Computadores:\n\n*   **Microcódigo:** Discussão sobre \"o microcódigo é a sequencia daquela tabela anterior\", indicando que slides anteriores abordaram a implementação de microcódigo.\n*   **Instrução JAL (Jump and Link):** Várias mensagens referem-se à instrução `jal` (\"Se eu quisesse um jal com contador de jal dava para fazer\", \"seria mem1 com jal\"), sugerindo um tópico de discussão sobre controle de fluxo, sub-rotinas e possivelmente implementação de contadores de programas.\n*   **Ferramentas de Hardware:** Menciona \"o quartus deixa fazer isso?\", referindo-se provavelmente ao Intel Quartus Prime, um software para design de FPGAs, indicando que a discussão pode envolver a implementação prática em hardware.\n*   **Desempenho Multiciclo:** Referências ao \"multiciclo\" e a comparações de desempenho, como \"foi o multicilco tbm\" e \"aí dava 1.21x mais rápido\", além de um valor numérico \"1,237623762\", que pode ser um fator de speedup ou outra métrica de performance. Isso reforça o contexto do slide principal sobre CPI em processadores multiciclo.\n\n**Resumo para RAG:**\nEste slide de Arquitetura de Computadores (UnB - CIC0099) apresenta um exercício detalhado de cálculo do CPI médio para uma arquitetura RISC-V multiciclo, considerando um workload do compilador GCC. Ele especifica as porcentagens de ocorrência e os custos em ciclos para instruções de Load, Store, Operações Lógico-Aritméticas, Desvios Condicionais e Desvios Incondicionais, culminando no cálculo `CPI = 4.04`. O chat anexo expande o contexto para incluir discussões sobre microcódigo, a instrução RISC-V JAL, ferramentas como Quartus e métricas de desempenho para sistemas multiciclo.",
        "transcription": "Então, parei a gravação aqui. E vou parar. Então, 1,2376x mais rápido. E vou parar a gravação aqui.",
        "video_source": "OAC_2022-03-30.mp4"
    }
]